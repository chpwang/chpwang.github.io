<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content>
  
  <title>快速上手 Python</title>
  <meta name="author" content="chpwang">
   <meta name="description" content="王哈哈的修行驿站">
  

  <meta property="og:title" content="快速上手 Python">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="行侠何须仗名剑">
 <meta property="og:image" content>
  
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="行侠何须仗名剑" type="application/atom+xml">
  <!-- link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" -->
  <!-- link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" -->
  <!-- 把 bootstrap 3.3.6 本地化，免得连不上它的服务器，相关文件放在了 pln/source/bootstrap 里-->
  <link rel="stylesheet" href="/css/bootstrap/css/bootstrap.min.css">
  <!-- 把 font-awesome 4.5.0 本地化，免得连不上它的服务器，相关文件放在了 pln/source/font-awesome 里 -->
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">
  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/css/highlight/styles/vs2015.css">
  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/css/m.min.css">
  <!--link rel="icon" type="image/x-icon" href="/favicon.ico"-->
  <link rel="icon" type="image/x-icon" href="/G.png"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="main">
    <div class="behind">
      <div class="back">
        <a href="/" class="black-color"><i class="fa fa-times" aria-hidden="true"></i></a>
      </div>
      <div class="description">
        &nbsp;
      </div>
    </div>
    <div class="container">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        快速上手 Python
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2018-05-10T11:23:26.000Z">
  <i class="fa fa-calendar"></i>&nbsp;
  2018-05-10
</time>






    
    &nbsp;
    <i class="fa fa-tag"></i>&nbsp;
    <a href="/tags/Programming-Language/">Programming Language</a>


    </div>
    <hr>
    <div class="picture-container">
      
    </div>
    <p>像 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript#" target="_blank" rel="noopener">JavaScript</a> 这类语言的设计，适合新手学习理解特别简单编程概念。比如<strong>函数</strong>。但如果要理解<strong>面向对象（Object Oriented）</strong>的概念，用 <strong>JavaScript</strong> 会比较绕。因为它设计比较奇怪，你得去理解一些专门针对 <strong>JavaScript</strong> 设计的东西。</p>
<p>相比之下，用 <a href="https://www.python.org" target="_blank" rel="noopener">Python</a> 来理解面向对象，思路会清晰很多。而且 Python 也有好的 IDE 支持（PyCharm 挺不错的）。当前 Python 特别流行，也是有一定原因的。</p>
<hr>
<h3 id="Python-编程环境"><a href="#Python-编程环境" class="headerlink" title="Python 编程环境"></a>Python 编程环境</h3><p>一般推荐两个编辑器，或者说 IDE ，来快速实践各种代码：</p>
<ul>
<li><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a>：微软开发的一款超轻量 IDE ，<a href="http://teahour.fm/2017/12/12/why-vscode-is-better-than-atom.html" target="_blank" rel="noopener">Teahour 91期</a> 有介绍，使用方法参考 <a href="/2018/05/25/vscode-intro/">快速上手 VS Code</a></li>
<li><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a>：JetBrains 团队开发的一款 Python 的 IDE ，安装和使用方法参考这个 <a href="https://www.youtube.com/watch?v=BPC-bGdBSM8" target="_blank" rel="noopener">YouTube 视频</a> </li>
</ul>
<p>此外，还可以选择 <a href="/2018/05/27/set-up-anaconda/">安装配置 Anaconda</a> ，以使用 Anaconda 附带的 Python 在终端里运行。</p>
<pre><code class="lang-bash">## 通过 Homebrew 安装 python
$ brew install python3

## 查看 Python 的版本
$ python3 --version
Python 3.6.5 :: Anaconda custom (64-bit)

## 运行 *.py 的 Python 脚本文件
$ cat ~/scripts/first_script.py         # 显示 first_script.py 文件里的内容
print(&#39;Congratulations on running this script!!&#39;)

$ python3 ~/scripts/first_script.py     # 用 python3 运行 first_script.py 文件
Congratulations on running this script!!

## 直接输入命令 python ，不带任何文件和参数，会进入 interactive interpreter（交互式解释器），可进行各种 Python 的语法测试
$ python3
[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;exit()
$
</code></pre>
<p>PS:<br>个人推荐新手使用 <a href="https://code.visualstudio.com" target="_blank" rel="noopener"><strong>VS Code</strong></a> ，这东西介于编辑器和 IDE（Integrated Development Environment）之间，既有编辑器的简洁，又有 IDE 的强大功能，关键是安装配置起来特别简单，最适合新手。<br>可以参考这篇<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 设置 Python 的运行环境。</p>
<hr>
<h3 id="Python-的一些基本规则"><a href="#Python-的一些基本规则" class="headerlink" title="Python 的一些基本规则"></a>Python 的一些基本规则</h3><ol>
<li>变量区分大小写，即 case sensitive</li>
<li>空格重要，附带语意，即 spacing matters</li>
<li>运算符号有优先级（比如乘除法 * / 优先级高于加减法 +-）</li>
<li>运算的优先级可以使用括号来确定：优先级方向为从里往外</li>
<li>Python 中名为 <code>_</code> 的变量（underscore variable）多数情况下代表忽略这个值，其他详细参见<a href="https://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc" target="_blank" rel="noopener">这里</a></li>
<li>Python 变量名的规则不用 listSum 这种大小写混合，而是用下划线分隔多个单词，写成 list_sum 这样</li>
<li><p>Python 赋值时是「传址（引用）」效果，而不是「传值」效果。见下例：</p>
<pre><code class="lang-python">a = [1, 2, 3]
b = a        # b 和 a 指向同一个列表对象，而不是把 a 的内容复制给 b
b.append(4)  # 修改 b 的内容，a 也会一起改变
print(a)     # 输出 [1, 2, 3, 4]

# 如果函数参数有默认值，这个值又是可变对象时，容易出错
def foo(data=[]):
 data.append(1)
 return data

print(foo())  # [1]
print(foo())  # [1, 1] - 意外结果
</code></pre>
</li>
</ol>
<p>附：<br><a href="https://www.jianshu.com/p/a793c0d960fe" target="_blank" rel="noopener">Python 命名规范</a></p>
<hr>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><p>整数 - <strong>int</strong></p>
<pre><code class="lang-bash">&gt;&gt;&gt; 2 * 3
6
&gt;&gt;&gt; 3 // 2  # 取整
1
</code></pre>
</li>
<li><p>浮点数 - <strong>float</strong><br>整数和浮点数在电脑里是有差别的，整数和浮点数混合计算会被转化为浮点数，结果也是浮点数</p>
<pre><code class="lang-bash">&gt;&gt;&gt; 3 / 2
1.5
&gt;&gt;&gt; 1.5 * 2
3.0
</code></pre>
</li>
<li><p>复数 - <strong>complex</strong><br>这是一种用于数学计算的数据类型，Python 中用 <code>j</code> 来表示虚数</p>
<pre><code class="lang-bash">&gt;&gt;&gt; (1 + 2j) * (1 + 2j)
(-3+4j)
</code></pre>
</li>
<li><p>字符串 - <strong>string</strong><br>可以用单引号 <code>&#39;hello&#39;</code> ，也可以用双引号 <code>&quot;hello&quot;</code><br>一个常用的字符串方法：<a href="https://docs.python.org/3/library/stdtypes.html#str.split" target="_blank" rel="noopener"><code>str.split()</code></a></p>
<pre><code class="lang-bash">&gt;&gt;&gt; &#39;1,2,3&#39;.split(&#39;,&#39;)
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
&gt;&gt;&gt; &#39;1,2,3&#39;.split(&#39;,&#39;, maxsplit=1)
[&#39;1&#39;, &#39;2,3&#39;]
&gt;&gt;&gt; &quot;1,2,,3,&quot;.split(&#39;,&#39;)
[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]
</code></pre>
</li>
<li><p>布尔类型 - <strong>bool</strong><br>Python 中不用 <code>&amp;&amp;</code> 而是用 <code>and</code> 来代表「<strong>且</strong>」<br>其实 <code>&amp;&amp;</code> 并不是一个好设计，因为这个符号没有 <code>and</code> 直观易懂</p>
<pre><code class="lang-bash">&gt;&gt;&gt; 1&lt;2 and 3&gt;4
False
&gt;&gt;&gt; 1&lt;2 or 3&gt;4
True
&gt;&gt;&gt; not 1&lt;2
False
&gt;&gt;&gt; 1 == 2
False
&gt;&gt;&gt; type(1==2)
&lt;class &#39;bool&#39;&gt;                # 注意这里返回的类型，不是「字符串」
&gt;&gt;&gt; type(type(1==2))
&lt;class &#39;type&#39;&gt;                # 它是一个 type 类，即 class &#39;type&#39;
&gt;&gt;&gt; type(1==2) == &quot;bool&quot;      # 所以不能用这种方式来判断数据的类型
False
&gt;&gt;&gt; type(1==2) == type(1&lt;2)   # 对应地，可以用这种方式来判断数据类型
True
&gt;&gt;&gt; type(1==2) == type(False) # Python 的类型设计是要比 JavaScript 严格很多的
True                          # 所以做科学计算或者 AI 用的就是 Python 而不是 JavaScript

## 正规判断类型的方法是用 isinstance(object, type)
&gt;&gt;&gt; isinstance(2, bool)
False
&gt;&gt;&gt; isinstance(2 &lt; 3, bool)
True
</code></pre>
</li>
<li><p><strong>None</strong><br>这是 Python 里面的一种专门的数据类型，代表「没有」，类似 JavaScript 里的 Null</p>
<pre><code class="lang-bash">&gt;&gt;&gt; None         # 注意第一个字母 N 是大写
&gt;&gt;&gt; x = None
&gt;&gt;&gt; x            # 没输出不显示
&gt;&gt;&gt; print(x)     # 用 print 能打印出来
None
&gt;&gt;&gt; print(None)
None
</code></pre>
</li>
</ul>
<hr>
<h3 id="基本的数据结构"><a href="#基本的数据结构" class="headerlink" title="基本的数据结构"></a>基本的数据结构</h3><ul>
<li><p>列表 - <strong>List</strong><br>在编程中，「<code>链表（Linked List）</code>」和「<code>列表（List）</code>」通常不是同一个概念：<br><strong>链表</strong>是一种数据结构，由一系列节点组成，每个节点包含数据以及指向下一个节点的指针；<br><strong>列表</strong>是一种抽象数据类型（ADT），用来存储一系列元素的有序集合。列表可以有不同的实现方式，包括数组、链表等，甚至可以是其他数据结构的组合。<strong>链表</strong>是<strong>列表</strong>的一种实现方式；<br>在编程中，「<strong>列表</strong>」通常更广泛地指代一种抽象数据类型，而「<strong>链表</strong>」则更具体地指代一种特定的数据结构。<br>因此，它们的主要区别在于抽象性和具体性；</p>
<pre><code class="lang-bash">&gt;&gt;&gt; li = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]

## li 的定义看起来像数组，但其实不是，它的类型是 class &#39;list&#39;
## 但你可以认为它就是一个数组
&gt;&gt;&gt; type(li)
&lt;class &#39;list&#39;&gt;

## 所以你可以用下标访问 - 下标从 0 开始
&gt;&gt;&gt; li[0]
1

## slice 操作
## 访问 list 中下标从 0 到 2 的部分 - 注意这里不包括 li[2]
## 相当于 [0, 2) 的感觉
&gt;&gt;&gt; li[0:2]
[1, 2]

## 访问从头到某个下标（不包括 li[1]）
&gt;&gt;&gt; li[:1]
[1]

## 访问从某个下标到最后
&gt;&gt;&gt; li[1:]
[2, 3]

## 赋值或者定义的时候，传递的是引用，而不是复制一份
&gt;&gt;&gt; li
[1, 2, 3]
&gt;&gt;&gt; li2 = li
&gt;&gt;&gt; li2[1] = 9    # 可以看到 li2 改变的同时，li 也被改变了
&gt;&gt;&gt; li
[1, 9, 3]

## 如果要复制一份而不是传递引用，需要用 .copy() 这个方法
&gt;&gt;&gt; li2 = li.copy()
&gt;&gt;&gt; li[1] = 2
&gt;&gt;&gt; li2
[1, 9, 3]
&gt;&gt;&gt; li
[1, 2, 3]     # 所以在使用 python 的时候你要注意它是同一个对象还是不同的

## 越界访问会报错 - 这是个好设计
## 如果返回 undefined 之类的数据，就有可能被到处传递引发潜在问题而难以被定位纠正
&gt;&gt;&gt; li[3]
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: list index out of range

## 计算列表长度
&gt;&gt;&gt; len(li)
3

## 使用 dir 可以看到一个类型（对象）里有哪些方法（methods）
&gt;&gt;&gt; dir(li)
[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__class_getitem__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, 
&#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, 
&#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, 
&#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, 
&#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, 
&#39;reverse&#39;, &#39;sort&#39;]

## 按 2 次 Tab 键进行补全，它就会提示你当前可用的所有方法（methods）
&gt;&gt;&gt; li.
li.append(  li.copy(    li.extend(  li.insert(  li.remove(  li.sort(
li.clear(   li.count(   li.index(   li.pop(     li.reverse(

## 插入元素 - 这里 insert 元素到开头还是比较费事的，不像 pair 那种 list 时间复杂度只有 O(1)
## 为了程序的效率，一般不会把东西插到中间
&gt;&gt;&gt; li.insert(0, 9)
&gt;&gt;&gt; li
[9, 1, 2, 3]

## 排序
&gt;&gt;&gt; li.sort()
&gt;&gt;&gt; li
[1, 2, 3, 9]

## 取出最后一个元素
&gt;&gt;&gt; li.pop()
9
&gt;&gt;&gt; li
[1, 2, 3]

## 列表里增加新元素（element）
## 效果一
&gt;&gt;&gt; li.append([4])
&gt;&gt;&gt; li
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4]]  # 可以看到 list 里每个元素的类型不一定要相同 

## 效果二
&gt;&gt;&gt; li.extend([4])
&gt;&gt;&gt; li
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4]

## 效果三
&gt;&gt;&gt; li + [5]
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4, 5]
&gt;&gt;&gt; li
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4]

## 使用「列表推导式（List Comprehension）」来生成 List
&gt;&gt;&gt; li_c = [x**2 for x in range(10)]
&gt;&gt;&gt; li_c
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 「列表推导式」中的 if
&gt;&gt;&gt; [x for x in li_c if x % 2 == 0]
[0, 4, 16, 36, 64]

## 「列表推导式」中的 if-else
## 注意这里用了跟上面单纯的 if 不同的结构，所以 if 和 for 的位置顺序也不一样  
## The expression 「 x if C else y 」 first evaluates the condition, C rather than x. 
## If C is true, x is evaluated and its value is returned.
## Otherwise, y is evaluated and its value is returned.
&gt;&gt;&gt; [x if x % 2 == 0 else 3 for x in li_c]
[0, 3, 4, 3, 16, 3, 36, 3, 64, 3]

## 「列表推导式」中的「列表推导式」- 嵌套
&gt;&gt;&gt; [ [x**2 for x in li] for li in [[1,3,5], [2,4,6]] ]
[[1, 9, 25], [4, 16, 36]]

## 对 List 中的元素进行 map 操作
&gt;&gt;&gt; list(map(lambda x:x+1, li_c))
[1, 2, 5, 10, 17, 26, 37, 50, 65, 82]
</code></pre>
</li>
<li><p>元组 - <strong>tuple</strong><br><code>tuple</code> 和 <code>list</code> 的区别在于，<code>tuple</code> 是不可更改的</p>
<pre><code class="lang-bash">## Tuple 用的是括号来表示，区别于 list 的方括号 []
&gt;&gt;&gt; t = (1, 2, 3, 4, 5, 5, 5)
&gt;&gt;&gt; t[1]
2

## 无法更改
&gt;&gt;&gt; t[1] = 0
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;tuple&#39; object does not support item assignment

## len 函数可以接收多种数据类型 - 这里是一个面向对象语言好的地方
&gt;&gt;&gt; len(t)
7
</code></pre>
</li>
<li><p>字典 - <strong>dict</strong><br>字典本质上就是哈希表，即键值对（key-value pair）。比如对于 <code>{&#39;Ace&#39;: 1, &#39;Queen&#39;: 12}</code> 这一字典来说，<strong>‘Ace’</strong> 和 <strong>‘Queen’</strong> 就是<strong>键</strong>（Key），而对应的 <strong>1</strong> 和 <strong>12</strong> 就是<strong>值</strong>（Value）</p>
<pre><code class="lang-bash">## dict 用花括号来表示，类型是 class &#39;dict&#39;
&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2}
&gt;&gt;&gt; d
{&#39;a&#39;: 1, &#39;b&#39;: 2}
&gt;&gt;&gt; type(d)
&lt;class &#39;dict&#39;&gt;

## 你需要用下标来访问，而不能当成对象（object）来用
## Python 里把 dict 和 object 区分开了 - 这是一个好设计
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a                                # 用 .a 来访问会报错
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;dict&#39; object has no attribute &#39;a&#39;

## 修改和添加
&gt;&gt;&gt; d[&#39;a&#39;] = 5         # 赋值
&gt;&gt;&gt; d[&#39;c&#39;] = 12        # 添加新的 key
&gt;&gt;&gt; d
{&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;c&#39;: 12}

## 判断某个 key 是否存在与某个字典中（注：case sensitive）
&gt;&gt;&gt; &quot;ace&quot; in {&#39;ace&#39;: 1}
True

## 计算字典长度
&gt;&gt;&gt; state_value = {(6, 10, False): -1.0, (15, 10, False): -1.0}
&gt;&gt;&gt; len(state_value)
2

## 使用「列表推导式（List Comprehension）」来生成字典（dictionary）
&gt;&gt;&gt; vocab_to_int = {word: ii for ii, word in int_to_vocab.items()}

## 这里也可以用「列表推导式（List Comprehension）」来实现使用函数 f 来对字典的内容进行 Map
{k: f(v) for k, v in my_dictionary.items()}
</code></pre>
<p>模组 <a href="https://docs.python.org/3/library/collections.html" target="_blank" rel="noopener"><strong>collections</strong></a> 中的 <strong>defaultdict</strong> 类能更方便地处理 value 为列表（list）、字典（dictionary）的情况，其用法参见<a href="https://www.accelebrate.com/blog/using-defaultdict-python/" target="_blank" rel="noopener">Using defaultdict in Python</a></p>
<pre><code class="lang-bash">&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; city_list = [(&#39;TX&#39;,&#39;Austin&#39;), (&#39;TX&#39;,&#39;Houston&#39;), (&#39;NY&#39;,&#39;Albany&#39;), (&#39;NY&#39;, &#39;Syracuse&#39;), (&#39;NY&#39;, &#39;Buffalo&#39;), (&#39;NY&#39;, &#39;Rochester&#39;), (&#39;TX&#39;, &#39;Dallas&#39;), (&#39;CA&#39;,&#39;Sacramento&#39;), (&#39;CA&#39;, &#39;Palo Alto&#39;), (&#39;GA&#39;, &#39;Atlanta&#39;)]
&gt;&gt;&gt;
&gt;&gt;&gt; cities_by_state = defaultdict(list)
&gt;&gt;&gt; for state, city in city_list:
...     cities_by_state[state].append(city)
...
for state, cities in cities_by_state.iteritems():
...     print state, &#39;, &#39;.join(cities)
...
NY Albany, Syracuse, Buffalo, Rochester
CA Sacramento, Palo Alto
GA Atlanta
TX Austin, Houston, Dallas
</code></pre>
</li>
<li><p>集合 - <strong>set</strong><br>集合也是数学计算中会常用到的数据结构：</p>
<pre><code class="lang-bash">## Set 也是花括号，可以注意到内部的顺序是乱的
&gt;&gt;&gt; s = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;t&#39;, &#39;hello&#39;}
&gt;&gt;&gt; s
{&#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}

## 增加元素
&gt;&gt;&gt; s.add(&#39;world&#39;)
&gt;&gt;&gt; s
{&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}

## 判断某个元素是否存在 - 可以认为这是个二元操作（binop）
&gt;&gt;&gt; &#39;t&#39; in s
True
&gt;&gt;&gt; &#39;hi&#39; in s
False

## set 的相关运算
&gt;&gt;&gt; s2 = {&#39;a&#39;, &#39;t&#39;, &#39;world&#39;, &#39;y&#39;, &#39;i&#39;}
&gt;&gt;&gt; s - s2
{&#39;b&#39;, &#39;hello&#39;, &#39;c&#39;}
&gt;&gt;&gt; s
{&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}             # 不会改变原来的集合 s
&gt;&gt;&gt; s.intersection(s2)
{&#39;world&#39;, &#39;t&#39;, &#39;a&#39;}                                # 交集
&gt;&gt;&gt; s.union(s2)
{&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;c&#39;, &#39;i&#39;, &#39;y&#39;, &#39;hello&#39;, &#39;a&#39;}   # 并集
</code></pre>
</li>
</ul>
<hr>
<h3 id="Python-中的注释"><a href="#Python-中的注释" class="headerlink" title="Python 中的注释"></a>Python 中的注释</h3><ul>
<li>以 <code>#</code> 开头的行</li>
<li>以 <code>&quot;&quot;&quot;</code>（三个双引号）包裹的代码块（Code Block）</li>
</ul>
<pre><code class="lang-python">## codes by chpwang - 2018-05-17 04:57:56

&quot;&quot;&quot;
任务3:
xxxxxx
&quot;&quot;&quot;
</code></pre>
<hr>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>Python 里面定义变量不需要 <code>var</code> 这类关键词，直接写就行，末尾也不用分号。</p>
<pre><code class="lang-python">## 变量定义
x = 2 * 3

## 赋值
x = 12

## 变量定义还可以解析结构
l1 = [9, 8]
[u, v] = l1

print(u)  # 9
print(v)  # 8
</code></pre>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Python 里面经常用「冒号」来分隔语言的各个部分。这里参数后面是冒号。新手要注意，冒号容易忘记写。</p>
<pre><code class="lang-python">## 匿名函数 x =&gt; x * x
lambda x: x * x

## 函数调用
(lambda x: x * x)(3)

## 函数定义
square1 = lambda x: x*x

def square2(x): return x*x

## 这里「缩进」很重要，python 靠缩进来判断函数体
## 如果函数体语句多，注意缩进要对齐，不能有的缩进 2 格，有的只缩进 1 格
## 「缩进」是一种危险的糟糕设计，容易出错，比如有时 return 缩进错了，可能就跑到外部去了
## 缩进设计似乎只是为了少写一些括号
def square3(x):
  return x*x


result1 = 10
result2 = 10

## square4 中的 result 是局部变量，不改变外面的 result
def square4(x):
  result1 = x*x
  return result

## 加了 global 关键词后，square5 中的 result 就是全局变量了
## 调用 square5 会改变外面的 result
def square5(x):
  global result
  result = x*x
  return result

print(square4(4))  # 16
print(result1)     # 10
print(square5(4))  # 16
print(result1)     # 16


## 函数也可以什么都不做，但要写一个 pass ，不能什么都不写
def do_nothing(x):
  pass
</code></pre>
<pre><code class="lang-bash">&gt;&gt;&gt; def minus(x, y): return x - y
...
&gt;&gt;&gt; minus(9, 6)
3
&gt;&gt;&gt; minus(y=9, x=6)  # python 的函数调用可以指定参数的值，这样可以无视参数的调用顺序
-3                   # 好处是如果参数比较多，把各参数名和值写上，代码阅读起来就很直观 - 这是个好设计
</code></pre>
<hr>
<h3 id="条件分支-if-语句"><a href="#条件分支-if-语句" class="headerlink" title="条件分支 - if 语句"></a>条件分支 - if 语句</h3><p><strong>注意</strong>，<code>else if</code> 分支在这里写作 <code>elif</code></p>
<pre><code class="lang-python">def fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)


if season == &#39;spring&#39;:
    print(&#39;plant the garden!&#39;)
elif season == &#39;summer&#39;:
    print(&#39;water the garden!&#39;)
else:
    print(&#39;unrecognized season&#39;)


## 三元操作符（Ternary Operator）写法
x = true_value if condition else false_value

## lambda 中的 if - 无法在 lambda 匿名函数中使用 print 打印，或者 raise 报错
lambda x: True if x % 2 == 0 else False
</code></pre>
<hr>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="lang-bash">## Python 中的循环一般不用下标
&gt;&gt;&gt; a = [2, 3, 4, 6]
&gt;&gt;&gt; for x in a:
...  print(x)
...
2
3
4
6

## 可以使用这种模式匹配来直接取出 key 和 value 而不用后续访问下标 - 这是好设计
&gt;&gt;&gt; for [k, v] in [[&quot;dog&quot;, 1], [&quot;cat&quot;, 2], [&quot;fish&quot;, 3]]:
...     print(f&quot;{k}: {v}&quot;)
...
dog: 1
cat: 2
fish: 3

## 模式匹配（pattern match）还可以用于赋值，比如交换变量的数据
&gt;&gt;&gt; [x, y] = [3, 4]
&gt;&gt;&gt; x
3
&gt;&gt;&gt; y
4
&gt;&gt;&gt; [x, y] = [y, x]
&gt;&gt;&gt; x
4
&gt;&gt;&gt; y
3

## 和 range(start, stop, step) 函数结合使用
&gt;&gt;&gt; for i in range(0, 2, 1):
...     print(i)
...
0
1

## 这里说明一下这个 range
## 可以认为 range(5) 的效果就相当于生成了一个 [0, 1, 2, 3, 4] 这样的 list
## 然后我们就可以 for i in range(5)
## 虽然效果上是一样的，但实际上 range 不会真的生成一个 list
## range 多用于循环，如果真生成一个 list ，就会影响计算性能并占用空间
## 比如这样一来 range(1000000) 就很吃计算资源了
## range 实际上生成的是一种 lazy list（惰性列表）
## 惰性列表的意思是，它不会真的给你放到内存里面去
## range(5) 会返回一个 range 对象，按需计算元素的值，内存高效（memory efficient）

## python 中的 for 循环都要用 for x in ... 这种形式，如果 x 是是数字，就要用这个 range
## 有人认为这样的 for 循环表达能力有限，不能表达复杂的逻辑，range 只能表达简单的数字
## 比如无法写出类似 for(var i=0, j=array.length; i &lt; j; i++, j--) 的代码
## 但其实这是 python 的一个好设计。当表达不了的时候，就不应该使用 for 循环，而要改用 while 循环
## 上述复杂的 for 循环需要思考到底是先判断 i &lt; j 还是先计算 i++ 和 j--，不利于代码阅读理解

## 用 reversed 配合 range 倒数
## 写成 for i in range(4, -1, -1) 虽然是同样的效果，但阅读理解上不直观
&gt;&gt;&gt; for i in reversed(range(0, 5)):
...     print(i)
...
4
3
2
1
0

# 和 zip() 函数结合使用
&gt;&gt;&gt; alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;]
&gt;&gt;&gt; blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;]
&gt;&gt;&gt; for a, b in zip(alist, blist):
...     print(a, b)
...
a1 b1
a2 b2
a3 b3

## upack 一个 list 也是常用的循环 - 若觉得下行的说明不清楚就开终端试一试
## 此例第 1 次循环取出第一个元素 [1, 3]，然后把第一项和第二项分别赋值给 a 和 b
&gt;&gt;&gt; for a, b in [[1,3],[2,4]]:
...     print(a)
...     print(b)
...
1
3
2
4

## 使用 * （星号 star）和 zip 来操作 list
## 下划线符号：_ 在 Python 中代表占位符，相当于吃掉这两个位置的输出 - 下面的代码原本会输出 3 个结果，但只想要其中最后一个结果，所以使用下划线来抛弃前两个结果 
&gt;&gt;&gt; _, _, rewards = zip(*[((6, 10, False), 1, 0), ((17, 10, True), 1, 0), ((21, 10, True), 0, 1.0)])
&gt;&gt;&gt; rewards
(0, 0, 1.0)

## while 循环
&gt;&gt;&gt; while i &lt; 6:
...   print(i)
...   if i==3:
...     break
...   i += 1
...
1
2
3
</code></pre>
<hr>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 - class"></a>类 - class</h3><p>这里以实现查找表为例演示 <code>class</code> 的用法：</p>
<ul>
<li>python 的类里要有这个 <code>__init__</code> 作为「构造函数」，如果没写 Python 也会给一个默认的：<br><code>def __init__(self): pass</code></li>
<li>类里面绑定到具体实例的函数，第一个参数通常都是 <code>self</code>，这是个自动接收的参数，代表类的当前实例对象</li>
<li>@classmethod 和 @staticmethod 标记的函数</li>
</ul>
<pre><code class="lang-python">## Map 没有定义 __init__ ，但还是程序还是会给它一个默认的 __init__
class Map:
  def print_data(self):
    print(&quot;&#39;Map&#39; object has no attribute &#39;data&#39;&quot;) 


class Table:
  def __init__(self):
    self.data = []

  def add(self, key, value):
    self.data.insert(0, [key, value])

  def lookup(self, key):
    for [k, v] in self.data:
      if k == key:
        return v
    return None


class Hash:
  def __init__(self):
    self.data = {}

  def add(self, key, value):
    self.data[key] = value

  def lookup(self, key):
    return self.data[key]
</code></pre>
<hr>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>这里介绍的是常用的输出语法，更详细的介绍可以参考这篇 <a href="https://www.digitalocean.com/community/tutorials/how-to-use-string-formatters-in-python-3" target="_blank" rel="noopener">How to use <strong><em>str.format()</em></strong></a></p>
<pre><code class="lang-bash">## 普通输出 - 使用 {} 占位，.format() 填充占位符
&gt;&gt;&gt; print(&quot;{} ~ {}% dog wins.&quot;.format(3, 9))
3 ~ 9% dog wins.

## 保留 5 位小数
&gt;&gt;&gt; print(&quot;{} - {:.5f}&quot;.format(3,9.0/3.5))
3 - 2.57143

## 保留 1 位小数
&gt;&gt;&gt; print(&quot;{} - {:.1f}&quot;.format(3,9.0/3.5))
3 - 2.6
</code></pre>
<p>在 Python 中，还可以使用 <code>f-string</code> 这种种字符串格式化的方法来输出。只需在<strong>字符串</strong>前加上字母 <code>f</code> 或 <code>F</code> ，然后在字符串中使用花括号 <code>{}</code> 包裹要插入的变量或表达式：</p>
<pre><code class="lang-python">name = &quot;Alice&quot;
age = 30
height = 1.75

print(f&quot;My name is {name}, I am {age} years old.&quot;)    # 使用 f-string 插入变量值
# My name is Alice, I am 30 years old.

print(f&quot;Next year, I will be {age + 1} years old.&quot;)   # 可以在 f-string 中进行简单的表达式计算
# Next year, I will be 31 years old.

print(f&quot;My height is {height:.2f} meters.&quot;)           # 使用 f-string 格式化浮点数
# My height is 1.75 meters.
</code></pre>
<hr>
<h3 id="自解释器"><a href="#自解释器" class="headerlink" title="自解释器"></a>自解释器</h3><p>Python 中的内置函数 <code>eval</code> 可以将字符串解析成 Python 的代码</p>
<pre><code class="lang-python">## test.py
num = 30
x = eval(&quot;num + 29&quot;)
print(x)
</code></pre>
<pre><code class="lang-bash">$ python test.py
59
</code></pre>
<hr>
<h3 id="创建与导入脚本"><a href="#创建与导入脚本" class="headerlink" title="创建与导入脚本"></a>创建与导入脚本</h3><p>处理大型项目时，可以将代码分割，整理成多个 <code>*.py</code> 文件以便重复利用这些文件中的代码。这些 <code>*.py</code> 文件称为脚本（script）。如果你要导入的 Python 脚本与当前脚本位于同一个目录下，只需输入 import，然后是文件名，无需扩展名 <code>.py</code></p>
<pre><code class="lang-python">## demo.py
import useful_functions as uf

scores = [88, 92, 79, 93, 85]
mean = uf.mean(scores)

print(&quot;Demo Mean:&quot;, mean)
print(&quot;__name__ value:&quot;, __name__)
print(&quot;uf.__name__ value:&quot;, uf.__name__)
</code></pre>
<pre><code class="lang-python">## useful_functions.py

def mean(num_list):
    return sum(num_list) / len(num_list)

def main():
    n_list = [34, 44, 23, 46, 12, 24]
    print(&quot;Useful Functions&#39; Mean:&quot;, mean(n_list))

# 检测当前脚本（即 useful_functions.py）是否做为主模块被运行
# 当前脚本若是被其他脚本的 import 语句导入，则下面的 if main 块代码不运行
if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>运行结果如下：</p>
<pre><code class="lang-bash">$ ls
demo.py             useful_functions.py
$ python demo.py
Demo Mean: 87.4
__name__ value: __main__
uf.__name__ value: useful_functions
</code></pre>
<p>人们通常只希望重复使用被导入脚本里的「函数」或「类」，而不是其他可执行代码（如 <code>print()</code>），所以为避免「<strong>脚本A</strong>」被导入后，其中的可执行语句被运行，应该要将这些语句包含在 <code>if __name__ == &quot;__main__&quot;</code>块中，或者，将它们包含在函数 <code>main()</code> 中并在上述 <code>if main</code> 块中调用该函数。</p>
<p>每当运行脚本时（<code>*.py</code> 文件），Python 会为所有模块（module）设置一个特殊的内置变量 <code>__name__</code>。这些模块包含导入模块（用 <code>import</code> 语句导入的），还有主模块（即当前脚本）。主模块的 <code>__name__</code> 变量值会被设为字符串 <code>&quot;__main__&quot;</code>，而对于被导入的模块，<code>__name__</code> 变量会设为该模块的名称。因此 <code>if main</code> 代码块常用来判断是否为主模块。</p>
<p>PS：<br>从输出结果可看到，上述例子中，被导入模块的 <code>__name__</code> 值为 <code>&quot;useful_functions&quot;</code></p>
<hr>
<h3 id="自定义一个类-复杂例子"><a href="#自定义一个类-复杂例子" class="headerlink" title="自定义一个类 - 复杂例子"></a>自定义一个类 - 复杂例子</h3><pre><code class="lang-python">import math
from decimal import Decimal, getcontext

## 设置 Decimal 数据类型的小数点后保留的位数
getcontext().prec = 19
## 用来辅助判断一个数是否为零（小于此值则为零）
TOLERANCE = 1e-10

class Vector(object):

  ## 设置报错信息
  ALL_ELEMENT_MUST_BE_NUM_MSG = &quot;Element must be number!&quot;

  ## 实例（instance）的创建
  def __init__(self, coordinates):
    try:
      if not coordinates:
          raise ValueError
      self.coordinates = tuple([Decimal(x) for x in coordinates])
      self.dimension = len(coordinates)

    except ValueError:
      raise ValueError(&#39;The coordinates must be nonempty&#39;)

    except TypeError:
      raise TypeError(&#39;The coordinates must be an iterable&#39;)

  ## print 输出内容
  def __str__(self):
    return &#39;Vector: {}&#39;.format(self.coordinates)

  ## 定义相等
  def __eq__(self, v):
    return self.coordinates == v.coordinates

  def __len__(self):
    return len(self.planes)

  ## __getitem__ 这个函数使得对于 v = Vector([5, 3, -2]) ，可使用索引方式 v[1] 得到数字 3
  def __getitem__(self, i):
    return self.coordinates[i]

  ## __setitem__ 这个函数使得对于 v = Vector([5, 3, -2]) ，可使用索引方式 v[1] = 9 将 v[1] 的值设置为 9
  def __setitem__(self, i, x):
    try:
      assert x.dimension == self.dimension  # 如果设置的 x 不是数字，则报错
      self.coordinates[i] = x

    except AssertionError:
      raise Exception(self.ALL_ELEMENT_MUST_BE_NUM_MSG)

  ## 计算向量的加法
  def plus(self, v):
    new_coordinates = [x+y for x,y in zip(self.coordinates, v.coordinates)]
    return Vector(new_coordinates)

  ## 计算向量的减法
  def minus(self, v):
    return self.plus(v.times_scalar(-1))

  ## 计算向量的数乘
  def times_scalar(self, c):
    new_coordinates = [x*c for x in self.coordinates]
    return Vector(new_coordinates)

  ## 计算向量与另一向量的点积（内积）
  def dot_product_with(self, v):
    new_coordinates = [x*y for x,y in zip(self.coordinates, v.coordinates)]
    return sum(new_coordinates)

  ## 计算向量的模
  def magnitude(self):
    return Decimal(math.sqrt(self.dot_product_with(self)))

  ## 计算向量标准化后的向量（同方向上的单位向量）
  def normalization(self):
    try:
      mag = self.magnitude()
      return self.times_scalar(Decimal(1)/mag)
    except ZeroDivisionError:
      #print(&quot;You can&#39;t normalize Zero Vector!&quot;)
      raise Exception(&quot;You can&#39;t normalize Zero Vector!&quot;)

  ## 计算向量与另一向量的夹角
  def angle_with(self, v, in_degrees=False):
    try:

      mag_1 = self.magnitude()
      mag_2 = v.magnitude()
      if in_degrees:
        return math.degrees(math.acos(self.dot_product_with(v)/(mag_1*mag_2)))
      else:
        return math.acos(self.dot_product_with(v)/(mag_1*mag_2))

    except ZeroDivisionError:
      #print(&quot;At least one of the vector is Zero Vector! No angle defined.&quot;)
      raise Exception(&quot;One of the vector is Zero Vector! No angle defined.&quot;)

  ## 私有函数（private function）和变量，以两个下划线开头来命名
  def __is_zero_vector(self):
    return self.magnitude() &lt; TOLERANCE

  def is_parallel_to(self, v):
    if v.__is_zero_vector() or self.__is_zero_vector():
      return True
    else:
      s_m = self.normalization()
      v_m = v.normalization()
      return s_m.minus(v_m).__is_zero_vector() or s_m.plus(v_m).__is_zero_vector() 

  def is_orthogonal_to(self, v):
    return abs(self.dot_product_with(v)) &lt; TOLERANCE

  ## 向量的分解 - 计算向量水平方向的分量
  def component_parallel_to(self, base_vactor):
    u_b = base_vactor.normalization()
    mag = self.dot_product_with(u_b)
    return u_b.times_scalar(mag)

  ## 向量的分解 - 计算向量竖直方向的分量
  def component_orthogonal_to(self, base_vactor):
    c_p = self.component_parallel_to(base_vactor)
    return self.minus(c_p)

  ## 计算向量与另一向量的叉乘
  def cross_product_with(self, v):
    if self.dimension != 3 or v.dimension != 3:
      raise Exception(&quot;Both cross product vectors must be three dimensional&quot;)

    if self.is_parallel_to(v):
      return Vector([0 for i in range(self.dimension)])
    else:
      x = self.coordinates[1]*v.coordinates[2] - self.coordinates[2]*v.coordinates[1]
      y = self.coordinates[2]*v.coordinates[0] - self.coordinates[0]*v.coordinates[2]
      z = self.coordinates[0]*v.coordinates[1] - self.coordinates[1]*v.coordinates[0]
      return Vector([x, y, z])

  ## 计算向量与另一向量的所围成的四边形的面积
  def area_of_parallelogram_spanned_with(self, v):
    new_self = self
    new_v = v
    if self.dimension == 2:
      new_self = Vector(self.coordinates + (0,))
    if v.dimension == 2:
      new_v = Vector(v.coordinates + (0,))

    return new_self.cross_product_with(new_v).magnitude()

  ## 计算向量与另一向量的所围成的三角形的面积
  def area_of_triangle_spanned_with(self, v):
    return self.area_of_parallelogram_spanned_with(v) / Decimal(2)
</code></pre>
<hr>
<h3 id="常用模组-Module"><a href="#常用模组-Module" class="headerlink" title="常用模组 - Module"></a>常用模组 - Module</h3><p><a href="https://docs.python.org/3/library/" target="_blank" rel="noopener">Python 的标准库</a>里包含了常用的 Module ，使用 <code>import</code> 语句可导入</p>
<p>以下是一些实用的模组（Module）：</p>
<ul>
<li><p><a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener">sys</a>：内建了很多好用的工具</p>
<pre><code class="lang-python">import sys

## 工具一：sys.stdout.flush() 
## 不断更新输出内容，而不是叠加输出（即每次删除上次的「显示结果」，然后显示当次的「显示结果」）
for i_episode in range(1, num_episodes+1):
        # monitor progress
        if i_episode % 1000 == 0:
            print(&quot;\rEpisode {}/{}.&quot;.format(i_episode, num_episodes), end=&quot;&quot;)
            sys.stdout.flush()
</code></pre>
</li>
<li><p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">re</a> ：通过正则表达式在字符串中进行模式匹配</p>
</li>
<li><p><a href="https://docs.python.org/3/library/math.html" target="_blank" rel="noopener">math</a> ：一些标准数学函数</p>
</li>
<li><p><a href="https://docs.python.org/3.6/library/fractions.html" target="_blank" rel="noopener">fractions</a>：此库最常用的是里面的 <code>Fraction</code>，分数（有理数）计算超方便</p>
<pre><code class="lang-python">from fractions import Fraction
</code></pre>
</li>
<li><p><a href="https://docs.python.org/3/library/random.html" target="_blank" rel="noopener">random</a> ：生成假随机数字，随机打乱序列并选择随机项 </p>
</li>
<li><p><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a> ：适用于读写 json 文件（面向网络开发）</p>
</li>
<li><p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="noopener">datime</a> ：读取当前时间和日期</p>
</li>
<li><p><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">os</a> ：与操作系统交互的操作</p>
<pre><code class="lang-python">import os
os.chdir(path)  # 更改当前的工作目录（working directory）
</code></pre>
</li>
<li><p><a href="https://docs.python.org/3/library/csv.html" target="_blank" rel="noopener">csv</a> ：处理 <code>.csv</code> 类型的文件</p>
</li>
<li><p><a href="https://docs.python.org/3/library/zipfile.html" target="_blank" rel="noopener">zipfile</a> ：处理 <code>.zip</code> 压缩文件</p>
</li>
<li><p><a href="https://docs.python.org/3/library/collections.html" target="_blank" rel="noopener">collections</a> ：常见数据类型的实用扩展，包括 OrderedDict、defaultdict 和 namedtuple</p>
</li>
<li><p><a href="https://docs.python.org/3/library/timeit.html" target="_blank" rel="noopener">timeit</a> ：显示<strong>简短的代码</strong>运行所花费的时间</p>
</li>
<li><p><a href="https://docs.python.org/3/library/profile.html" target="_blank" rel="noopener">cProfile 或 profile</a> ：显示<strong>大型项目</strong>运行所花费的时间</p>
</li>
</ul>
<hr>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>


  </article>



    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot container">
    <div class="firstrow">
        <a href="#top" >
        <i class="fa fa-arrow-right"></i>
        </a>
        
    </div>
    <div class="secondrow">
        <a href="">
        
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <!-- jquery.min.js 导致网页加载时间特别长，更换使用本地的 jquery.min.js  -->
<!-- script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script -->
<script src="/js/jquery.min.js"></script>
<script src="/js/search.js"></script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">

// comments below to disable loading animation
function revealOnScroll() {
  var scrolled = $(window).scrollTop();
  $(".excerpt, .index-title, .index-meta, p").each(function() {
    var current = $(this),
      height = $(window).outerHeight(),
      offsetTop = current.offset().top;
    (scrolled + height + 50 > offsetTop) ? current.addClass("animation"):'';
  });
}
$(window).on("scroll", revealOnScroll);
$(document).ready(revealOnScroll)

// disqus scripts
/**/

// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

// back to top scripts
$("a[href='#top']").click(function() {
  $("html, body").animate({ scrollTop: 0 }, 500);
  return false;
});


var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
