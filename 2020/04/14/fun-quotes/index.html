<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content>
  
  <title>言语之曰</title>
  <meta name="author" content="chpwang">
   <meta name="description" content="王哈哈的修行驿站">
  

  <meta property="og:title" content="言语之曰">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="行侠何须仗名剑">
 <meta property="og:image" content>
  
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="行侠何须仗名剑" type="application/atom+xml">
  <!-- link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" -->
  <!-- link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" -->
  <!-- 把 bootstrap 3.3.6 本地化，免得连不上它的服务器，相关文件放在了 pln/source/bootstrap 里-->
  <link rel="stylesheet" href="/css/bootstrap/css/bootstrap.min.css">
  <!-- 把 font-awesome 4.5.0 本地化，免得连不上它的服务器，相关文件放在了 pln/source/font-awesome 里 -->
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css">
  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/css/highlight/styles/vs2015.css">
  <!-- highlight.js代码高亮主题 css 引入-->
  <link rel="stylesheet" href="/css/m.min.css">
  <!--link rel="icon" type="image/x-icon" href="/favicon.ico"-->
  <link rel="icon" type="image/x-icon" href="/G.png"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="main">
    <div class="behind">
      <div class="back">
        <a href="/" class="black-color"><i class="fa fa-times" aria-hidden="true"></i></a>
      </div>
      <div class="description">
        &nbsp;
      </div>
    </div>
    <div class="container">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        言语之曰
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2020-04-14T13:17:40.000Z">
  <i class="fa fa-calendar"></i>&nbsp;
  2020-04-14
</time>






    
    &nbsp;
    <i class="fa fa-tag"></i>&nbsp;
    <a href="/tags/Miscellaneous/">Miscellaneous</a>


    </div>
    <hr>
    <div class="picture-container">
      
    </div>
    <p><strong>Ian：</strong>你需要在头脑中对程序进行“数据流分析”，才能找到它定义的位置。</p>
<p><strong>Ian：</strong>凡是发现奇怪反直觉的地方，经常都是有设计错误的。</p>
<p><strong>Ian：</strong>如果你真的在乎代码的质量，就会发现大部分时候你的代码的读者是你自己，而不是别人，因为你需要反复的阅读和提炼你的代码。所以很多时候最省人力的做法并不是那种看来最聪明，最酷，打字量最少的办法，而是写得最明确，让读者省事的办法。</p>
<p><strong>Ian：</strong>代码读的时候比写的时候多得多，所以要想语言好用省事，我们应该更加重视读的时候，而不是写的时候。</p>
<p><strong>Gemini 2.5 Pro：</strong>这背后是两种截然不同的语言机制，核心区别在于 void 是一个“类型”，而 undefined 是一个“值”。void 作为一种类型级别的约束，让编译器在编译阶段就能检查错误。</p>
<p><strong>Gemini 2.5 Pro：</strong>编译器把重定义视为一个严重的逻辑错误，因为它无法安全地猜测程序员的意图。与其冒险生成一个可能随时崩溃的程序，不如直接在编译阶段就报错，强迫程序员修复这个根本性的“蓝图冲突”问题。</p>
<p><strong>Gemini 2.5 Pro：</strong>如果语言允许“覆盖式”重定义，你的程序会变得极度脆弱。你包含了一个新的头文件，可能会在不经意间“覆盖”掉一个已有的类定义，导致一个完全不相关的、远在项目另一端的模块出现行为异常。调试会变成噩梦。因为一个类的具体行为取决于头文件的包含顺序，这使得代码的行为变得不可预测。</p>
<p><strong>Gemini 2.5 Pro：</strong>为什么编译器不能“聪明”一点，就用最后看到的那份定义呢？这会引发至少四个层面的灾难性问题……</p>
<p><strong>Ian：</strong>……程序所做的几乎一切事情，都是信息的传递：分流或汇合。</p>
<p><strong>Ian：</strong>……它完全没有防止你什么…两个人同时写啊之类的事情。就是说，这个事情它不管的。它只管这个内存到后来要释放掉，而且只能有一个释放。你不能多次释放。差不多这样……那至于多线程的时候，你要怎么处理这种（读写）冲突事情，那就是你自己的事情了。</p>
<p><strong>Ian：</strong>……这个…这个有可能开头有点烧脑，但是你用惯了之后你就会发现这个实际上…挺清晰的…没有什么…不像 Rust 那个什么，你两个解引用你都不知道它在干什么。</p>
<p><strong>Ian：</strong>我觉得它这个设计是碰出来的。都没想清楚是怎么回事。</p>
<p><strong>Ian：</strong>……你不觉得这样很危险吗？就是…程序员写成什么样就应该是什么样…它自动给你加一些解引用。就是隐式的东西太多了，就容易…就不明白了。到后来你们就会…乱碰，说：“啊~这个地方…为什么加一个这个就能过了？啊？它为什么这个地方不加这个就不能过？然后呢这个把这个取掉，然后又可以编译过了…”到后来就碰来碰去碰对了，就不理解。</p>
<p><strong>Ian：</strong>我打算给你们加一节课，把 C++ 的这个做法讲一下。这样我们就有一个对比了。然后，有对比就有伤害了……所以在这个方面我觉得 C++ 还是做得更好一点的。</p>
<p><strong>Ian：</strong>我感觉它那个……看上去它好像有很多新的概念，其实它没有什么新的概念。它这些东西都是在其他语言里面有的，只不过其他语言没有设计成这个样子。</p>
<p><strong>Ian：</strong>……这样太难懂了，它就说，我要自动给你加一些解引用上去，让你的代码看起来简单一点。但是，那只是看起来简单一点，不等于…你就能理解你的代码了。这种自动解引用就会让你…造成你的困惑。</p>
<p><strong>Ian：</strong>就是它……隐含的自动干的事情太多了，我觉得这个 Rust 语言。自动做了太多的事情那个程序员他就不知道这是什么回事了对吧。所以我觉得这些东西还是应该是显式的，不应该…自动解引用。</p>
<p><strong>Ian：</strong>C++ 完美地解决了我对 Rust 的不满……但 C++ 有个讨厌的问题就是，出错信息太难看了。</p>
<p><strong>Ian：</strong>这个课听完之后你们应该会发现 <strong>Rust</strong> 的<a href="https://doc.rust-lang.org/book/title-page.html" target="_blank" rel="noopener">文档</a>其实写得很不容易理解。</p>
<p><strong>Ian：</strong>……如果代码都得这样写的话，你的那些函数…要把你写得很头痛。所以，这显然不是一个解决方案。只是告诉你这…这个移动这个…这个语义是怎么进行的。</p>
<p><strong>Ian：</strong>你要付出表达能力的代价，来满足…来达到它可以好像自动把类型都给你推导出来的这种幻觉。结果你的代码为了能够表达你想要写的那个思路，你就要绕一个弯子才能写出来。所以我不觉得它的这个类型推导是个什么好东西……但是总有一些人他很迷信这个类型推导。因为他也不知道类型推导是怎么回事，他也没有实现过这些东西。他就觉得好神奇啊，我可以不写类型，多好啊。但是代价蛮大的。</p>
<p><strong>Ian：</strong>……就是很多本来你可以…Java 里面你可以写的代码，你到 Haskell 里面就不能写了。就是因为你那样写了它就推导不出类型。那并不是…因为你的思路有问题或者是你不应该写那样的代码，而是因为它的这个类型推导是有局限性的。它为了能够反着推出这个类型，它就规定了这样的代码、这样的代码你不能写，这种子类型关系你不能有。呵呵~</p>
<p><strong>Ian：</strong>……但你们不要以为这个…它这种类型推导是什么好东西。就你这里不写类型，然后它给你推导出来。这样的代价其实蛮大的。</p>
<p><strong>Ian：</strong>你就要找到你的 bug 在哪里。你把它修好，你这个异常就不会发生了。不会发生了你又 try-catch 它干嘛？然后你 catch 到它你又能干嘛？对吧。你啥都做不了，因为那是你的 bug 。呵呵……下标越界这个异常，你 catch 它是没有意义的。</p>
<p><strong>Ian：</strong>……然后呢，我不是去把这一行（代码）改对，（而是）我在这里去 catch 这个异常，然后处理这个异常，你觉得这样合理吗对吧？正确地处理下标越界的办法，就是你写出的代码就不应该下标越界。</p>
<p><strong>Ian：</strong>反正它们这些语言都是……有些时候它会学到一些经验教训，但是呢它又加进自己的一些误解。嗯…对，比如说 C# 。你看到它把这个（Type Erasure）改进了，学到了历史的教训，你就以为它都做对了，其实它…Java 已经做对的东西它却没有做对，对吧。就是…C# 它没有那个 checked exception 。</p>
<p><strong>Ian：</strong>总的说来，就是说这个 Java 的 <strong>JVM</strong> 里面它其实没有这个泛型（Generics）。只是说你这个编译器能看到这个东西。但是它运行的时候它其实是没有的。因为最初 <strong>JVM</strong> 就没有这个东西，后来可能又加不进去了。加不进去它就只有把它叫做 <strong>Type Erasure</strong> 。就是说「编译之后它（类型）就不见了」。然后你还以为它是什么很先进的功能。</p>
<p><strong>Ian：</strong>如果你去查这个 <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html" target="_blank" rel="noopener">Type Erasure</a> 的话，你还以为它是一个 feature 。但是我觉得它就是一个历史遗留局限。然后呢，被当成 feature ，哦不，呵呵，被<strong>宣传为</strong> feature 。（你）还以为 erasure 是 Java 专门实现的一种功能，它其实就是一个没有完整实现的 Generics 的系统。所以这个代码编译以后，这个 <code>T</code> 的这个东西在 <strong>JVM</strong> 里面是不存在的。</p>
<p><strong>Ian：</strong>……就是为什么加了这个泛型之后，它才报这个错，对吧。你没泛型的时候，它为啥就没这个错？所以这个就是一个……我感觉就是这个 Java 它这个…它的类型系统的实现…其实它并不是一个很完善的实现。因为它最初没有这些东西，后来又加进去。加进去它的 JVM 又没法改了。为了兼容它以前的代码，所以 Java 有所谓的 <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html" target="_blank" rel="noopener">Type Erasure</a> 就是这个原因。</p>
<p><strong>Ian：</strong>像 Haskell 之类的有类型的函数式语言它其实就是这个 interface （Java interface），只不过它把它叫另外一个名字（type class）。所以你不要觉得这个东西是面向对象语言才有的。它是一种……其实是一种通用的、制造抽象的思想。</p>
<p><strong>Ian：</strong>有些东西吸取了教训，但又加进了自己的一些误解。</p>
<p><strong>Ian：</strong>你看它（<a href="https://github.com/features/copilot" target="_blank" rel="noopener">Copilot</a>）好像能猜出我想写什么，我都没打 <code>fib</code> 呢，它就知道我下一步要写 <code>fib</code> 了。就这个东西比较危险啊。你打的代码它全都看去了，它还知道你下一步要打什么。</p>
<p><strong>Ian：</strong>语言的特性有些是通过解释器实现的，有些是通过编译器实现的。</p>
<p><strong>Ian：</strong>所以这个灵活的定义有好处也有坏处。坏处就是，不知道这个东西怎么用的人，他就喜欢滥用这个，对吧。</p>
<p><strong>Ian：</strong>有些东西它虽然提供给你了，但是你最好不要用，对吧。</p>
<p><strong>Ian：</strong>你把它写成这种 <code>for</code> 循环，你就每次你都要利用你对这个 <code>for</code> 循环的“深刻理解”，你才能知道，啊~这个是先执行了，然后这个判断才执行。然后实际上你还不如你就写成 <code>while</code> 这种样子。</p>
<p><strong>Ian：</strong>好了，这样我们的解释器应该就写完了。虽然功能特别少，但是这是一个很有原则的解释器。</p>
<p><strong>Ian：</strong>为什么这个函数是递归的？因为它处理的数据是递归的。为什么这个函数里面有 3 个分支？因为它处理的数据就是有 3 种情况。就是这么简单。</p>
<p><strong>Ian：</strong>这些练习不一定要做完的，因为考虑到让有时间的同学多练习，所以数量很多。要是你为了做完而没有学到经验，就比较不划算了。</p>
<p><strong>Ian：</strong>很多设计错误都是因为设计者为了“用户方便”而产生的。结果带来的麻烦比方便多很多。</p>
<p><strong>Ian：</strong>现在就像你们刚学开车，我先拿了一辆有点毛病的便宜车给你们先掌握基本的油门和方向盘的使用。之后换一辆毛病少点的车照样可以开。没必要去记住这车的毛病。</p>
<p><strong>Ian：</strong>要记得，函数是一个动作，它含有它自己所需的一切信息。很多函数的参数是一个函数，它表示“具体要做什么”。它不是一个字符串，而是一个动作自己。</p>
<p><strong>Ian：</strong>一旦你做过了这些题，你对函数的理解就非常深入了。因为你完全用函数来表达了自然数（及其计算）。</p>
<p><strong>Ian：</strong>……先写 Call 吧，（解释器）三大要素……</p>
<p><strong>Ian：</strong>这里有一个信息流动的方向的问题。</p>
<p><strong>Ian：</strong>这样写破坏了 pair 的抽象层。你可以试试用 first, second 而不要直接把 pair 作为函数调用。</p>
<p><strong>Ian：</strong>嗯……好像你（@拉拉拉）不用这样表达吧？你看我都已经说清楚了是什么意思然后你又非得要说一句话，然后让大家来判断你说的话对不对，好像就没有什么意义了，对吧。你现在应该已经看明白了这是什么意思嘛。嗯…好~的~</p>
<p><strong>Ian：</strong>嗯…好了…那个……就是说……大家…嗯…你们看明白了是怎么回事就行了。然后，就是说如果你们要用自己的语言表达出来的话，却不一定是对的。所以，尽量试图不要去用语言表达这个事情，理解了就好。</p>
<p><strong>Ian：</strong>嗯…到了这个阶段我觉得应该……放开一点，不要总是想独立想出来。你比如说你…你拿了别人的想法之后其实你…也没有损失什么，你也不一定要照他的做，然后也许你能发现一些……做得…做得不一样的地方然后就…就够了。然后……重头想的话，真想不出来其实…效果并不好。</p>
<p><strong>Ian：</strong>所以…可能将来的那些……练习啊或者是…下了课之后你们要做什么，你们…就不用有那个限制了。然后也可以…搜索引擎里面搜一下……看看网上有没有其他的内容。嗯…但是要小心就是有…有那种…就是“啊”…说“啊~我来给你讲一下这个 call/cc …”什么的，然后就…噼里啪啦打了一堆代码出来然后…结果那代码又不好。然后你就…被误导了。</p>
<p><strong>Ian：</strong>你可以想象这个 task …… task1 你在跑，对吧？然后到了某个时候你突然说停……停了之后你要回到哪去呢？是不是应该回到启动你的那个地方去？</p>
<p><strong>Ian：</strong>到现在你应该已经理解，是什么语言并不是由语法决定的。我可以有一个 Scheme 语法的 C 语言，但它仍然是 C 语言。</p>
<p><strong>Ian：</strong>我又开始看 <a href="https://mitpress.mit.edu/books/little-typer" target="_blank" rel="noopener"><em>The Little Typer</em></a>。发现有时候你必须已经理解它在说什么，你才能理解它在说什么。^_^</p>
<p><strong>Ian：</strong><a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a> 是一个好的操作系统，它只是缺少一个好的编辑器。</p>
<p><strong>Ian：</strong>…正好相反，真正可以发挥创造力的空间并不在底层的编译器一类的东西，而在更接近应用和现实的地方。</p>
<p><strong>Ian：</strong>如果你理解了句子是一个函数调用，那么你就会懂得何时该使用句号。很多中国人对句子没有清晰的概念和边界。本该是句号的地方他们却打逗号，所以你不知道他的句子到哪里结束。</p>
<hr>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>


  </article>



    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot container">
    <div class="firstrow">
        <a href="#top" >
        <i class="fa fa-arrow-right"></i>
        </a>
        
    </div>
    <div class="secondrow">
        <a href="">
        
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <!-- jquery.min.js 导致网页加载时间特别长，更换使用本地的 jquery.min.js  -->
<!-- script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script -->
<script src="/js/jquery.min.js"></script>
<script src="/js/search.js"></script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">

// comments below to disable loading animation
function revealOnScroll() {
  var scrolled = $(window).scrollTop();
  $(".excerpt, .index-title, .index-meta, p").each(function() {
    var current = $(this),
      height = $(window).outerHeight(),
      offsetTop = current.offset().top;
    (scrolled + height + 50 > offsetTop) ? current.addClass("animation"):'';
  });
}
$(window).on("scroll", revealOnScroll);
$(document).ready(revealOnScroll)

// disqus scripts
/**/

// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

// back to top scripts
$("a[href='#top']").click(function() {
  $("html, body").animate({ scrollTop: 0 }, 500);
  return false;
});


var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

</body>
</html>
