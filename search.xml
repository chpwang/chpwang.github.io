<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 语言入门</title>
      <link href="/2024/04/27/cpp-basics/"/>
      <url>/2024/04/27/cpp-basics/</url>
      
        <content type="html"><![CDATA[<p>在理解 Rust 内存管理的本质之后（参见<a href="/2024/04/22/rust-basics/"> Rust 入门</a> ），再来了解一下 <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++ 语言</a>和它的内存管理。这样和 Rust 对比一下，就能更加理解 Rust 内存管理方式和特点。进而更好地使用 C++ 进行编程。</p><p>如果从具有<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">垃圾回收（Garbage Collection）</a>的语言出发来类比和理解，可能到后来你就始终弄不明白 C++ 这样的语言到底要怎么写代码。</p><p>当年 Ian 刚开始学计算机是从 <a href="https://en.wikipedia.org/wiki/Pascal_(programming_language)" target="_blank" rel="noopener">Pascal</a> 语言开始的。之后马上又学了 <a href="https://en.wikipedia.org/wiki/C_(programming_language)" target="_blank" rel="noopener">C 语言</a> 。因为传言 C 语言比 Pascal 好。而 C 语言的内存管理都是手动的。所以经常会出现一些很奇怪的问题。但是通过学习 Rust 或者 C++ ，你就能从本质上理解用 C 语言怎么会遇到那么稀奇古怪的一些问题：要么你内存泄漏了，要么你就是出现一些内存错误。比如说有一个地方的值莫名其妙地被人改了，你就不知道哪里的代码在改那个内存。因为内存管理弄错了之后，你的指针就有可能指向它不该指的地方。</p><p>Rust 语言会强制你去思考这些内存问题，所以你就被迫就要把这些事情按照它的规则做对。然后 Rust 的内存管理思路大致上是对的。就是它强制你有个 <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">ownership</a> 。这样通常情况下只有一个变量可以指向这个对象。然后如果你需要共享的话，你就得自己显式地使用那个 <a href="https://doc.rust-lang.org/book/ch15-04-rc.html" target="_blank" rel="noopener">Rc</a>（引用计数）的方式。习惯了 Rust 之后再去写 C 语言或者 C++ ，就不会那么容易有问题了——当然，你还是可能会犯错的。</p><p>C++ 的 <a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170" target="_blank" rel="noopener">Smart Pointer</a> 设计，其使用的方式稍微改一点，就能实现和 Rust 同样的目标，而不太增加思维负担。不过 C++ 有一个<strong>讨厌</strong>的地方是，它的出错信息太难以阅读了。写错代码之后的报错信息令人困惑，不知哪里错了。因为它的 <a href="https://learn.microsoft.com/en-us/cpp/cpp/smart-pointers-modern-cpp?view=msvc-170" target="_blank" rel="noopener">Smart Pointer</a> 这些东西是靠 <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)" target="_blank" rel="noopener">Template</a> 和<a href="https://learn.microsoft.com/en-us/cpp/preprocessor/macros-c-cpp?view=msvc-170" target="_blank" rel="noopener">宏</a>展开之后实现出来的，它并不是 C++ 语言直接实现了这些东西。所以你一旦出点错，它是展开了一堆内部实现的代码，最后给你说展开之后的代码哪里错了。但展开之后的代码跟你写的代码完全是两码事了。这就是 C++ 的一个问题。</p><p>在熟悉 C++ 之后，可以进一步思考一下 C++ 和 Rust 关于内存做法的各自优缺点。</p><hr><h3 id="C-编程环境设置"><a href="#C-编程环境设置" class="headerlink" title="C++ 编程环境设置"></a>C++ 编程环境设置</h3><p>首推自然是使用友好功能强大的 <a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">CLion</a> 作为 <strong>C++</strong> 的 <strong>IDE</strong>。不过这是收费的软件，30 天免费试用期过后就需要付费订阅。适合需要长期使用 C++ 的玩家们。</p><p>作为入门学习体验，也可以退而求其次继续选择免费的 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a> 。此时要先安装 <a href="https://gcc.gnu.org" target="_blank" rel="noopener">GNU C++</a> 或者 <a href="https://clang.llvm.org" target="_blank" rel="noopener">Clang C++</a> 的编译器。对于 MacOS 的用户，推荐用 Clang ，因为它包含在 Xcode 命令行工具里，安装非常方便。</p><pre><code class="lang-bash">## 安装 Command Line Tools - MacOS 编程软件 Xcode 的命令行工具$ xcode-select --install## 完成后可以使用一下命令查看版本说明安装成功了$ clang --versionApple clang version 14.0.0 (clang-1400.0.29.202)Target: arm64-apple-darwin21.6.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin</code></pre><p>安装完 Clang 之后，在 VS Code 中新建后缀为 <code>.cpp</code> 的文件比如 <code>demo.cpp</code> 就能开始编程了：</p><pre><code class="lang-c++">#include &lt;iostream&gt;// C++ 的 main 函数一定要返回 intint main(){  std::cout &lt;&lt; &quot;Hello C++&quot; ;  return 0;}</code></pre><p>关于 <strong>VS Code</strong> 的安装、设置和使用可以参考<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 。</p><p>一些方便的设置：</p><ul><li><p><strong>设置花括号另起一行</strong>：<code>Settings</code> -&gt; 搜索 <code>C_Cpp.clang_format_fallbackStyle</code><br>在输入框处填上 <code>&quot;Visual Studio&quot;</code> ，也就是使用 <strong>VS</strong> 的格式<br>这样在编辑完代码后，就可以使用快捷键 <code>option</code> + <code>shift</code> + <code>F</code> 来格式化代码，让花括号另起一行<br>最开始 <strong>C</strong> 语言的时候大家花括号都是写在下一行的，自从有了 <strong>Java</strong> ，大家才开始写埃及括号 Egyptian brackets ，然后代码就挨得太近了<br>要注意的是，该格式化也会把 <code>int* p = ...</code> 改成 <code>int *p = ...</code> ，但 <code>int*</code> 其实是一个「类型」，代表<strong>整数指针</strong>。写成 <code>int *p</code> 会和解引用计算 <code>*p</code> 混淆。正确写法还是要 <code>int* p</code> 表示变量 <strong>p</strong> 是整数指针类型；<br>你如果想抬杠把它理解成先计算 <code>*p</code> ，然后再把计算结果标记为 <code>int</code> 类型，那逻辑就绕了。而且类型标记是标记变量和函数的，不是标记表达式的值的；</p></li><li><p><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a> 默认用的是 <code>g++</code> 来编译，最好能加上一个参数 <code>-std=c++17</code> ，这样就能使用 <a href="https://en.wikipedia.org/wiki/C%2B%2B17" target="_blank" rel="noopener">C++17</a> 标准来编译。这意味着你的代码可以用一些新的写法和功能，比如使用 <code>std::make_unique</code> 函数等。<br>参考<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 打开配置文件 <em>settings.jason</em> ：<br><code>Extensions Settings</code> -&gt; <code>Code-runner:</code> <strong><code>Executor Map</code></strong> -&gt; <code>Edit in settings.jason</code><br>在 <strong>cpp</strong> 那行的 <code>g++</code> 后面编辑添加 <code>std=c++17</code> 保存即可。编辑完成后这行的文本如下：</p><pre><code class="lang-jason">&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -std=c++17 $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,</code></pre></li></ul><hr><h3 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h3><p>C++ 和 Java 非常相似，对熟悉 Java 的玩家来说，开始的这些代码和概念可以快速通过：</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;stdexcept&gt;#include &lt;cmath&gt; // &lt;cmath&gt; 库包含开平方的函数 sqrt// 如果没有 using namespace std; 那 cout 和 endl 等就都要加上 std::// 这里我们只有一个 cout ，所以可以不用担心可能导致的命名冲突using namespace std;// C++ 不允许你在函数内部定义函数，编译不通过，所以 fact 定义到外面// 尽管有编译过程，但是函数要定义在调用的前面才能被识别，否则就会报错 undeclared// fact 定义在 basic_test 之前，basic_test 内部才能调用它int fact(int n){  if (n == 0)  {    return 1;  }  else  {    return n * fact(n - 1);  }}// int sqrt(int n) {//   return n * n;// }// ###########################################################//                            基本语法// ###########################################################void basic_test(){  // 如果没有上面的 using namespace std; 那输出的 cout 和换行 endl 等等就都要加上 std:: 这个前缀  // std::cout &lt;&lt; &quot;---------------- basic_test ----------------&quot; &lt;&lt; std::endl;  cout &lt;&lt; &quot;---------------- basic_test ----------------&quot; &lt;&lt; endl;  cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;  int x = 2 * 3;  cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;  int y = 1 + x;  cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; endl;  const int z = 5; // const 代表常数，不能改动  cout &lt;&lt; &quot;z = &quot; &lt;&lt; z &lt;&lt; endl;  // z = 10; // Error: assignment of read-only variable &#39;z&#39;  float a = 3.14;  cout &lt;&lt; &quot;a(float) = &quot; &lt;&lt; a &lt;&lt; endl;  double b = 3.14;  cout &lt;&lt; &quot;b(double) = &quot; &lt;&lt; b &lt;&lt; endl;  char c = &#39;A&#39;;  cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;  bool d = true;  cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;  string e = &quot;Hello&quot;; // string 类型是小写开头的 Java 是大写 String  cout &lt;&lt; &quot;e = &quot; &lt;&lt; e &lt;&lt; endl;  cout &lt;&lt; e + &quot; World!&quot; &lt;&lt; endl;  e.append(&quot; World!&quot;);  cout &lt;&lt; &quot;e = &quot; &lt;&lt; e &lt;&lt; endl;  cout &lt;&lt; sqrt(25) &lt;&lt; endl; // sqrt function is defined in the cmath header file.  cout &lt;&lt; fact(5) &lt;&lt; endl;  string arr[] = {&quot;Hello&quot;, &quot;World&quot;, &quot;Good&quot;, &quot;Morning&quot;, &quot;Everyone&quot;};  // C++ 的数组没有 length 函数  // sizeof(arr) 得到整个数组占用多少内存，用字节计算，sizeof(string) 则得到 string 对象的大小  // 两者除一下，计算出数组的长度 length  cout &lt;&lt; &quot;arr length = &quot; &lt;&lt; sizeof(arr) / sizeof(string) &lt;&lt; endl;  for (int i = 0; i &lt; 5; i++)  {    cout &lt;&lt; &quot;for: &quot; + arr[i] &lt;&lt; endl;  }  arr[3] = &quot;Evening&quot;;  for (string s : arr)  {    cout &lt;&lt; &quot;for-each: &quot; + s &lt;&lt; endl;  }  int arr2[] = {1, 2, 3, 4, 5};  cout &lt;&lt; &quot;arr2 length = &quot; &lt;&lt; sizeof(arr2) / sizeof(int) &lt;&lt; endl;  int total = 0;  for (int i = 0; i &lt; 5; i++)  {    total += arr2[i];  }  cout &lt;&lt; &quot;Total = &quot; &lt;&lt; total &lt;&lt; endl;  struct User // struct 可以在函数体里定义  {    string name;    int age;    // 如果 struct 定义函数的话，这个函数是单独存放的    // 不算 struct 里的 field    // 比如你这里定义了一个 printUser() 函数，然后 unique_ptr&lt;User&gt; u1    // 然后 move 它：unique_ptr&lt;User&gt; u2 move(u1)    // 按理说此时 u1 被清零了（地址为 0），但 u1.printUser() 仍然能调用    // 除了 struct 外 class 的行为也是如此    // 思考：struct 和 class 有什么区别？哪些情况下时候分别用哪个？    // class 中，默认的成员访问级别是 private，而在 struct 中，默认的成员访问级别是 public；    // class 常用于定义复杂行为和数据封装的对象，如包含多种类方法；而 struct 则用于轻量级的数据结构，如坐标；  }; // C++ 这里要加一个分号  // User u1 = {&quot;John&quot;, 25};  // User u1 = {name : &quot;John&quot;, age : 25}; // 加上 key 后更明确（这样写和其他语言像一点）  User u1 = {.name = &quot;John&quot;, .age = 25};  // C++ 编译器推荐用这种 .name 的写法  cout &lt;&lt; &quot;u1.name = &quot; &lt;&lt; u1.name &lt;&lt; endl;  cout &lt;&lt; &quot;u1.age = &quot; &lt;&lt; u1.age &lt;&lt; endl;  // 匿名的 struct ，直接作为变量的类型  struct  {    string name;    int age;  } u2 = {&quot;John-2&quot;, 25};  cout &lt;&lt; &quot;u2.name = &quot; &lt;&lt; u2.name &lt;&lt; endl;  cout &lt;&lt; &quot;u2.age = &quot; &lt;&lt; u2.age &lt;&lt; endl;}// ###########################################################//                           指针和地址// ###########################################################void pointer_test(){  cout &lt;&lt; &quot;---------------- pointer_test ----------------&quot; &lt;&lt; endl;  // 直接定义的整数 10 被 C++ 放在栈上 - 和 Java 不同的是，C++ 的「堆」和「栈」分得很清楚的  // x 的数据 2 在 stack 上  int x = 2;  cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; // 直接可以打印出 x 的值 2   cout &lt;&lt; &quot;&amp;x = &quot; &lt;&lt; &amp;x &lt;&lt; endl; // 打印 x 的地址：符号 &amp; 代表取得该变量的地址  // 这个定义，数据 int(10) 在 heap 上，指针变量 p 则在 stack 上  // int* 的这个 * 号是 int* 这个类型的一部分，下面的 *p 的 * 号则是解引用操作符，两者不一样  // Rust 的 * 只是用来 move 改变 ownership 的，虽然也叫 dereference 但和这的 *p 本质不一样  // C++ 里，看到关键词 new 就要知道它肯定在 heap（堆）上了，因为 new 就是在 heap 上分配内存的操作  int* p = new int(10);  // 直接打印 p 会打印出 p 中数据的内存地址，即 10 存放在作为 heap 的内存的地址（0x开头的16进制数）  cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;  // int* 是一个「类型」，而 *p 表示「解引用 p」，* 在这两者中的意思是不同的  // 同理，int** 也是一个「类型」，所以虽然 int **q 和 int ** q 也能编译通过，  // 但建议写 int** q ，这样就能反应出 int** 是一个类型标记，这也是它的本质  // 使用 VS Code 格式化代码会使得 int** q 被改写为 int **q ，而这样写会和 **q 混淆  // &amp;p 是取得 p 的地址，和 Rust 中作为借用（borrow）的 &amp; 不同  int** q = &amp;p;                // q 本身在 stack 上，指向 stack 上的 p 的地址 &amp;p  cout &lt;&lt; &quot;q = &quot; &lt;&lt; q &lt;&lt; endl; // 可发现 &amp;p 和 &amp;x 值很接近，因为 p 和 x 在 stack（栈） 上是相邻的  cout &lt;&lt; &quot;*q = &quot; &lt;&lt; *q &lt;&lt; endl;  cout &lt;&lt; &quot;**q = &quot; &lt;&lt; **q &lt;&lt; endl;  int*** r = &amp;q;  cout &lt;&lt; &quot;r = &quot; &lt;&lt; r &lt;&lt; endl;  cout &lt;&lt; &quot;*r = &quot; &lt;&lt; *r &lt;&lt; endl;  cout &lt;&lt; &quot;**r = &quot; &lt;&lt; **r &lt;&lt; endl;  cout &lt;&lt; &quot;***r = &quot; &lt;&lt; ***r &lt;&lt; endl;  int**** s = &amp;r;  cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; endl;  // int arr[5] = {3, 5, 7, 9, 11};  // 这里 p2 的类型为什么是 int* 而不是 int[]* ？为什么是 int 的指针类型而不是数组的指针类型？  // 因为数组里所有元素是挨在一起相邻储存的，故知道了第一个元素的地址，就知道整个数组的所有元素的地址  // p2 会指向向数组的第一个数据：3 ，即 *p2 = 3  int* p2 = new int[5] {3, 5, 7, 9, 11};  // 注意，C++11 之前的标准不支持直接使用列表初始化数组  cout &lt;&lt; &quot;p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;  cout &lt;&lt; &quot;*p2 = &quot; &lt;&lt; *p2 &lt;&lt; endl;  cout &lt;&lt; &quot;p2 + 1 = &quot; &lt;&lt; p2 + 1 &lt;&lt; endl;       // 数组第二元素 5 的地址  cout &lt;&lt; &quot;*(p2 + 1) = &quot; &lt;&lt; *(p2 + 1) &lt;&lt; endl; // 数组第二元素的值，即 5  int** q2 = &amp;p2;  cout &lt;&lt; &quot;q2 = &quot; &lt;&lt; q2 &lt;&lt; endl;}void address_test(){  cout &lt;&lt; &quot;---------------- address_test ----------------&quot; &lt;&lt; endl;  int i = 10;  string s = &quot;Hello&quot;;  int* pi = new int(10);  // i 和 s 的地址是挨在一块的，都在 栈（stack） 上  // pi 则在堆（heap）上，打印出的地址上可以看到距离 i 和 s 较远  cout &lt;&lt; &quot;address of i = &quot; &lt;&lt; &amp;i &lt;&lt; endl;  // stack  cout &lt;&lt; &quot;address of s = &quot; &lt;&lt; &amp;s &lt;&lt; endl;  // stack  cout &lt;&lt; &quot;pi = &quot; &lt;&lt; pi &lt;&lt; endl;            // heap}// ###########################################################//                            传递引用// ###########################################################void pass_by_reference(int&amp; x)  // x 会成为传入参数的别名{  cout &lt;&lt; &quot;pass_by_reference: x = &quot; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &quot;address of x: &quot; &lt;&lt; &amp;x &lt;&lt; endl;  x += 1;   // 修改 x 就是修改传入的变量}void pass_by_reference_const(const int&amp; x){  cout &lt;&lt; &quot;pass_by_reference_const: x = &quot; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &quot;pass_by_reference_const: address of x: &quot; &lt;&lt; &amp;x &lt;&lt; endl;}void reference_test(){  cout &lt;&lt; &quot;---------------- reference_test ----------------&quot; &lt;&lt; endl;  int x = 10;  int&amp; y = x;  // 同上文的理，int&amp; 是一个类型，&amp; 是 int&amp; 类型的一部分  cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; endl;  x = 20; // 给 x 赋值 20 ，y 也会改变  cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; endl;  y = 30; // 给 y 赋值 20 ，x 也会改变  cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;  cout &lt;&lt; &quot;y = &quot; &lt;&lt; y &lt;&lt; endl;  // &amp;x and &amp;y are the same - x 和 y 的地址相同  // meaning: x and y is the same variable - //可看出 x 和 y 就是同一个东西  // y 和 x 的地址一样，说明 stack 上没有分配一个空间位置给 y ，y 只是 x 的一个别名  // 之后会看到 y 这种东西有什么用 - .borrow_mut()  cout &lt;&lt; &quot;&amp;x = &quot; &lt;&lt; &amp;x &lt;&lt; endl;  cout &lt;&lt; &quot;&amp;y = &quot; &lt;&lt; &amp;y &lt;&lt; endl;  // // Can&#39;t take non-const reference of temporary  // // 如果这个能通过，那 z 就是 x + 1 的别名，那 z = 100 这样的赋值就能写  // // 但 z = 100 相当于对 x + 1 赋值，语义上就很奇怪的，所以不能这么写  // int&amp; z = x + 1;  // 但是你可以有下面这样一个引用，因为是 const 所以你后续不能对 z 赋值了：  const int&amp; z = x + 1;  cout &lt;&lt; &quot;z = &quot; &lt;&lt; z &lt;&lt; endl;  int a = 12;  cout &lt;&lt; &quot;&amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl;  cout &lt;&lt; &quot;before a = &quot; &lt;&lt; a &lt;&lt; endl;  pass_by_reference(a);  cout &lt;&lt; &quot;after a = &quot; &lt;&lt; a &lt;&lt; endl;  // Doesn&#39;t work because pass_by_reference takes a non-const int&amp;  // 原理和上面的 const int&amp; z = x + 1; 一样  // pass_by_reference(x + 1);  pass_by_reference_const(x + 1);  // 参数类型是 const int&amp; ，代表无法更改，所以可允许  // pass_by_reference 和 pass_by_reference_const 这种用法是 C 语言和 C++ 特有的}// ###########################################################//                            数组// ###########################################################// C++ 的这个类型语法是比较诡异的，数组的类型要写成 int arr[] ，应该是历史遗留问题// Java 中的数组就比较有规律 int[] arr ，类型是 int[] ，变量名是 arr// 且这里数组传递的是 reference ，但又不像 pass_by_reference 那样写成 int&amp; arr[]void pass_array(int arr[])  {  for (int i = 0; i &lt; 5; i++)   {    cout &lt;&lt; &quot;pass_array: &quot; &lt;&lt; arr[i] &lt;&lt; endl;  }  arr[0] = 100;}void pass_array_test(){  cout &lt;&lt; &quot;---------------- pass_array_test ----------------&quot; &lt;&lt; endl;  // 在栈（stack）上定义一个 array  int arr[] = {1, 2, 3, 4, 5}; // stack 上  for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++)   {    cout &lt;&lt; &quot;before pass_array: &quot; &lt;&lt; arr[i] &lt;&lt; endl;  }  pass_array(arr);  // a[0] 的值在函数 pass_array 中被改变了，说明数组传递进去的时候不是复制一份  // 而是 arr[] 本身直接进去（很上面的 pass_by_reference 行为相同）  for (int i = 0; i &lt; sizeof(arr)/sizeof(int); i++)   {    cout &lt;&lt; &quot;after pass_array: &quot; &lt;&lt; arr[i] &lt;&lt; endl;  }}// ###########################################################//                            面向对象// ###########################################################class Animal{  // 外部能用的成员和方法都写到 public: 后面  // 不像 Java 那样每个都要写一次 public  public:  // virtual 类似 Java 的 abstract class  // 强制继承的子类定义 speak 方法  // C++ 中得写成这中奇怪的样子  // 如果不加 virtual ，那子类就无法 override 这个 speak 方法了  // 如果不写 = 0 ，就无法强制子类定义 speak 函数  virtual void speak() = 0;  };// 要在 Dog 里能访问到 Animal 里的成员，就要写上 publicclass Dog: public Animal{  public:  // 重载 speak 方法，更严谨的做法是加上 override   // 类似 Java 的 @Override 标记  void speak() override  {    cout &lt;&lt; &quot;汪！&quot; &lt;&lt; endl;  }};class Cat: public Animal{  public:  // override 不写也行，但写的话编译器会检查父类的内容  // 如果父类没有 speak ，那就会编译不通过（要重载但父类却没有）  void speak()  {    cout &lt;&lt; &quot;喵！&quot; &lt;&lt; endl;  }};void inheritance_test(){  cout &lt;&lt; &quot;---------------- inheritance_test ----------------&quot; &lt;&lt; endl;  // 栈（stack）上面定义了狗 d 和猫 c  // Dog 和 Cat 的实例（instance）在 stack 上  Dog d; // stack  Cat c; // stack  int i = 9;  // stack  // 定义在 heap 上的 Dog  Dog* d2 = new Dog();  // heap allocation  // 不能这么写，因为 new Dog() 在堆上，一定要个指针来指向它，而不能用普通的变量来存放它  // Dog d2 = new Dog(); // 编译不通过  // 打印变量们的地址，可以看到 c ，d 和 i 离得很近，都在 stack 上  // 而 d2 则是在 heap 上  // 注意，这里容易有歧义  // 这里说的在 stack 上或者在 heap 上指的是数据内容，即 Dog 和 Cat 的实例（instance）  // d , c , i , d2 这些变量本身都是在 stack 上的  // 然后以 d 为例，d 的内容是一个 Dog 实例，也就是数据本身，所以此时数据本身在 stack  // 但是 d2 的内容不是一个 Dog 实例，它的内容是 heap 上的地址  cout &lt;&lt; &quot;dog address: &quot; &lt;&lt; &amp;d &lt;&lt; endl;  cout &lt;&lt; &quot;cat address: &quot; &lt;&lt; &amp;c &lt;&lt; endl;  cout &lt;&lt; &quot;i address: &quot; &lt;&lt; &amp;i &lt;&lt; endl;  cout &lt;&lt; &quot;d2 address: &quot; &lt;&lt; d2 &lt;&lt; endl; // heap 上的地址  d.speak();  c.speak();  (*d2).speak(); // d2 是一个指针，先解引用得到指向的 Dog 实例，再调用 speak 方法  d2-&gt;speak();  // C++ 语法里还可以用箭头来访问指针指向的对象里的成员（方法）  // 综上，同一个 Class 可以有 2 种不同的分配方法：栈（stack）上，或者堆（heap）上  // 用一个 Animal 指针 a1 指向 d  Animal* a1 = &amp;d;  // Animal a1 = d; // 编译不通过 - 为什么不能这么写？  cout &lt;&lt; &quot;Animal pointer to dog: &quot; &lt;&lt; endl;  cout &lt;&lt; &quot;animal address: &quot; &lt;&lt; a1 &lt;&lt; endl;  a1-&gt;speak();  // 和 Java 不一样的是，如果上面不是用指针，而是 Animal a = d; 就编译不通过  // 在 C++ 里「用一个父类的变量指向一个子类」叫做多态，你必须要用指针，不能直接用这个变量  // 也就是类型必须是 Animal* 。其实 Java 中父类指向子类也是类似。  // 在 Java 里你写 Animal a 的时候，a 其实是一个指针  // Java 里你可以写 Dog d = new Dog(); 然后这个 new Dog() 实际上是在堆（heap）上  // 所以 Java 的这个 d 实际上是一个指针，但 Java 的语法不要求写 Dog* 表示指针  // 同样的表达在 C++ 中要写成：Dog* d = new Dog();  // 根据上面 reference_test 函数体里的写法，这里还可以这样写  Animal&amp; a2 = d;  cout &lt;&lt; &quot;Animal pointer to dog: &quot; &lt;&lt; endl;  cout &lt;&lt; &quot;animal address: &quot; &lt;&lt; &amp;a2 &lt;&lt; endl;  a2.speak();  // 变量 a1 指向猫  a1 = &amp;c;  cout &lt;&lt; &quot;Animal pointer to cat: &quot; &lt;&lt; endl;  cout &lt;&lt; &quot;animal address: &quot; &lt;&lt; a1 &lt;&lt; endl;  a1-&gt;speak();}// ###########################################################//                        模板（Template）// ###########################################################// template 模板类似 Java 的泛型，使得同一段代码可以适应不同的数据类型，从而增加代码的复用性和灵活性template &lt;typename T&gt;   // T 是类型参数class Auto_ptr         // 这里用 template 功能创建智能指针 Auto_ptr 实现在生命周期结束后自动释放{  T* m_ptr;public:  // Pass in a pointer to &quot;own&quot; via the constructor  Auto_ptr(T* ptr=nullptr)  {    this-&gt;m_ptr = ptr;  }  // Copy constructor to handle ownership transfer  Auto_ptr(Auto_ptr &amp;a)  {    this-&gt;m_ptr = a.m_ptr;    a.m_ptr = nullptr;    cout &lt;&lt; &quot;ownership transfer (copy constructor)&quot; &lt;&lt; endl;  }  Auto_ptr&amp; operator = (Auto_ptr &amp;a)  {    if (&amp;a == this) {      return *this;    }    delete m_ptr;    m_ptr = a.m_ptr;    a.m_ptr = nullptr;    cout &lt;&lt; &quot;ownership transfer (assignment)&quot; &lt;&lt; endl;    return *this;  }  // The destructor will make sure it gets deallocated  ~Auto_ptr()  {    delete m_ptr;  }  // Overload dereference and operator-&gt; so we can use Auto_ptr like m_ptr.  T&amp; operator * () const { return *m_ptr; }  T* operator -&gt; () const { return m_ptr; }};// A sample class to prove the above worksclass Resource{public:  int x = 42;    Resource() { cout &lt;&lt; &quot;Resource acquired\n&quot;; }    ~Resource() { cout &lt;&lt; &quot;Resource destroyed\n&quot;; }    void sayHi() { cout &lt;&lt; &quot;Hi &quot; &lt;&lt; x &lt;&lt; endl; }};void pass_by_value(Auto_ptr&lt;Resource&gt; ptr){  cout &lt;&lt; &quot;pass_by_value&quot; &lt;&lt; endl;}void smart_ptr_test(){  cout &lt;&lt; &quot;---------------- smart_ptr_test ----------------&quot; &lt;&lt; endl;  Auto_ptr&lt;Resource&gt; r1(new Resource());  r1-&gt;sayHi();  // Auto_ptr&lt;Resource&gt; r2(r1);  // pass_by_value(r1);  Auto_ptr&lt;Resource&gt; r2;  r2 = r1;  r2-&gt;sayHi();}int** pointer_of_pointer(){  int** p = nullptr;  {    int* x = new int(10);    p = &amp;x;  }  cout &lt;&lt; &quot;inside function: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;inside function: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  cout &lt;&lt; &quot;inside function: **p = &quot; &lt;&lt; **p &lt;&lt; endl;  return p;}void pointer_of_pointer_test(){  cout &lt;&lt; &quot;---------------- pointer_of_pointer_test ----------------&quot; &lt;&lt; endl;  int** p = pointer_of_pointer();  cout &lt;&lt; &quot;outside function: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;outside function: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  cout &lt;&lt; &quot;outside function: **p = &quot; &lt;&lt; **p &lt;&lt; endl;  // wrong result}// ###########################################################//                  智能指针之 Unique Pointer// ###########################################################// 智能指针的“智能”体现在于它们在生命周期结束时自动释放资源，避免手动管理内存带来的问题，提高代码的安全性和可靠性// 普通指针需要手动释放内存 delete rawPtr; 而智能指针会在不再需要使用时自动释放分配的内存，从而避免了内存泄漏的风险// 智能指针还会在底层实现一些机制，如引用计数或所有权管理，以确保内存安全性，避免悬垂指针或重复释放内存等问题int* pass_pointer(int* p){  cout &lt;&lt; &quot;----- pass_pointer(int* p) -----&quot; &lt;&lt; endl;  cout &lt;&lt; &quot;inside function: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;inside function: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  cout &lt;&lt; &quot;----- outside pass_pointer -----&quot; &lt;&lt; endl;  return p;}struct IntOwner{public:  unique_ptr&lt;int&gt; p;  ~IntOwner()  {    // 符号 ~ 标记的函数是析构函数（Destructor）    // 它一个特殊的成员函数，它在对象生命周期结束时被调用    // 这里是打印输出字符串 &quot;IntOwner destructor&quot;    cout &lt;&lt; &quot;IntOwner destructor&quot; &lt;&lt; endl;  }};unique_ptr&lt;IntOwner&gt; create_int_owner(unique_ptr&lt;int&gt; p){  // 这一行代码创建了一个 unique_ptr 智能指针对象 owner  // &lt;IntOwner&gt; 表示 owner 指针所指向的数据类型是 IntOwner  // new IntOwner() 作为参数传入构造类型为 unique_ptr&lt;IntOwner&gt; 的指针  // 所以 owner(new IntOwner()) 是将其初始化为指向 heap 上 new IntOwner() 实例的地址  // 下文的 shared_ptr&lt;int&gt; p4(p3); 也用到类似语法  unique_ptr&lt;IntOwner&gt; owner(new IntOwner());  owner-&gt;p = std::move(p);  return owner;}void unique_ptr_test(){  cout &lt;&lt; &quot;---------------- unique_ptr_test ----------------&quot; &lt;&lt; endl;  // 相当于 Rust 的：let p1 = String::from(&quot;Hello&quot;);  // Rust 里的变量默认就是 unique 的，因为只能有一个 owner  // C++ 里要实现 Rust 这种 unique 的单 owner 效果就要用 unique_ptr  // 对比普通指针写法：  int* p = new int(10);  // 普通指针，类型是 int*  unique_ptr&lt;int&gt; p1 = make_unique&lt;int&gt;(10); // unique 指针，“类型”是 unique_ptr&lt;int&gt;  // 为啥 unique 指针是这种奇怪的写法？  // 因为它不是 C++ 语言本身（编译器）直接实现的，而是用宏（macro）和模版（template）实现的  // 算是一片自定义的用户代码  cout &lt;&lt; &quot;unique_ptr: p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;  cout &lt;&lt; &quot;unique_ptr: *p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl;  // 编译不通过，因为 p1 是 unique 的，不能和 p2 共享数据  // unique_ptr&lt;int&gt; p2 = p1;  // 如果要 p2 取得 p1 的值，就要用 std::move 转移 “ownership”  // Rust 中默认就是 move ，所以可以直接写 let p2 = p1;  // 在这行之后，上面的 p1 变量就不能用了  unique_ptr&lt;int&gt; p2 = std::move(p1);   // 这里明显能看到是 move（比 Rust 清晰）  cout &lt;&lt; &quot;unique_ptr: p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;  cout &lt;&lt; &quot;unique_ptr: *p2 = &quot; &lt;&lt; *p2 &lt;&lt; endl;  cout &lt;&lt; &quot;unique_ptr: p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;  // nullptr 在 C++ 中 0x0 表示 null  // 解引用 null pointer 会让程序崩溃中断  // cout &lt;&lt; &quot;*p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl;  // Error: dereferencing nullptr  // std::move 实现了类似 Rust 这样转移 ownership 的目的  // 只不过变量 p1 仍然存在，它的值变为了 null ，要注意不要再使用它  // Rust 中 p1 会直接用不了  // C++ 里也可以释放 p1 的内存  delete p1.get();  // 读取 p2 的值，类似 Rust 的 borrow :  // let p3 = &amp;p2;  int* p3 = p2.get();  cout &lt;&lt; &quot;normal pointer: p3 = &quot; &lt;&lt; p3 &lt;&lt; endl;  cout &lt;&lt; &quot;normal pointer: *p3 = &quot; &lt;&lt; *p3 &lt;&lt; endl;  // Rust 里是 let p4 = p3; // p4 也是 borrow 的，owner 还是 p2  int* p4 = pass_pointer(p3);  cout &lt;&lt; &quot;normal pointer: p4 = &quot; &lt;&lt; p4 &lt;&lt; endl;  cout &lt;&lt; &quot;normal pointer: *p4 = &quot; &lt;&lt; *p4 &lt;&lt; endl;  { // 花括号指定了一个 scope（作用域），int_owner 只在这个范围内有效    unique_ptr&lt;IntOwner&gt; int_owner = create_int_owner(std::move(p2));    cout &lt;&lt; &quot;unique_ptr: int_owner-&gt;p = &quot; &lt;&lt; int_owner-&gt;p &lt;&lt; endl;    cout &lt;&lt; &quot;unique_ptr: *int_owner-&gt;p = &quot; &lt;&lt; *int_owner-&gt;p &lt;&lt; endl;  }  // 作为 unique pointer 的 int_owner 出了花括号之外就会被释放，内存被回收  cout &lt;&lt; &quot;unique_ptr: p2 = &quot; &lt;&lt; p2 &lt;&lt; endl; // p2 被 move 了，所以成了 null pointer}// ###########################################################//                   智能指针之 Shared Pointer// ###########################################################void shared_ptr_test(){  cout &lt;&lt; &quot;---------------- shared_ptr_test ----------------&quot; &lt;&lt; endl;  // shared pointer 实际上就是 Rust 里面的 Rc  // shared_ptr 的使用语法和 unique_ptr 类似  shared_ptr&lt;int&gt; p1 = make_shared&lt;int&gt;(10);  // 在 heap 里造出 shared pointer  cout &lt;&lt; &quot;shared_ptr: p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;  // 指针 p1 指向（存放） heap 里的地址  cout &lt;&lt; &quot;shared_ptr: *p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl;  // 调用 .use_count() 可以查看引用计数  cout &lt;&lt; &quot;in scope shared_ptr: p1.use_count() = &quot; &lt;&lt; p1.use_count() &lt;&lt; endl;  {    // C++ 的赋值依靠一个 copy constructor    // 由于 p1 是 shared pointer ，所以它有一个引用计数在这    // 当这里做这个赋值操作的时候，copy constructor 会增加这个引用计数    // 思考：为何不用其他比如 int&amp; y = x; 的方式来共享，而要用看起来更复杂的 shared_ptr ？    shared_ptr&lt;int&gt; p2 = p1;      cout &lt;&lt; &quot;shared_ptr: p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;    cout &lt;&lt; &quot;shared_ptr: *p2 = &quot; &lt;&lt; *p2 &lt;&lt; endl;    cout &lt;&lt; &quot;shared_ptr: p1 = &quot; &lt;&lt; p1 &lt;&lt; endl;    cout &lt;&lt; &quot;shared_ptr: *p1 = &quot; &lt;&lt; *p1 &lt;&lt; endl;    // 查看引用计数    cout &lt;&lt; &quot;in scope shared_ptr: p1.use_count() = &quot; &lt;&lt; p1.use_count() &lt;&lt; endl;    cout &lt;&lt; &quot;in scope shared_ptr: p2.use_count() = &quot; &lt;&lt; p2.use_count() &lt;&lt; endl;  }  // 出了花括号，p2 会被释放掉，引用计数再次减小为 1  cout &lt;&lt; &quot;out scope shared_ptr: p1.use_count() = &quot; &lt;&lt; p1.use_count() &lt;&lt; endl;  // convert normal pointer to shared_ptr  int* p3 = new int(20);  int* p5w;  {    // p4(p3) 是一种初始化 shared_ptr 的语法    // 通过将 p3 作为参数传递给 p4 的构造函数，p4 将获取对这个动态分配的整数对象的所有权    // 并在 p4 生命周期结束时，会自动释放这个对象    shared_ptr&lt;int&gt; p4(p3); // 把普通指针转换为 Rc 的指针，但这样做不是对的    cout &lt;&lt; &quot;shared_ptr: p4 = &quot; &lt;&lt; p4 &lt;&lt; endl;    cout &lt;&lt; &quot;shared_ptr: *p4 = &quot; &lt;&lt; *p4 &lt;&lt; endl;    cout &lt;&lt; &quot;shared_ptr: p4.use_count() = &quot; &lt;&lt; p4.use_count() &lt;&lt; endl;    // // Can&#39;t have two of them converted from raw pointer    // // 上面从 p3 造了一个 shared pointer 指针 p4    // // 这里又从 p3 造了一个 shared pointer 指针 p4w    // // p4 和 p4w 都认为自己的引用计数是 1，这就有问题了：    // // 当 p4 出了作用域之后，由于引用计数是 1 ，所以它会回收一次这个内存    // // 等到 p4w 出了作用域之后，由于引用计数也是 1 ，于是它会再回收一次    // // 然后 p4w 发现没有内存可以回收，于是程序就崩溃了    // shared_ptr&lt;int&gt; p4w(p3);    // cout &lt;&lt; &quot;shared_ptr: p4 = &quot; &lt;&lt; p4w &lt;&lt; endl;    // cout &lt;&lt; &quot;shared_ptr: *p4 = &quot; &lt;&lt; *p4w &lt;&lt; endl;    // cout &lt;&lt; &quot;shared_ptr: p4.use_count() = &quot; &lt;&lt; p4w.use_count() &lt;&lt; endl;    // // 所以在 C++ 里面，永远不应该从一个普通的 pointer 造出一个 shared pointer    // // 就像在 Rust 里面你不能把一个 borrow 的引用变成一个 owned 的    // // 比如下面的 Rust 代码就是这样的表达，无法通过编译：    // // cannot move out of `*x` which is behind a shared reference    // let s = String::from(&quot;hello&quot;);    // let x = &amp;s;    // let y = *x;    // // C++ 的这些智能指针不是语言自己实现的，所以它没法阻止你这样写，所以程序会崩溃    // // 用 make_shared 来创建 shared pointer 就能避免上述问题，因为会编译不过    // convert shared_ptr to normal pointer    // int* p5 = p4.get(); 这个操作相当于 borrow    // 你可以读取 p4 ，但不能释放 p4 ，你也不能在 p4 出了作用域之外还使用 p5    int* p5 = p4.get();    p5w = p5;    cout &lt;&lt; &quot;normal pointer: p5 = &quot; &lt;&lt; p5 &lt;&lt; endl;    cout &lt;&lt; &quot;normal pointer: *p5 = &quot; &lt;&lt; *p5 &lt;&lt; endl;  }  // // p5w 指针的值（地址）还是 p5 的值，但是内容已经变了  // // p4 除了作用域被释放了，所以内存的内容变了，所以 *p5w 的值是错的  // cout &lt;&lt; &quot;p5w = &quot; &lt;&lt; p5w &lt;&lt; endl;  // cout &lt;&lt; &quot;*p5w = &quot; &lt;&lt; *p5w &lt;&lt; endl;   // // 出了作用域之后，p5w 竟然还能用，说明 C++ 内存的安全保障没有 Rust 那么强}void shared_ptr_bug(){  // 和上文的 p4w 一样，不应该把普通指针转为 shared pointer  // C++ 里，永远不应该从一个普通的 pointer 造出一个 shared pointer  int* x = new int(10);  shared_ptr&lt;int&gt; p1(x);    // 能编译通过，但埋下隐患  // shared_ptr&lt;int&gt; p2(x);  // can&#39;t have this  // This can be avoided by using make_shared  // 使用 make_shared 来创造 shared pointer 可以让编译器检查出此类错误  // shared_ptr&lt;int&gt; p1 = make_shared&lt;int&gt;(x);  // 编译不通过}void add1(int* x){  *x += 1;}void shared_ptr_mutation(){  cout &lt;&lt; &quot;---------------- shared_ptr_mutation ----------------&quot; &lt;&lt; endl;  // 你可以对 pointer 指向的对象进行修改，这和 Rust 有点不同  // Rust 的 Rc 你是不能修改它的值的，你必须要在 Rc 里套一个 RefCell 才能改它的值  // C++ 没有这类读写锁来防止多个人同时修改同一个内存上的数据  // C++ 只管这些内存到最后被释放掉，而且只能释放一次  // 至于多线程的时候，你要怎么处理这些读写冲突问题，那就是你自己的事情，C++ 不管  shared_ptr&lt;int&gt; p = make_shared&lt;int&gt;(10);  cout &lt;&lt; &quot;shared_ptr: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;shared_ptr: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  // Can use function that takes normal pointer  // and can mutate the value  add1(p.get());  cout &lt;&lt; &quot;shared_ptr (after add1): *p = &quot; &lt;&lt; *p &lt;&lt; endl;  *p += 1;  cout &lt;&lt; &quot;shared_ptr (after +=1): *p = &quot; &lt;&lt; *p &lt;&lt; endl;}class Example {  public:    void sayHello() { cout &lt;&lt; &quot;Hello, world!\n&quot;; }};void misuseSharedPtr() {  Example example; // example 是 stack 上的对象，不是指针  // std::shared_ptr&lt;Example&gt; ptr(&amp;example); // 错误用法！  // shared_ptr&lt;Example&gt; ptr(&amp;example, [](Example*){});  // OK  // make_shared&lt;Example&gt;(example) 在 heap 上复制了一份 example 的数据，所以看起来没问题  // 但是一般也不要这么写  shared_ptr&lt;Example&gt; ptr = make_shared&lt;Example&gt;(example);  // seems OK, used copy constructor?  ptr-&gt;sayHello();}class Example2 {public:  shared_ptr&lt;int&gt; data;  Example2(shared_ptr&lt;int&gt; data) : data(data)   {    cout &lt;&lt; &quot;Example2 created with value: &quot; &lt;&lt; *data &lt;&lt; endl;  }  // 使用默认的拷贝构造函数：  // 这个构造函数的作用是用于创建一个新的 Example2 对象  // 其成员变量 data 的值与另一个 Example2 对象相同  // 使用 = default 来声明拷贝构造函数，表示使用编译器生成的默认实现  // 这种语法通常用于避免手动实现拷贝构造函数，特别是当类中没有需要手动管理的资源时。  Example2(const Example2&amp; other) = default;  ~Example2()   {    cout &lt;&lt; &quot;Example2 destroyed, value was: &quot; &lt;&lt; *data &lt;&lt; endl;  }};void shared_ptr_test2(){  cout &lt;&lt; &quot;---------------- shared_ptr_test2 ----------------&quot; &lt;&lt; endl;  shared_ptr&lt;int&gt; data = make_shared&lt;int&gt;(42);  Example2 a(data);  Example2 b = a; // 拷贝构造  // 修改 b 的 data，a 的 data 也会看到改变  *b.data = 100;  cout &lt;&lt; &quot;a&#39;s value: &quot; &lt;&lt; *a.data &lt;&lt; endl; // 输出 100  cout &lt;&lt; &quot;b&#39;s value: &quot; &lt;&lt; *b.data &lt;&lt; endl; // 输出 100  cout &lt;&lt; &quot;data&#39;s value: &quot; &lt;&lt; *data &lt;&lt; endl; // 输出 100}// ###########################################################//                        其他代码行为测试// ###########################################################void ref_of_ref(){  cout &lt;&lt; &quot;---------------- ref_of_ref ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;string&gt; s = make_unique&lt;string&gt;(&quot;Hello&quot;);  string* r1 = s.get(); // 把 unique_ptr 的指针拿出来  string** r2 = &amp;r1;  cout &lt;&lt; &quot;s = &quot; &lt;&lt; s &lt;&lt; endl;  cout &lt;&lt; &quot;*s = &quot; &lt;&lt; *s &lt;&lt; endl;  cout &lt;&lt; &quot;r1 = &quot; &lt;&lt; r1 &lt;&lt; endl;  cout &lt;&lt; &quot;*r1 = &quot; &lt;&lt; *r1 &lt;&lt; endl;  cout &lt;&lt; &quot;r2 = &quot; &lt;&lt; r2 &lt;&lt; endl;  cout &lt;&lt; &quot;*r2 = &quot; &lt;&lt; *r2 &lt;&lt; endl;  cout &lt;&lt; &quot;**r2 = &quot; &lt;&lt; **r2 &lt;&lt; endl;}void pass_unique_ptr(unique_ptr&lt;int&gt; p){  cout &lt;&lt; &quot;pass_unique_ptr: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;pass_unique_ptr: *p = &quot; &lt;&lt; *p &lt;&lt; endl;}void pass_unique_ptr_test(){  cout &lt;&lt; &quot;---------------- pass_unique_ptr_test ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;int&gt; p = make_unique&lt;int&gt;(10);  cout &lt;&lt; &quot;unique_ptr: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;unique_ptr: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  pass_unique_ptr(std::move(p));  cout &lt;&lt; &quot;unique_ptr: p = &quot; &lt;&lt; p &lt;&lt; endl;  // nullptr  // cout &lt;&lt; &quot;unique_ptr: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  // Error: dereferencing nullptr}unique_ptr&lt;int&gt; output_unique_ptr(){  unique_ptr&lt;int&gt; p = make_unique&lt;int&gt;(10);  return p;}void output_unique_ptr_test(){  cout &lt;&lt; &quot;---------------- output_unique_ptr_test ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;int&gt; p = output_unique_ptr();  cout &lt;&lt; &quot;output_unique_ptr_test: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;output_unique_ptr_test: *p = &quot; &lt;&lt; *p &lt;&lt; endl;}unique_ptr&lt;int&gt; pass_through_unique_ptr(unique_ptr&lt;int&gt; p){  return p;}void pass_through_unique_ptr_test(){  cout &lt;&lt; &quot;---------------- pass_through_unique_ptr_test ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;int&gt; p = make_unique&lt;int&gt;(10);  cout &lt;&lt; &quot;pass_through_unique_ptr_test: p = &quot; &lt;&lt; p &lt;&lt; endl;  cout &lt;&lt; &quot;pass_through_unique_ptr_test: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  unique_ptr&lt;int&gt; p2 = pass_through_unique_ptr(std::move(p));  cout &lt;&lt; &quot;pass_through_unique_ptr_test: p2 = &quot; &lt;&lt; p2 &lt;&lt; endl;  cout &lt;&lt; &quot;pass_through_unique_ptr_test: *p2 = &quot; &lt;&lt; *p2 &lt;&lt; endl;  cout &lt;&lt; &quot;pass_through_unique_ptr_test: p = &quot; &lt;&lt; p &lt;&lt; endl;  // nullptr  // cout &lt;&lt; &quot;pass_through_unique_ptr_test: *p = &quot; &lt;&lt; *p &lt;&lt; endl;  // Error: dereferencing nullptr}template &lt;typename T&gt;T pass_through(const T&amp; x){  return x;}void pass_through_test(){  cout &lt;&lt; &quot;---------------- pass_through_test ----------------&quot; &lt;&lt; endl;  int x = 10;  int y = pass_through(x);  cout &lt;&lt; &quot;pass_through_test: y = &quot; &lt;&lt; y &lt;&lt; endl;  string s = &quot;Hello&quot;;  string t = pass_through(s);  cout &lt;&lt; &quot;pass_through_test: t = &quot; &lt;&lt; t &lt;&lt; endl;  unique_ptr&lt;int&gt; p = make_unique&lt;int&gt;(10);  // unique_ptr&lt;int&gt; q = pass_through(p);  // doesn&#39;t work  // cout &lt;&lt; &quot;pass_through_test: q = &quot; &lt;&lt; q &lt;&lt; endl;}class IntContainer{public:  int* x;  IntContainer(int* x) : x(x) {}  ~IntContainer()  {    cout &lt;&lt; &quot;IntContainer destructor: x = &quot; &lt;&lt; x &lt;&lt; endl;  }};class RawContainer{public:  IntContainer* ic;  RawContainer(IntContainer* ic) : ic(ic) {}  ~RawContainer()  {    cout &lt;&lt; &quot;RawContainer destructor: ic = &quot; &lt;&lt; ic &lt;&lt; endl;  }};void raw_container_test(){  cout &lt;&lt; &quot;---------------- raw_container_test ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;int&gt; int_unique = make_unique&lt;int&gt;(10);  int* int_raw = int_unique.get();  // 读取出 int_unique 的指针放到 int_raw 里 - 相当于 Rust 里的 borrow  // 造出一个 IntContainer 对象，然后把 int_raw 包在里面，然后各种嵌套  // 下面的代码显示这里的内存分配和释放没有问题 - 通过各种 ~ 标记的 destructor 打印确认对象被回收释放  unique_ptr&lt;IntContainer&gt; int_container_unique = make_unique&lt;IntContainer&gt;(int_raw);  IntContainer* int_container_raw = int_container_unique.get();  unique_ptr&lt;RawContainer&gt; raw_container = make_unique&lt;RawContainer&gt;(int_container_raw);  cout &lt;&lt; &quot;raw_container_test: int_unique = &quot; &lt;&lt; int_unique &lt;&lt; endl;  cout &lt;&lt; &quot;raw_container_test: int_raw = &quot; &lt;&lt; int_raw &lt;&lt; endl;  cout &lt;&lt; &quot;raw_container_test: int_container_unique = &quot; &lt;&lt; int_container_unique &lt;&lt; endl;  cout &lt;&lt; &quot;raw_container_test: *int_container_unique-&gt;x = &quot; &lt;&lt; *int_container_unique-&gt;x &lt;&lt; endl;  cout &lt;&lt; &quot;raw_container_test: int_container_raw = &quot; &lt;&lt; int_container_raw &lt;&lt; endl;  cout &lt;&lt; &quot;raw_container_test: raw_container = &quot; &lt;&lt; raw_container &lt;&lt; endl;}class UniqueContainer{public:  unique_ptr&lt;IntContainer&gt; ic;  // must pass reference _and_ move because no copy constructor for unique_ptr  UniqueContainer(unique_ptr&lt;IntContainer&gt;&amp; ic) : ic(std::move(ic)) {}  ~UniqueContainer()  {    cout &lt;&lt; &quot;UniqueContainer destructor: ic = &quot; &lt;&lt; ic &lt;&lt; endl;  }};void unique_container_test(){  // 这个例子和上面的 raw_container_test 类似，只不过两个对象里面放的是 unique pointer  // 在 C++ 中，函数调用的参数传递会调用 copy structor ，但是 unique pointer 是没有 copy structor 的  // 所以期间会需要 &amp; 符号和 std::move 操作  // 最后通过 destructor 来观察判断内存被正确回收释放  cout &lt;&lt; &quot;---------------- unqiue_container_test ----------------&quot; &lt;&lt; endl;  unique_ptr&lt;int&gt; int_unique = make_unique&lt;int&gt;(10);  int* int_raw = int_unique.get();  unique_ptr&lt;IntContainer&gt; int_container_unique = make_unique&lt;IntContainer&gt;(int_raw);//  unique_ptr&lt;IntContainer&gt; int_container_unique2 = std::move(int_container_unique);  unique_ptr&lt;UniqueContainer&gt; unique_container = make_unique&lt;UniqueContainer&gt;(int_container_unique);//  unique_ptr&lt;UniqueContainer&gt; unique_container = make_unique&lt;UniqueContainer&gt;(std::move(int_container_unique));  // After move, int_container_unique is nullptr  cout &lt;&lt; &quot;int_unique owns = &quot; &lt;&lt; (int_unique ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; &quot;, value = &quot; &lt;&lt; *int_unique &lt;&lt; endl;  cout &lt;&lt; &quot;int_raw points to = &quot; &lt;&lt; int_raw &lt;&lt; endl;  cout &lt;&lt; &quot;int_container_unique has been moved = &quot; &lt;&lt; (int_container_unique ? &quot;No, not null&quot; : &quot;Yes, nullptr&quot;) &lt;&lt; endl;  if (unique_container &amp;&amp; unique_container-&gt;ic)   {    cout &lt;&lt; &quot;unique_container-&gt;ic-&gt;x points to = &quot; &lt;&lt; unique_container-&gt;ic-&gt;x &lt;&lt; endl;    cout &lt;&lt; &quot;*unique_container-&gt;ic-&gt;x = &quot; &lt;&lt; *unique_container-&gt;ic-&gt;x &lt;&lt; endl;  }  cout &lt;&lt; &quot;unique_container owns = &quot; &lt;&lt; (unique_container ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;}int main() // C++ 中规定 main 函数一定要返回整数，所以是 int main(){  // basic_test();  // pointer_test();  // address_test();  // reference_test();  // pass_array_test();  // inheritance_test();  // smart_ptr_test();  // pointer_of_pointer_test();  // unique_ptr_test();  // shared_ptr_test();  // shared_ptr_bug();  // misuseSharedPtr();  // shared_ptr_test2();  // shared_ptr_mutation();  // ref_of_ref();  // pass_unique_ptr_test();  // output_unique_ptr_test();  // pass_through_unique_ptr_test();  // pass_through_test();  // raw_container_test();  // unique_container_test();  return 0;  }</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 入门</title>
      <link href="/2024/04/22/rust-basics/"/>
      <url>/2024/04/22/rust-basics/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.rust-lang.org" target="_blank" rel="noopener">Rust</a> 算是一个<strong>底层</strong>的系统编程语言。和有<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">垃圾回收（Garbage Collection）</a>的语言不一样，Rust 作为一种底层的系统语言，在内存管理方面有一些特殊的地方。它用某种语言特性设计（<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">ownership</a>）（<strong>部分</strong>）取代了垃圾回收。</p><p>应该说 <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> 的<a href="https://learn.microsoft.com/en-us/cpp/cpp/pointers-cpp?view=msvc-170" target="_blank" rel="noopener"><strong>指针</strong></a>也能实现类似的功能，但 Rust 增加了 ownership 这些概念和与之相应的使用规则，并且会对代码进行这些规则相关的<strong>静态检查</strong>——即运行代码前，编译器检会查你代码对内存的使用是否按照 Rust 的规则做对了。总的来说， Rust 的静态类型检查相比 C++ 等其他语言增加了内存使用的规范的检测，防止代码运行时出现内存问题。</p><p>Rust 的这些 <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">ownership</a>，<a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html" target="_blank" rel="noopener">lifetime</a> 之类的<strong>静态检查设计</strong>，主要目的是让人们可以尽量少地使用 <a href="https://doc.rust-lang.org/book/ch15-04-rc.html" target="_blank" rel="noopener">Rc（引用计数）</a>。不过到了复杂的数据结构，比如<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)" target="_blank" rel="noopener">解释器</a>，仍然是要用 <strong>Rc</strong> 的。只是比较简单的那一部分代码你可以不用 <strong>Rc</strong> 。</p><p>由于 Rust 语言的内存管理通过少用或不用 Rc ，减少了 Rc 的开销，代码性能据说在某些情况下会快很多。所以可以稍微重视一下。当然，它的这种设计并没有很完善，其中有一些多余而复杂东西（比如 Rust 总有一些自以为方便的隐式操作，而非写什么代码就是什么的所见即所得，类型系统也反直觉地水），但理解它的内存管理思路能给人们提供启发。进而可以改进自己的代码思路。</p><p>像 <a href="https://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="noopener">C++</a> 稍微“扩展”一下 <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener">unique_ptr</a>，也能实现 Rust 的内存管理精髓。但若没有 Rust 这套内存规则的作为大方向指导我们的思路，那我们可能就会不知道如何有效地使用这些 <code>unique_ptr</code> 等指针。不过像这种 <strong>ownership</strong> 的思路可能在 C++ 里就已经有了（<a href="https://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener">unique_ptr</a> 和 <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener">shared_ptr</a>），只不过 C++ 没有类型系统来检查它：比如 C++ 中指针 <code>p1</code> 被 <a href="https://en.cppreference.com/w/cpp/utility/move" target="_blank" rel="noopener">move</a> 之后，仍然能使用，只不过 <code>p1</code> 指向的地址是 <code>0</code> 而已。</p><p>初次使用 Rust 语言编程很可能会非常痛苦，除了没有所见即所得的设计（各种隐式操作），期间还有复杂的内存管理规则要适应。多数时候更是要<strong>连蒙带猜</strong>。不过如果能耐心坚持到成功写出一个解释器，也许对内存管理的理解会上升一个台阶。</p><p>新的理解也包括<a href="https://www.yinwang.org/blog-cn/2016/09/18/rust" target="_blank" rel="noopener">也许除了垃圾回收（GC）和引用计数（RC），内存管理没有其它更好更简单的办法</a>。</p><hr><h3 id="Rust-编程环境设置"><a href="#Rust-编程环境设置" class="headerlink" title="Rust 编程环境设置"></a>Rust 编程环境设置</h3><p>简单的代码可以直接先去官网的 <a href="https://play.rust-lang.org/" target="_blank" rel="noopener">Rust Playground</a> 在线运行。这样不用进行任何配置和安装，最方便。之后的正式学习，建议使用友好的 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a> 来运行 <strong>Rust</strong> 代码。</p><p>以 <strong>MacOS</strong> 操作系统为例，先<a href="https://doc.rust-lang.org/book/ch01-01-installation.html" target="_blank" rel="noopener">安装 Rust</a> ：</p><pre><code class="lang-bash">## 官方推荐的安装方式，适用于 Linux 和 MacOS$ curl --proto &#39;=https&#39; --tlsv1.2 https://sh.rustup.rs -sSf | sh## 如果有 Homebrew ，也可以使用它安装 Rust$ brew install rust## 安装完后调用下面的 rustc 命令应该能正确查看版本号$ rustc --versionrustc 1.77.2 (25ef9e3d8 2024-04-09) (Homebrew)</code></pre><p>最后参考<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 把 <strong>VS Code</strong> 软件安装设置完成即可。</p><p>如果想方便地一键格式化自己写的代码，比如设置 <code>TAB</code> 键的空格数量等，可以继续安装 <a href="https://github.com/rust-lang/rustfmt" target="_blank" rel="noopener">rustfmt</a> </p><pre><code class="lang-bash">## 通过上面官方推荐方式 curl 安装的 Rust ，才有 rustup 这个命令$ rustup component add rustfmt## 如果是 Homebrew 安装的 Rust ，就要用 Homebrew 来安装 rustfmt$ brew install rustfmt</code></pre><p>完成安装之后根据 <a href="https://rust-lang.github.io/rustfmt/" target="_blank" rel="noopener">rustfmt 文档</a>新建 <code>rustfmt.toml</code> 文件设置好想要的格式，即可在 <strong>VS Code</strong> 中右键点击 <code>Format Document</code> 或是快捷键：<code>option</code> + <code>shift</code> + <code>F</code> 来格式化代码。注意，<code>rustfmt.toml</code> 文件里的设置项分为 stable 和 unstable ，如果要开启 unstable 的设置项，需要使用 <a href="https://rust-lang.github.io/rustup/concepts/channels.html" target="_blank" rel="noopener">Nightly</a> 版本的 Rust ，即最不稳定版。</p><p>也可以在终端中调用 <code>rustfmt</code> 命令来格式化：</p><pre><code class="lang-bash">$ rustfmt demo.rs</code></pre><hr><h3 id="Rust-的基本操作"><a href="#Rust-的基本操作" class="headerlink" title="Rust 的基本操作"></a>Rust 的基本操作</h3><p>每次接触新的编程语言，基本都可以从「<strong>变量定义</strong>」，「<strong>函数调用</strong>」，「<strong>条件分支</strong>」，「<strong>类型</strong>」和「<strong>常见数据结构</strong>」这几个方向入手快速熟悉。至于语言的一些特有的特性，之后再根据需要补充学习即可。</p><p>由于 <strong>Rust</strong> 代码需要编译，加上期间产生的各式各样的文件，最好专门建一个文件夹 <code>demo</code> 来进行下面的编程操作。以便管理。</p><p>在文件夹 <code>demo</code> 中新建后缀为 <code>.rs</code> 的文件，比如 <code>demo.rs</code> ，之后编辑完代码，就能用 <strong>VS Code</strong> 里的 <strong>Code Runner</strong> 来一键调用上面安装的 <code>rustc</code> 完成编译并运行。关于 VS Code 的具体操作和设置参见<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 。</p><pre><code class="lang-rust">// 这部分 allow 代码是消除 rust 编译器警告的信息// 这样就能只看到代码打印出的结果，没有多余视线干扰// 注意这不是全局生效的，对每一个需要的函数，都要写一次#[allow(unused_variables)]#[allow(dead_code)]#[allow(unused_mut)]#[allow(unused_imports)]#[allow(unused_parens)]// 和 Java 类似，Rust 需要一个 main 函数作为入口来运行其中的代码// fn 相当于 function ，是定义函数的关键词fn main(){  let x = 2 * 3;  // 格式化字符串中的变量有时可以写在花括号里，有时不行  // 所以统一写到外面比较好，统一视觉，避免写 &quot;x = {x}&quot;  println!(&quot;x = {}&quot;, x);    // Rust 是需要写类型的，i32 代表 32 位带符号的整数，上面 x 没写是因为有类型推导  // 「类型推导」其实是错误的语言设计，应该在定义处直接标记类型。方便阅读，且提高代码的表达能力  // 「类型推导」会限制代码的表达能力，导致很多写法不能写，否则没法正确推导出这些写法下的数据类型  // Rust 是系统编程的语言，每个类型的尺寸（占内存的空间）都是固定的  let y: i32 = 1 + x;  println!(&quot;y = {}&quot;, y);  // 定义好的变量默认不能赋值修改  // y = &quot;9&quot;;  // error: cannot assign twice to immutable variable  // 用 mut 关键词来定义可赋值的变量（mut 表示 mutable）  let mut z = 5;  println!(&quot;first z = {z}&quot;);  // 这样的写法不好，任何变量都应该给一个初始值才对  // 设计得好的语言里面没有 variable declaration 这个概念  // let mut z;  z = 10;  println!(&quot;first z = {z}&quot;);  // 同名变量在 rust 里可以重复定义，且可以不同类型（这里同样有类型推导 type inferred）  // 注意！Rust 里，此时 y 的类型不是 String ，而是 &amp;str 类型，该类型是指向字符串的一个“引用”  let y = &quot;Hello&quot;;  println!(&quot;y = {}&quot;, y);  // 数组 - 默认也是不能更改，若要可更改则用 let mut a: [i32; 3] = [1, 2, 3]  let a: [i32; 3] = [1, 2, 3];  println!(&quot;a = {:?}&quot;, a);  println!(&quot;a[0] = {}, a[1] = {}, a[2] = {}&quot;, a[0], a[1], a[2]);  // 定义重复数组内容的方便写法 - 全是 5 的数组为例  let b = [5; 20];  println!(&quot;b = {:?}&quot;, b);  // 元组 - tuples（可以存在不同类型的内容）  // tuple 定义虽没有用 mut 关键词，但 t 的内容是可以赋值更改的：t.1 = True  let t: (i32, bool, char) = (42, false, &#39;X&#39;);  println!(&quot;t = {:?}&quot;, t);  println!(&quot;t.0 = {}, t.1 = {}, t.2 = {}&quot;, t.0, t.1, t.2);  println!(&quot;{}&quot;, (42, false, &#39;X&#39;).1);  // 匿名函数：x =&gt; x + 1  println!(&quot;(|x| x + 1)(5) = {}&quot;, (|x| x + 1)(5));  // 定义 add1 函数 - 不标记(输入和返回)类型，依赖类型推导  // Rust 是从下一行的 println! 里的调用 add1(5) 推导出来的  let add1 = |x| x + 1;  println!(&quot;add1(5) = {}&quot;, add1(5));   // 若无 add1(5)，Rust 推不出类型会报错，除非标记类型  // 标记类型的函数定义  let add2 = |x: i32| -&gt; i32 { x + 2 };  println!(&quot;add2(5) = {}&quot;, add2(5));  // 上面展示的类型推导有局限，比如 identity 函数  let id = |x| x;  println!(&quot;id(5) = {}&quot;, id(5));  // 正常输出 5  // 但下面这行会报错，因为从上面的 id(5) 推导出输入类型是 i32 ，不能是 bool  // 然而 id 函数应该是无论你输入什么类型的数据都能原封不动返回它  // println!(&quot;id(5) = {}&quot;, id(True));    // 正确实现 identity 函数，需要用到「泛型」  // 下面第 1 个 T 代表 T 是类型参数，它先会生成类似这样一个东西：  // T =&gt; fn id2(x: T) -&gt; T { return x; }  // 类型 T 作为输入，然后构造出一个具有类型标记的函数 id2  // 第 2 个 T 是输入参数 x 的类型；第 3 个 T 是函数 id2 的返回类型；  fn id2&lt;T&gt;(x: T) -&gt; T { x }  println!(&quot;id2(5) = {}&quot;, id2(5));  println!(&quot;id2(true) = {}&quot;, id2(true));  // curried functions: x =&gt; y =&gt; x + y  // 这里需要用到关键词 move 才能让 y 取到 3 这个操作数，这和 Rust 的内存管理有关  // Rust 制造了这些麻烦设计，是为了能够不用垃圾回收（Garbage Collection）这一语言特性  println!(&quot;(|x| (move |y| x + y))(2)(3) = {}&quot;, (|x| (move |y| x + y))(2)(3));  // 条件分支  let x = 3;  if x &lt; 5 {    println!(&quot;condition was true&quot;);  } else {    println!(&quot;condition was false&quot;);  }  fn fib(n: u64) -&gt; u64  {    if (n == 0)    {      return 0;    }    else if n == 1    {      return 1;    }    else    {      return fib(n - 1) + fib(n - 2);    }  }  println!(&quot;fib(8) = {}&quot;, fib(8));  // while loop  let mut total = 0;  let mut x = 1;  while x &lt;= 10 {    total += x;    x += 1;   // Rust 没有 ++ 或 -- 操作，这是个正确的设计。好的语言里不应该有这种东西，可避免一些愚蠢的写法  }  println!(&quot;total = {}&quot;, total);  // for loop  let mut a = [2, 3, 5, 7, 11, 13, 17];  // a 的类型为 [i32; 7]  // 由于数组 a 的内容是 i32 整数  // 所以定义 type_test 变量会 copy 数组内容，而不会 move ，和 i32 一样  // 如果内容是 String 字符串，那 let type_test: [String; 7] = a; 就会 move 了  let type_test: [i32; 7] = a;             for x in a {    println!(&quot;array element: {}&quot;, x);  }  // range (like Python)  for x in 1..5 {    println!(&quot;range 1..5: {x}&quot;);  }  for x in 1..=5 {    println!(&quot;range 1..5: {x}&quot;);  }  // reverse range  for x in (1..5).rev() {    println!(&quot;(1..5).rev() range: {x}&quot;);  }  // vector - 类似 Java 中的 ArrayList ，长度不固定，可添加数据（上面的数组长度固定不能添加）  // 变量 v 的类型是 Vec&lt;i32&gt;，且注意就算内容是 i32 ，也不能像上面的 a 变量那样默认 copy  // let type_test: Vec&lt;i32&gt; = v; 会发生 move  let mut v = vec![1, 2, 3, 4, 5];     // 这里如果不用 &amp;v 而采用 v ，虽然仍然能顺利输出，但会发生 move ，后续 v 变量就不能用了  for x in &amp;v {    println!(&quot;vector element: {x}&quot;);  }  // let x = &amp;v[3];   // can&#39;t borrow  let x = v[3];       // But can copy  v.push(6);  for x in &amp;v {    println!(&quot;changed vector element: {x}&quot;);  }  println!(&quot;v[3] = {}&quot;, x);  // for 循环中的 x 在循环结束后就没了，这里的 x 是上面的 let x = v[3];  // access by index - 下标访问  println!(&quot;v[2] = {}&quot;, v[2]);  // 标记类型的 vector  let mut v2: Vec&lt;String&gt; = vec![&quot;a&quot;.to_string(), &quot;b&quot;.to_string(), &quot;c&quot;.to_string()];  // let x = v2[1];  // 这样写会报错；和 Rust 内存管理有关 - cannot move out of index of `Vec&lt;String&gt;`  let x = &amp;v2[1];    println!(&quot;Vec&lt;String&gt; v2[1] = {}&quot;, x);  // hash map - 数据结构，属于库函数，所以先要用 use 来加载一下，相当于 Java 的 import  println!(&quot;----- hash map -----&quot;);  use std::collections::HashMap;  // 注意这里没有声明 table 类型  // Rust 会从后面的 table.insert(&quot;one&quot;, 1); 推导出 table 的类型  // table 的完整类型是 HashMap&lt;&amp;str, i32&gt;  // 为什么整数部分是 i32 而不是 i64 ？其实 Rust 编译器无法确切地知道是 i32 还是 i64  // Rust 编译器会根据上下文和已知的类型信息尝试找到最适合的类型，以满足所有 insert 的值的类型  // 下方 insert 的值 1 、2 、3 通常在 Rust 中默认为 i32 类型，所以这里是 i32  // 但是如果在其他部分的代码中，插入了 i64 类型的值，那么编译器则会认为是 HashMap&lt;&amp;str, i64&gt;  // 「类型推导」是错误的设计，会限制语言的表达，正确做法应该在定义的地方显式标记类型  let mut table = HashMap::new();    table.insert(&quot;one&quot;, 1);  table.insert(&quot;two&quot;, 2);  table.insert(&quot;three&quot;, 3);  // 可以通过 key 访问 table 的值  println!(&quot;table[\&quot;one\&quot;] = {}&quot;, table[&quot;one&quot;]);  // 但如果 key 来访问的值不存在，程序会报错中断  // println!(&quot;table[\&quot;four\&quot;] = {}&quot;, table[&quot;four&quot;]);  // 所以更合理的方式是调用 get 函数配合 {:?} 来尝试取值，这样程序不会中断  println!(&quot;table[\&quot;four\&quot;] = {:?}&quot;, table.get(&quot;four&quot;));         // table[&quot;four&quot;] = None  // get 函数返回的是一个 option type 类型的值，比如这里的 Some(2)  // 这里的 option 类型表示为 Option&lt;&amp;{integer}&gt; ，意思是「有可能是 integer 或者 None（没有）」  // Rust 用这个 option 设计避免了 null pointer exception 之类的问题  // Rust 是不会出现 null pointer exception 的  println!(&quot;table[\&quot;two\&quot;] = {:?}&quot;, table.get(&quot;two&quot;));           // table[&quot;two&quot;] = Some(2)  // Tips: 直接打印 None 会报错  // println!(&quot;None: {:?}&quot;, None);   // 需要添加类型 T 即 None::&lt;T&gt; 才能顺利打印出 None: None  // 这说明 table.get(&quot;four&quot;) 得到的 None 其实是 None::&lt;i32&gt; ，编译器类型推导出了这个 T  println!(&quot;None: {:?}&quot;, None::&lt;i32&gt;);    // 处理这种 option 类型可以用 match ，对不同的取值进行不同的操作  match table.get(&quot;three&quot;)   {    Some(value) =&gt; println!(&quot;value: {}&quot;, value),   // value 在这里直接被取出    None =&gt; println!(&quot;one: not found&quot;),  }  // match 是一种程序语言里通用的构造，有点像 if 的那个分支的构造   // struct - 结构体，类似面向对象里的「对象」  struct User {    username: String,    email: String,    active: bool,  }  // struct instance  let mut user1 = User {    username: String::from(&quot;user1&quot;),    email: String::from(&quot;user1@example.com&quot;),    active: true,  };  // field access - 访问成员  println!(&quot;user1: username = {}, email = {}&quot;, user1.username, user1.email);  // field mutation - 对成员赋值  user1.email = String::from(&quot;other1@example.com&quot;);  println!(&quot;changed user1: username = {}, email = {}&quot;, user1.username, user1.email);  // struct constructor - 构造函数来创建 struct instance  fn build_user(email: String, username: String) -&gt; User   {    User {  // 注意这里没有写 return ，Rust 会自动隐式返回最后一个表达式的值            // 除非表达式有分号或者没有表达式。表达式末尾有分号就要显示地写 return        // 在 Rust 语法里，这里可以就只写 username 和 email，值也能正确对应        // 但这样并不好，还是写 username: username 这样看起来更直观逻辑更清楚        // 少打几个字，增加逻辑思考的负担，是不明智的        // username,           // email,        // active: true,        username: username,           email: email,        active: true,    }  // 这里不能加分号，否则函数 build_user 无法隐式返回，只能写 return  }  let user2 = build_user(String::from(&quot;user2@example.com&quot;), String::from(&quot;user2&quot;));  println!(&quot;user2: username = {}, email = {}&quot;, user2.username, user2.email);  // 一种可能可以提供方便的构造语法  // user3 和 user1 只有 email 的值不同，其他都相同，就可以通过这种方法构造 user3  let user3 = User {    email: String::from(&quot;user3@example.com&quot;),    ..user1  };  println!(&quot;user3 (created from user1): username = {}, email = {}&quot;, user3.username, user3.email);  // tuple struct  // 和上面的 struct 区别在于，tuple struct 的成员是没有名字的，要靠位置（下标）来访问  // tuple struct 一般用于最简单的构造，比如后续的 enum 会用到。日常还是用上面那种有成员名字的 struct  struct Color(i32, i32, i32);  struct Point(i32, i32, i32);  let black = Color(1, 2, 3);  let origin = Point(2, 3, 5);  println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2);  println!(&quot;origin = ({}, {}, {})&quot;, origin.0, origin.1, origin.2);  // Unit-like struct  // 这种 struct 内部没有数据，它就是它自己而已  #[derive(Debug)]  // 给 AlwaysEqual 自动实现 Debug trait ，以便能够用 {:?} 格式化符号打印它的信息  struct AlwaysEqual;  let a = AlwaysEqual;  println!(&quot;a = {:?}&quot;, a);  // {} 和 {:?} 是 println! 两种常用的格式化符号  // {} 是默认的显示格式，用于打印实现了 Display trait 的类型，类似 .to_string() 函数  // {:?} 是调试输出格式，用于打印实现了 Debug trait 的类型，旨在提供详细输出，包含类型的更多内部细节  // 使用 #[derive(Debug)] 可以方便地实现 Debug trait ，所以类型的调试输出一般用这个  // #[derive(Debug)] 需要直接应用于每个需要它的结构体或枚举上。它不是全局性的，不能应用一次就影响整个模块或包  // 这意味着每个想用 {:?} 格式化输出的类型都要单独写一次 #[derive(Debug)]  // 注意这个 derive 只能用于 struct ，enum 和 union  // methods - Struct 的方法是定义在外面的  // 这里给 Point 这个 struct 添加（定义）方法  // 关键词 impl 表示 implementation  impl Point  {    // 注意，函数（方法）的第一个参数是 self（参数名只能是 self 不能是 this 或其他），它的类型是 &amp;Self    // 第一个参数 self: &amp;Self 也可以简写为 &amp;self ，可省略额外的类型标记    fn distance(self: &amp;Self, other: &amp;Point) -&gt; f64    {      let dx = self.0 - other.0;      let dy = self.1 - other.1;      let dz = self.2 - other.2;      ((dx * dx + dy * dy + dz * dz) as f64).sqrt()    }  }  let p1 = Point(1, 2, 3);  let p2 = Point(4, 5, 6);  println!(&quot;distance between p1 and p2 = {}&quot;, p1.distance(&amp;p2));  // enum (like abstract class in OOP, sum type in FP) -  枚举，类似 Java 中的 abstract class  // 这里定义了一个 Mybool 类型，它包含 2 个子类型 MyTrue 和 MyFalse  enum MyBool  {    MyTrue,    // Unit-like struct    MyFalse  }  let x = MyBool::MyTrue;  match x  {    MyBool::MyTrue =&gt; println!(&quot;x is true&quot;),    MyBool::MyFalse =&gt; println!(&quot;x is false&quot;)  }  println!(&quot;----- lists -----&quot;);  // // 用 enum 定义链表：  // // 注意这里用了泛型：可理解为类型 T 作为参数的一种类型函数  // // 这样不同类型就能通过 T 被传入进而得到内容类型不同的 List  // // 类似 List：T =&gt; enum List { Pair(T, List), Nil}  // // 这里意思是：List&lt;T&gt; 要么是空链表 Nil ，要么是一个 Pair 装了一个 T 类型的数据和另一个链表 List&lt;T&gt;  // // 但类似 Pair(T, List&lt;T&gt;) 这样的写法在 Rust 里是不行的，因为这里涉及了递归  // // Rust 的内存管理不知道要为递归分配多少内存空间，所以会报错  // enum List&lt;T&gt;  // {  //   Pair(T, List&lt;T&gt;),  //   Nil  // }  // 在 Rust 里，递归的部分要放在一个 Box&lt;...&gt; 里，即 Box&lt;List&lt;T&gt;&gt; ，才能正确运行  // 这个 Box 相当于其他语言里的「指针」，它的大小是固定的  // 所以这里放进去的是 T 类型的数据，和一个指向另一个 List&lt;T&gt; 的指针  // 于是 Rust 就能确定它的空间大小，从而顺利分配内存 - Rust 是系统语言，必须要知道每个东西占多少空间  enum List&lt;T&gt;  {    Pair(T, Box&lt;List&lt;T&gt;&gt;),    Nil  }  // length 函数，计算输入链表的长度  fn length&lt;T&gt;(ls: &amp;List&lt;T&gt;) -&gt; usize  {    match ls    {      List::Pair(_, tail) =&gt; 1 + length(tail),      List::Nil =&gt; 0,    }  }  let ls1 = List::Pair(1, Box::new(List::Pair(2, Box::new(List::Pair(3, Box::new(List::Nil))))));  println!(&quot;list length = {}&quot;, length(&amp;ls1));  // sum 函数，计算输入链表所有成员的和  fn sum(ls: &amp;List&lt;i32&gt;) -&gt; i32  {    match ls    {      List::Pair(head, tail) =&gt; head + sum(tail),      List::Nil =&gt; 0,    }  }  println!(&quot;list sum = {}&quot;, sum(&amp;ls1));  println!(&quot;----- calculator -----&quot;);  // enum for arithmetic expressions - 用 enum 来构造算术表达式  // 算术表达式 exp 要么是一个 Lit 要么是一个 Binop  // 同样地，递归的部分放进 Box 里  enum Exp  {    Lit(i32),    // tuple struct    Binop(char, Box&lt;Exp&gt;, Box&lt;Exp&gt;)  }  // calculator  fn calc(exp: Exp) -&gt; i32  {    match exp    {      Exp::Lit(n) =&gt; n,      Exp::Binop(op, e1, e2) =&gt;      {        // * 代表 dereferencing ，即读取“引用”对应的值        // 顺便说一下 &amp; 符号用于创建“引用”，而 * 符号用于“解引用”，获取其所指向的值        // 注意，我把所有的「引用」和「指针」都打了引号，代表 Rust 的引用和 C 语言、C++ 的引用（指针）概念不一样        // &amp; 和 * 只能暂时近似理解为「创建引用」和「解引用」的效果，不能认为是等同的概念        // 之后会有例子暴露 Rust 的问题：&amp;&amp;String 和 &amp;String 的类型是否一样        // 准确的理解应该抛弃 C 语言的指针思维，进一步还得查看 Rust 官方文档关于 ownership 的说明        // https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html        // 由于这里的 e1 和 e2 都是 Box&lt;Exp&gt; ，上面提到 Box 其实是“指针”，所以要通过 * 把对应的值取出来        let v1 = calc(*e1);          let v2 = calc(*e2);        match op        {          &#39;+&#39; =&gt; v1 + v2,          &#39;-&#39; =&gt; v1 - v2,          &#39;*&#39; =&gt; v1 * v2,          &#39;/&#39; =&gt; v1 / v2,          _ =&gt; panic!(&quot;Unknown operator&quot;)        }      }    }  }  let exp1 = Exp::Binop(&#39;*&#39;, Box::new(Exp::Lit(2)), Box::new(Exp::Lit(3)));  println!(&quot;2 * 3 = {}&quot;, calc(exp1));  let exp2 = Exp::Binop(&#39;+&#39;, Box::new(Exp::Lit(1)), Box::new(Exp::Binop(&#39;*&#39;, Box::new(Exp::Lit(2)), Box::new(Exp::Lit(3)))));  println!(&quot;1 + 2 * 3 = {}&quot;, calc(exp2));  // 下面是另一个版本的计算器 calc2  // 主要区别在于表达式的定义。  // 上面的表达式 Exp 是 tuple struct ，里面的成员没有名字  // 而下面的 NamedExp 则是常见的 struct ，里面的成员是有名字的  // 推荐写法还是下面这种有名字的 struct ，也就是 NamedExp  // 注意两者的括号类型也有区别  // 可以具体观察对比 exp1 和 exp3 的定义内容  // with named fields  enum NamedExp  {    Lit { n: i32 },    Binop { op: char, e1: Box&lt;NamedExp&gt;, e2: Box&lt;NamedExp&gt; }  }  fn calc2(exp: NamedExp) -&gt; i32  {    match exp    {      NamedExp::Lit { n } =&gt; n,      // free ordering of fields      NamedExp::Binop { e1, e2, op }=&gt;      {        let v1 = calc2(*e1);        let v2 = calc2(*e2);        match op        {          &#39;+&#39; =&gt; v1 + v2,          &#39;-&#39; =&gt; v1 - v2,          &#39;*&#39; =&gt; v1 * v2,          &#39;/&#39; =&gt; v1 / v2,          _ =&gt; panic!(&quot;Unknown operator&quot;)        }      }    }  }  let exp3 = NamedExp::Binop { op: &#39;*&#39;, e1: Box::new(NamedExp::Lit { n: 2 }), e2: Box::new(NamedExp::Lit { n: 3 }) };  println!(&quot;2 * 3 = {}&quot;, calc2(exp3));  // option types (already defined in Rust standard library)  // enum Option&lt;T&gt; {  //   Some(T),  //   None,  // }  // 前面提到的 Option 类型其实也就是一个 enum ，这里我们自己定义一个 MyOption 感受一下  enum MyOption&lt;T&gt; {    Some(T),    None,  }  let x: MyOption&lt;i32&gt; = MyOption::Some(5);  let y: MyOption&lt;i32&gt; = MyOption::None;  println!(&quot;----- MyOption -----&quot;);  match x {    MyOption::Some(n) =&gt; println!(&quot;x = {}&quot;, n),    MyOption::None =&gt; println!(&quot;x is None&quot;),  }  match y {    MyOption::Some(n) =&gt; println!(&quot;y = {}&quot;, n),    MyOption::None =&gt; println!(&quot;y is None&quot;),  }}</code></pre><hr><h3 id="Rust-的内存管理"><a href="#Rust-的内存管理" class="headerlink" title="Rust 的内存管理"></a>Rust 的内存管理</h3><p><strong>Rust</strong> 最重要的功能就是「<strong>内存管理</strong>」。它和其他语言（比如 <strong>Java</strong>）不一样。因为它没有<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">垃圾回收(GC)</a> 。它是靠编译器的静态检查来实现内存管理的。<strong>Rust</strong> 可以静态地保证大部分的内存不会出问题。</p><p><strong>Rust</strong> 的内存管理导致有很多代码写法上的限制，使得 <strong>Rust</strong> 写一些复杂的代码会有点痛苦。这就是为啥这个语言<strong>很</strong>不适合作为初学者的第一门语言。因为太多这个内存管理的东西夹在里面。你就没法思考你的那些逻辑。写一个链表都要想想 <code>Box</code> 。</p><p>总的来说，核心思路有 3 个：</p><ul><li><p>拥有数据所有权 <strong>ownership</strong> 的变量，才能确保数据不会随便失效；borrow 来的数据，别人失效了，你就失效了</p></li><li><p><code>move</code> 转移 <strong>ownership</strong> 会让原变量失效，<code>borrow</code> 不会，要思考是否希望（允许）原变量失效</p></li><li><p>要注意什么情况下会 <code>move</code> ，什么情况下只是 <code>borrow</code> ，以及这两种情况下数据如何读取、如何修改</p></li></ul><pre><code class="lang-Rust">  // ......  // ...... 下面这些代码是接着上文的代码写在 main 函数的函数体里的  // ......  // ---------------------------- Ownership ----------------------------  println!(&quot;--------------- Ownership ---------------&quot;);  let x = 5;  let y = x;  // copy (because i32 is Copy)  println!(&quot;x: {}, y: {}&quot;, x, y);  // Example 1: String  let s1 = String::from(&quot;hello&quot;);  let s2 = s1;                     // move - move 之后变量 s1 就失效了  println!(&quot;s2: {}&quot;, s2);  // error: value borrowed here after move  // println!(&quot;s1: {}&quot;, s1);  // Rust 里的传递基本都是 move ，只有专门标记 &amp; 才是 borrow  // 函数调用的操作数也是发生 move ，例如  f(s2) 后，s2 就失效了（下文有描述）  // 因为你把值传递给函数的参数，本质和变量定义没有差别  // clone  println!(&quot;----- clone -----&quot;);  let s1 = String::from(&quot;hello&quot;);  let s2 = s1.clone();  println!(&quot;s1: {}&quot;, s1);  println!(&quot;s2: {}&quot;, s2);  // borrow  println!(&quot;----- borrow -----&quot;);  let s1 = String::from(&quot;hello&quot;);  let s2 = &amp;s1;  println!(&quot;s1: {}&quot;, s1);  println!(&quot;s2: {}&quot;, s2);  // function that takes ownership  fn take_ownership(s: String)  {    println!(&quot;take_ownership: {}&quot;, s);  }  let s = String::from(&quot;hello&quot;);  take_ownership(s);  // error: value borrowed here after move  // println!(&quot;s: {}&quot;, s);  // function that gives ownership  fn give_ownership() -&gt; String  {    let s = String::from(&quot;hello&quot;);    println!(&quot;give_ownership: {}&quot;, s);    return s;  }  let s = give_ownership();  println!(&quot;s: {}&quot;, s);  fn take_and_give_back(s: String) -&gt; String  {    println!(&quot;take_and_give_back: {}&quot;, s);    return s;  }  let s = String::from(&quot;hello&quot;);  let s1 = take_and_give_back(s);  println!(&quot;s1: {}&quot;, s1);  // borrow of moved value: `s`  // println!(&quot;s: {}&quot;, s);  // function that borrows  fn borrow(s: &amp;String)  {    println!(&quot;borrow: {}&quot;, s);  }  let s = String::from(&quot;hello&quot;);  borrow(&amp;s);  println!(&quot;s: {}&quot;, s);  // mutable borrow  fn mutate(s: &amp;mut String)  {    s.push_str(&quot;, world&quot;);  }  let mut s = String::from(&quot;hello&quot;);  mutate(&amp;mut s);  println!(&quot;after mutatable borrow, s: {}&quot;, s);  // only one mutable borrow is allowed  // let s1 = &amp;mut s;  // let s2 = &amp;mut s;  // println!(&quot;s1: {}, s2: {}&quot;, s1, s2);  // cannot borrow `s` as mutable more than once at a time  let s1 = &amp;mut s;  println!(&quot;s1: {}&quot;, s1);  // can borrow because s1 is no longer used later  let s2 = &amp;mut s;  println!(&quot;s2: {}&quot;, s2);  // println!(&quot;s1: {}&quot;, s1);  // can&#39;t have immutable and mutable borrows at the same time  // let s1 = &amp;s;  // let s2 = &amp;mut s;  // println!(&quot;s1: {}, s2: {}&quot;, s1, s2);  // fn dangle() -&gt; &amp;String {  //   let s = String::from(&quot;hello&quot;);  //   return &amp;s;  // }  // string slice is borrowed reference  let s = String::from(&quot;hello&quot;);  let slice1 = &amp;s[0..2];  // will not compile with this line  // let s1 = s;  println!(&quot;slice1: {}&quot;, slice1);  // Generics  println!(&quot;----- Generics -----&quot;);  // revisit id function  fn id3&lt;T&gt;(x: T) -&gt; T { x }  println!(&quot;id3(5) = {}&quot;, id3(5));  println!(&quot;id3(true) = {}&quot;, id3(true));  // Two arguments must be the same time  fn second1&lt;T&gt;(x: T, y: T) -&gt; T  {    return y;  }  println!(&quot;second1(1, 2) = {}&quot;, second1(1, 2));  println!(&quot;second1(true, false) = {}&quot;, second1(true, false));  // error: mismatched types  // println!(&quot;second1(1, true) = {}&quot;, second1(1, true));  // Two arguments can be different types  fn second2&lt;T, U&gt;(x: T, y: U) -&gt; U  {    return y;    // Change to return x will not compile    // return x;  }  println!(&quot;second2(1, 2) = {}&quot;, second2(1, 2));  println!(&quot;second2(true, false) = {}&quot;, second2(true, false));  println!(&quot;second2(1, true) = {}&quot;, second2(1, true));  // Lifetime (very similar to generics)  // Lifetime is a way to specify relationship between references  println!(&quot;----- Lifetime -----&quot;);  // Won&#39;t compile without lifetime specifier (why?)  // fn second_string1(s1: &amp;String, s2: &amp;String) -&gt; &amp;String  // {  //   return s2;  // }  // broad lifetime (not knowing exact which one is returned)  fn second_string2&lt;&#39;a&gt;(s1: &amp;&#39;a String, s2: &amp;&#39;a String) -&gt; &amp;&#39;a String  {    return s2;  }  let s1 = String::from(&quot;s1&quot;);  let s2 = String::from(&quot;s2&quot;);  let s3 = second_string2(&amp;s1, &amp;s2);  // s1 moved here, but compiler doesn&#39;t know s3 is not referring to s1  // compiler thinks s3 could refer to both s1 and s2  // let s4 = s1;  println!(&quot;s3: {}&quot;, s3);  // This one works because we know s3 refers to s2, not s1  fn second_string3&lt;&#39;a,&#39;b&gt;(s1: &amp;&#39;a String, s2: &amp;&#39;b String) -&gt; &amp;&#39;b String  {    return s2;    // Change to return s1 will not compile    // return s1;  }  let s1 = String::from(&quot;s1&quot;);  let s2 = String::from(&quot;s2&quot;);  let s3 = second_string3(&amp;s1, &amp;s2);  // s1 moved here, but compiler konws know s3 is not referring to s1  let s4 = s1;  println!(&quot;s3: {}&quot;, s3);  // We don&#39;t know which is longer string  // so lifetime of returned reference could be either of s1 or s2  fn longer_string&lt;&#39;a&gt;(s1: &amp;&#39;a String, s2: &amp;&#39;a String) -&gt; &amp;&#39;a String  {    if s1.len() &gt; s2.len()    {      return s1;    }    else    {      return s2;    }  }  let s1 = String::from(&quot;hello&quot;);  let s2 = String::from(&quot;world!&quot;);  let s3 = longer_string(&amp;s1, &amp;s2);  // s1 moved here, and compiler knows s3 could refer to s1 or s2  // so uncommenting either of the following lines will not compile  // let s4 = s1;  // let s4 = s2;  println!(&quot;longer string: {}&quot;, s3);  // Lifetime in struct  println!(&quot;----- Lifetime in struct -----&quot;);  // Error: missing lifetime specifier  // struct Person {  //   name: &amp;String,  //   email: &amp;String  // }  // Struct 里标记 lifetime 是 Rust 复杂多余的设计  // 这意味着这个 Struct 只能临时用一下  // 一旦出了 name1 和 email1 的作用域，p1 就用不了了  // 正常的 Struct 都应该是内部成员的 owner 而不是 borrow  // 这和函数参数的 lifetime 是不一样的  // GitHub 上的 Rust 项目，只有【极少数】的 Struct 里存在这种 reference  // 所以建议 struct 的成员不使用 &amp; ，即不使用 reference 这样的引用成员  struct Person&lt;&#39;a&gt; {    name: &amp;&#39;a String,    email: &amp;&#39;a String  }  let name1 = String::from(&quot;name1&quot;);  let email1 = String::from(&quot;email1&quot;);  let p1 = Person { name: &amp;name1, email: &amp;email1 };  // name1 moved here, compiler knows p1 contains reference to name1 and email1  // so uncommenting either of following lines will not compile  // let name2 = name1;  // let email2 = email1;  println!(&quot;p1: name = {}, email = {}&quot;, p1.name, p1.email);  // Lifetime of hashmaps  println!(&quot;----- Lifetime of hashmaps -----&quot;);  let mut table = HashMap::new();        // 这里 HashMap 的类型应为 HashMap&lt;String, String&gt;  // 但 Rust 是通过下面的 table.insert(key1, value1); 推导出这个类型的  // 这是个错误的设计，不应该从调用的地方反推 HashMap 类型，应该在定义的时候就写清楚  // 逻辑上，类型标记本来就是要检查后续数据是否正确使用，而现在却要从后续数据的使用推导，万一后续数据用错了呢？  // 此外，定义的时候不写类型，就要用人脑来推导一下才能理解代码，大大降低了代码可读性，增加理解难度  let key1 = &quot;key1&quot;.to_string();  let value1 = &quot;value1&quot;.to_string();  table.insert(key1, value1);  // Can no longer use key1 and value1  // println!(&quot;key1: {}&quot;, key1);  // println!(&quot;value1: {}&quot;, value1);  // boxes  println!(&quot;----- boxes -----&quot;);  let x = 5;  let y = Box::new(5);    // Box 相当于指针，Box::new(5) 效果相当于创造一个指向 5 的指针：&amp;5  // let y = &amp;x;          // also work  println!(&quot;y: {}&quot;, y);  // 被 box 封装的数据无法在其他位置被更改，只能在所有权变量处更改，无法从其他变量访问更改  // 因为如果从其他变量修改，那原始变量就会失效  // box 独占封装的数据，不能像 Rc 引用计数那样共享数据，比如 2 个 box 实现的 list 无法共享其中部分数据  // 比如 box 实现的 ls1 中一部分是 ls2 ，则 ls2 会发生 move 转移 ownership ，这将使 ls2 变量失效不可用  // assert_eq! 接受两个参数（表达式），比较它们是否相等。若不相等，程序将 panic，并显示两个不匹配值的信息  // 主要用于测试中，确保代码在开发和维护过程中符合预期行为  assert_eq!(5, x);  assert_eq!(5, *y);  // Box 会转移所有权（ownership） ，即 move 操作  // 下面 Box::new(s) 使得 s 的所有权转移给了 Box ，b 这个 Box 是 &quot;hello&quot; 的新 owner  // 所以下一行 move s 给 s1 的操作就会报错  // 后续的 Rc (Reference Counted) 也是同样的这个行为，Rc::new(x) 也会拥有 x 的数据  let s = String::from(&quot;hello&quot;);  let b = Box::new(s);  // let s1 = s;  // error: use of moved value: `s`  // Define smart pointer - 可以认为 Box 和 Rc 都是 Smart Pointer 和 C++ 的原理一样  // 提示：MyBox 是上文提到的 tuple struct ，里面只存有一个数据，通过下标来访问，如 mb.0  struct MyBox&lt;T&gt;(T);  impl&lt;T&gt; MyBox&lt;T&gt; {      fn new(x: T) -&gt; MyBox&lt;T&gt; {          MyBox(x)      }  }  let x = String::from(&quot;hello&quot;);  let y = MyBox::new(x);      // 这行把 x 数据 move 给了一个 MyBox ，然后这个 MyBox 的 owner 则是 y  // let z = x;               // error: use of moved value: x  // 使用 C++ 的代码里的 unique_ptr 可以实现同样的效果  // 不过 C++ 中要明确写出是在 move ，即 move(x) ，而 Rust 中默认就是 move 操作  // unique_ptr&lt;string&gt; x = make_unique&lt;string&gt;(&quot;hello&quot;);  // unique_ptr&lt;string&gt; z = move(x);  let x = 5;  let y = MyBox::new(x);  // let z = MyBox(x);    // also work  // 直接使用 MyBox(x) 构造实例的方式直接通过类型的构造器初始化，适用于简单的包装或当不需要额外逻辑处理的情况。  // 这通常更简单，但功能上可能较为有限，主要用于简单地包装或转换类型。  // MyBox::new(x) 是一个更常见的构造函数模式，其中 new 是一个静态方法，用于创建并初始化类型的实例。  // 这种方式可以包含更复杂的初始化逻辑。如设置默认值、进行验证或其他必要的设置步骤。  use std::ops::Deref;  // Deref Trait - trait 相当于 Java 中 interface 的概念，即要求实现 interface 中规定的方法，如 get 和 add 等  impl&lt;T&gt; Deref for MyBox&lt;T&gt; {    type Target = T;   // 指定 Target 为 T 类型    // Self::Target 是 Deref trait 的一个关联类型，表示被解引用时得到的目标类型，即 self.0 的类型    // 所以，这里 deref 函数返回的 &amp;self.0 是 &amp;Self::Target 类型，&amp; 代表它是个引用的类型    fn deref(&amp;self) -&gt; &amp;Self::Target {        &amp;self.0    }    // C++ 中类似的 smart pointer 定义    // T&amp; operator * () const { *return m_ptr; }    // T* operator -&gt; () const { return m_ptr; }  }  // 当使用 * 符号的时候，其实就是在调用这个 deref 函数  // 所以 *y 相当于 y.deref() ，从上面的代码得知此时返回的是一个引用，即 &amp;self.0  // 然后 Rust 又会再自动地隐式解引用一次，于是得到嘞 self.0 ，也就是真正的值  assert_eq!(5, x);  assert_eq!(5, *y);  // equiv to *(y.deref()) , *y is &amp;i32 type  assert_eq!(5, *(y.deref()));  fn foo(x: &amp;i32) {    println!(&quot;x: {}&quot;, x);  }  foo(&amp;y);  // Drop trait  println!(&quot;----- Drop trait -----&quot;);  struct Pointer {    data: String,  }  // 这个 drop trait 相当于 C++ 里的 destructor  impl Drop for Pointer {    fn drop(&amp;mut self) {      // drop 出了作用域后就会打印这些信息作为 debug 信息，让人知道确实 drop 掉了      println!(&quot;Dropping Pointer with data `{}`!&quot;, self.data);    }  }  let a = Pointer {    data: String::from(&quot;a&quot;),  };  {    let b = Pointer {        data: String::from(&quot;b&quot;),    };  }  drop(a);  let c = Pointer {      data: String::from(&quot;c&quot;),  };  let d = Pointer {      data: String::from(&quot;d&quot;),  };  println!(&quot;Pointers created.&quot;);  // Rc (Reference Counted) - 引用计数  println!(&quot;----- Rc -----&quot;);  // shared list can&#39;t work with Box - Box 的链表实现无法共享数据  // let a = List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))));  // let b = List::Cons(5, Box::new(a));  // a moved here  // let c = List::Cons(8, Box::new(a));  // can&#39;t use a again  // Rc 的主要功能就是共享数据，也就是 Rc::clone 这个操作  // Rc::clone 不会复制数据，只会复制一个引用  // Rc::clone 的参数类型也必须是一个 Rc 类型  use std::rc::Rc;  enum List2 {    Cons(i32, Rc&lt;List2&gt;),    Nil,  }  let a = Rc::new(List2::Cons(2, Rc::new(List2::Cons(3, Rc::new(List2::Nil)))));  let b = Rc::new(List2::Cons(5, Rc::clone(&amp;a)));    // Rc::clone(arg) 接收的参数类型 arg 必须是一个 Rc 的引用：&amp;Rc&lt;_&gt;  let c = Rc::new(List2::Cons(8, Rc::clone(&amp;a)));    // 这里 a 是一个 Rc ，所以 &amp;a 就是一个 &amp;Rc&lt;_&gt;  println!(&quot;a&#39;s ref count: {}&quot;, Rc::strong_count(&amp;a));  // 查看变量 a 的引用次数  println!(&quot;b&#39;s ref count: {}&quot;, Rc::strong_count(&amp;b));  println!(&quot;c&#39;s ref count: {}&quot;, Rc::strong_count(&amp;c));  drop(b);  drop(c);  // 释放 b 和 c 之后，a 的引用次数减少  println!(&quot;a&#39;s ref count after dropping b, c: {}&quot;, Rc::strong_count(&amp;a));    // 虽然 Rc::clone 可以让我们在多个地方共享数据，但它并不提供数据的内部可变性  // 以下面这个 struct 为例，使用 Rc 之后，无法更改成员 name 的值  #[derive(Debug)]  struct TestRc  {    name: String,    age: i32,  }  let mut tr1 = TestRc   {    name: String::from(&quot;user1&quot;),    age: 19,  };  println!(&quot;original tr1: {:?}&quot;, tr1);  tr1.name = String::from(&quot;guest&quot;);   // 可更改 tr1 内部成员 name 的内容  println!(&quot;changed tr1: {:?}&quot;, tr1);  // 套上 Rc 封装之后，就无法更改 tr1 内部数据的内容了  // 注意这里 tr1 发生 move 了，tr1 失效，新 owner 是 Rc ，而 Rc 的 owner 是变量 rc_tr1  let rc_tr1 = Rc::new(tr1);  // rc_tr1.name = String::from(&quot;guest_2nd&quot;);   // cannot assign to data in an `Rc  // *rc_tr1.name = String::from(&quot;guest_3rd&quot;);  // mismatched types  // 如果希望用 Rc::clone 共享数据的同时，还能够改变变量内部数据，就要配合 RefCell 使用  // RefCell - 本质相当于 Reader-Writer Lock（读写锁）  // 可以有 2 个（多个）immutable 的 borrow（Reader）  // 但只能有 1 个 mutable 的 borrow（Writer）  println!(&quot;----- RefCell -----&quot;);  use std::cell::RefCell;  // Reader-Writer Lock（读写锁）是一种常用的同步机制，用来解决多个线程同时访问同一资源（如数据或文件）时的并发问题。  // 读写锁非常适合那些读操作远多于写操作的场景，因为它允许多个读线程同时访问资源，而写线程则需要独占访问。  // 与读写锁并列的还有互斥锁（mutex）等  let value = RefCell::new(42);  // 可修改的 mut_borrow 相当于 writer  // 如果一个 writer 把一个对象锁掉了，那所有的 reader 就都没法读取了  let mut mut_borrow = value.borrow_mut(); // 调用 .borrow_mut 函数，并加关键词 mut 来定义  println!(&quot;value: {}&quot;, *mut_borrow);  *mut_borrow = 9;                         // 改变指针（引用） mut_borrow 所指向的数据  println!(&quot;value: {}&quot;, *mut_borrow);  drop(mut_borrow);   // 释放 mut_borrow 后，下面才能调用 .borrow() ，因为读写锁不能同时读和写  // 不可修改的 imm_borrow 相当于 reader  // 同理，如果一个 reader 拿到了锁，那 writer 就拿不到这个锁（没法写入）  // 但是其他的 reader 也能拿到这个锁  let imm_borrow1 = value.borrow();  println!(&quot;value: {}&quot;, *imm_borrow1);  let imm_borrow2 = value.borrow();  println!(&quot;value: {}&quot;, *imm_borrow2);  // Rc 配合 RefCell 可以让我们既可以 Rc::clone 共享数据，又可以 .borrow_mut 来改变数据  // 这对复杂一点的数据结构来说是必要而实用的工具，比如解释器里的数据结构  // 不过新手也许还有个疑问：封装到底是谁包裹谁？是 Rc&lt;RefCell&lt;_&gt;&gt; 还是 RefCell&lt;Rc&lt;_&gt;&gt; ？  // 其实从上面 Rc 部分的例子就能知道，我们可以改动 tr1 ，但无法改动 Rc&lt;tr1&gt;  // 对于 RefCell&lt;Rc&gt; ，当我们调用 .borrow_mut() 之后，拿到的就是 Rc&lt;_&gt; ，而我们无法改动 Rc&lt;_&gt;  // 对于 Rc&lt;RefCell&lt;_&gt;&gt; ，调用 .borrow_mut() 后拿到的是数据，可以被更改  // 所以正确的封装顺序应该是 Rc&lt;RefCell&gt;  println!(&quot;----- Rc with RefCell -----&quot;);  let tr2 = TestRc     // 这里定义 tr2 不需要 mut  {    name: String::from(&quot;user2&quot;),    age: 17,  };  let tr2_rfrc = Rc::new(RefCell::new(tr2));  // tr2 发生 move 转移所有权，新 owner 是 RefCell  println!(&quot;tr2_rfrc: {:?}&quot;, tr2_rfrc.borrow());  // tr2_rfrc: TestRc { name: &quot;user2&quot;, age: 17 }  tr2_rfrc.borrow_mut().name = String::from(&quot;admin&quot;);  // 改变 name 成员（field）的值  println!(&quot;changed tr2_rfc: {:?}&quot;, tr2_rfrc.borrow());  // tr2_rfrc: TestRc { name: &quot;admin&quot;, age: 17 }  // 有了 RefCell 和 Rc，我们还可以造出一个「环」来：  // A -&gt; B -&gt; A（ A 指向 B ，B 又指向 A ）  // 这样内存就可能会泄露了，因为 Rc（Reference Counting）互相指来指去就不会为 0 了  // 这会使得内存就会无法释放，导致泄露（Memory Leak）  // 不过正常的垃圾回收机制可以正确地处理这类「循环引用」导致的问题  // reference cycles  println!(&quot;----- reference cycles -----&quot;);  struct Node {    value: i32,    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,  }  // 定义 node1 和 node2 两个被 Rc 和 RefCell 封装包裹的 Node  let node1 = Rc::new(RefCell::new(Node {      value: 1,      next: None,  }));  // 这里 Node2 的成员（field）next 通过 Rc::clone 指向了 node1  let node2 = Rc::new(RefCell::new(Node {      value: 2,      next: Some(Rc::clone(&amp;node1)),  }));  // 由于有 RefCell ，所以可以使用 borrow_mut  // 这里 borrow_mut 取得一个指向 node1 数据且可以改变这些数据的东西  // 然后 .next = Some(Rc::clone(&amp;node2)) 让 node1 中本来为 None 的值换成了 Node2  // 这样 node1 和 node2 就相互指向了  // creating cycle  node1.borrow_mut().next = Some(Rc::clone(&amp;node2));  // node2 也可以指向自己  node2.borrow_mut().next = Some(Rc::clone(&amp;node2));} // &lt;--- 这个是 main 函数的花括号</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上手 Java</title>
      <link href="/2024/03/23/java-basics/"/>
      <url>/2024/03/23/java-basics/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.java.com" target="_blank" rel="noopener">Java</a> 是一门非常成熟的工业级静态类型语言。对于新手来说，它是<strong>体验</strong>了解「静态类型系统」的绝佳语言之一。</p><p>所谓<a href="https://en.wikipedia.org/wiki/Type_system" target="_blank" rel="noopener"><strong>静态类型</strong></a>，就是对程序中各数据的类型进行<strong>严格规范</strong>的一种语言特性。比如在 <strong>Java</strong> 中，<strong>所有</strong>变量在定义的时候都需要声明标记它的数据类型。这会让代码看起来有点“啰嗦”，不够简洁。但好处是，代码可以无需运行就能通过类型不匹配提前发现问题，保证代码可靠性（静态类型检查）。此外，标记类型也让编译后的程序不用每次都询问一下数据的类型而减小了计算开销，提高程序性能。比如 <strong>Java</strong> 比非编译执行的语言 <strong>Python</strong> 就快 30 多倍。</p><p>静态类型的语言也使得 IDE（集成开发环境，比如下文介绍的 IntelliJ IDEA）能更好地支持它，比如可以实现精准的<strong>语义跳转</strong>和<strong>重构</strong>（比如可靠的变量换名）等操作。</p><p>通过 <strong>Java</strong> 还可以体验面向对象（<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">OOP</a>）的设计精髓：面向对象主要不在于节省代码、重用代码——这些其他非面向对象语言也能做到——而在于<strong>表达各种类型之间的关系</strong>（其实就是数学上集合的包含关系）。</p><blockquote><p>它本来这种类型它不是这种集合的包含关系，他还去继承一下。就因为他能省…少打一点代码。结果后来就越弄越复杂。看不懂了。</p><footer><strong>Ian</strong></footer></blockquote><p>还有就是面向对象的设计把各种函数以它的方式整理起来（使用类似 <code>object.method</code> 这样的方式访问），让函数更有“组织性”：</p><ul><li>都是访问 <code>e1</code> 的内容，对比 <code>binopE1(exp)</code> 和 <code>binop.e1</code> 这两种表达方式，后者阅读上会更加直观一点</li></ul><hr><h3 id="Java-编程环境"><a href="#Java-编程环境" class="headerlink" title="Java 编程环境"></a>Java 编程环境</h3><p><a href="https://www.java.com" target="_blank" rel="noopener">Java</a> 是一个需要<strong>编译</strong>才能运行的语言，不像其他一些语言那样 <code>.py</code> <code>.js</code> 等文件写好了直接就能运行。在学习和开发的时候，最好能打开一个命令行窗口（Ternimal），进行相关操作才比较方便。</p><ul><li><p>安装 <strong>JDK</strong><br><a href="https://www.oracle.com/hk/java/technologies/downloads/#jdk22-mac" target="_blank" rel="noopener">JDK</a>（Java Development Kit）是用于开发 Java 应用程序的软件包，提供了运行 Java 代码所需的工具和库，比如编译器（javac）。通过 <a href="https://formulae.brew.sh/formula/openjdk" target="_blank" rel="noopener">Hombrew</a> 来安装。完成后就可以在终端命令行里使用 <code>java</code> 和 <code>javac</code> 了：</p><pre><code class="lang-bash">## 东西比较多，注意保持网络通畅$ brew install openjdk## brew install java## 安装的是由 Apple 或者 Apple 授权的 Java 版本，通常是 Oracle JDK## brew install openjdk ## 安装的是由 OpenJDK 项目提供的开源 Java 版本，与 Oracle JDK 功能上是兼容的## 不同的是 OpenJDK 是由社区维护的## 安装完成之后，应该要能用这个命令查看 Java 的版本$ java --versionopenjdk 21.0.2 2024-01-16OpenJDK Runtime Environment Homebrew (build 21.0.2)OpenJDK 64-Bit Server VM Homebrew (build 21.0.2, mixed mode, sharing)</code></pre><p><code>Tips：新手推荐在下文 IntelliJ IDEA 的 onboarding tour 教学过程中安装 JDK，省去各种复杂的配置</code></p></li><li><p>安装 <strong>IntelliJ IDEA</strong><br><a href="https://www.jetbrains.com/help/idea/creating-and-running-your-first-java-application.html" target="_blank" rel="noopener">IntelliJ IDEA</a> 是 <a href="https://www.jetbrains.com" target="_blank" rel="noopener">JetBrains</a> 公司推出的集成开发环境（IDE）。对 <strong>Java</strong> 编程来说，使用上比 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a> 更加方便一些。对于初学者，下载安装 <strong>IntelliJ IDEA Community Edition</strong> 这个<strong>免费的</strong>版本就够用了。</p><p><img src="IntelliJ.png" alt="Welcome to IntelliJ IDEA" style="width: 800px; height: auto;"></p><p>可以看到，<strong>IntelliJ IDEA</strong> 有极其友好的 onboarding 入门教程。点击 <strong>Start Tour in Java</strong> 试试吧。<br>这个 <strong>Quick onbording tour</strong> 的过程还可以根据提示，非常方便地安装 <strong>JDK</strong> 。</p></li></ul><hr><h3 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h3><p>先来简单地走一遍完整流程，了解一下整个 Java 编程作业的大体过程。</p><ul><li><p><strong>新建 <code>.java</code> 文件：</strong></p><pre><code class="lang-bash">  ## 打开 Terminal，进入到要进行编程的目录  $ cd ~/Documents/prog  ## 创建新的工作目录  $ mkdir lesson9  $ cd lesson9/  ## 在这个目录下建立一个 .java 文件  ## 注意这里文件名第一个字母要大写，因为后续文件里要写一个类 class Lesson9  $ touch Lesson9.java</code></pre><p>  对代码的分散管理是 Java 的特点。这也导致了 Java 编程的过程中会产生很多文件。所以通常会建立一个工作目录来进行作业。这里 <code>.java</code> 文件的名字是有命名规则要求的，这是 Java 语言的一个规范：</p><ol><li>若文件中有公共类 <code>public class</code> ，则文件名<strong>必须</strong>和该类的名字一样，一个文件<strong>只能有一个</strong>公共类；</li><li>若无公共类，则文件名无要求，但最好用易理解可维护的名字，如此处用代表性类的名字 <code>Lesson9</code>；</li></ol></li><li><p><strong>编辑上述文件写入 <code>Java</code> 代码：</strong></p><pre><code class="lang-Java">  // Lesson9.java   class Lesson9  {    public static void main(String[] args)    {      System.out.println(&quot;Magnifique！&quot;);    }  }</code></pre><p>  <strong>Lesson9.java</strong> 文件里定义了一个类 <code>Lesson9</code> 。类里则定义了一个函数 <code>main</code> 。该函数接收一个参数 <code>args</code> 。其中 <code>String[]</code> 标记了参数 <code>args</code> 的类型。它是一个存储字符串对象的<strong>数组类型</strong>。<code>void</code> 代表这个函数没有返回值，也可以认为该函数的返回类型是 <strong>void</strong> 。<strong>main</strong> 函数里是个打印语句，打印出字符串 <code>&quot;Magnifique&quot;</code>。</p><p>  <code>public</code> 表示 <strong>main</strong> 函数在 <strong>Lesson9</strong> 这个类的外面也可以被访问和调用。与之相对的是 <code>private</code> ，表示只能在类内部才能访问调用这个函数。如果两者都没有，那这个函数就有<strong>另外的作用范围</strong>。</p><p>  <code>static</code> 表示 <strong>main</strong> 是一个<strong>普通的函数</strong>（function），而不是类中的<strong>方法</strong>（method），它的调用方式是 <code>main(args)</code> 。如果没有 <code>static</code> 标记，它的调用方式就是 <code>(New Lesson9()).main(args)</code> 了。<br>  Java 默认所有的函数都是方法（method）。方法存在一个内部可用的参数是 <code>this</code> ，用 <code>static</code> 标记的普通函数则没有 <code>this</code> 这个参数。</p><p>  <code>public</code> 和 <code>static</code> 的位置可以互换。</p></li></ul><ul><li><p><strong>编译和运行：</strong><br>  <code>.java</code> 文件里的代码写好之后，需要先用 <code>javac</code> 命令将其编译成 <code>.class</code> 文件（字节码 bytecode）。然后再用 <code>java</code> 命令来运行编译好的 <code>.class</code> 文件。使用 <code>java</code> 命令运行的时候，只需写文件名就行，不用写 <strong>.class</strong> 这个后缀。<br>  比如下面的例子里，<code>java Lesson9</code> 就能运行。</p><pre><code class="lang-bash">  ## 切换回 Terminal  $ pwd  ~/Documents/prog/lesson9  ## 可以看到，当前目录下只有一个上面编辑好的文件  $ ls  Lesson9.java  ## 编译 .java 文件 - javac 这个命令代表 java compiler  $ javac Lesson9.java  ## 可以看到，当前目录下多了个 .class 文件  $ ls  Lesson9.class     Lesson9.java  ## 运行 .class 文件，打印出字符串 &quot;Magnifique！&quot;  $ java Lesson9  Magnifique！</code></pre><p>为什么要把编译和运行分开，而不是像解释器那样直接运行代码？因为直接运行会有很多重复的操作（主要是反复询问程序的结构和类型，比如问这是一个 if 吗？是的话就要计算 condition 表达式的值。编译之后就不用问，而是到这步直接计算 condition 的值）。如果先编译再运行，它会去掉很多重复的操作。这样代码就会快很多。这就是为啥一般这种工业化的语言它都会稍微编译一下。</p></li></ul><hr><h3 id="更顺手的-IntelliJ"><a href="#更顺手的-IntelliJ" class="headerlink" title="更顺手的 IntelliJ"></a>更顺手的 IntelliJ</h3><p>当需要频繁使用 Java 写些严肃点的东西时，上面的方式就不那么好用了。使用 <a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="noopener">IntelliJ IDEA</a> 编程会更加高效。跟着 IntelliJ 的 onboarding 入门教程走一遍就能很快上手，这里主要记录一下常用快捷键和技巧：</p><p><strong>快捷键：</strong></p><ul><li><strong>编译并运行</strong>代码：<code>control + R</code>（ MacOS 系统）；</li><li>快速<strong>排版</strong>（格式化）所有代码：<code>cmd + option + L</code>（ MacOS 系统）；</li><li><strong>注释/取消注释</strong>代码（选中后按）：<code>cmd + /</code>（ MacOS 系统）；</li><li>显示光标位置代码可能的改善操作（常用于处理 warning）：<code>option + Return</code>（ MacOS 系统）；</li><li>搜索（若有选中的内容，则它会自动进入搜索框）：连续按 <strong>2</strong> 次 <code>Shift</code> 键；</li></ul><p><strong>技巧：</strong></p><ul><li>设置缩进空格数：<code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>Code Style</code> -&gt; <code>Java</code> -&gt; <code>Tabs and Indents</code> -&gt; 设置 <code>Indents</code> 空格数；</li><li>设置 <strong>if-else</strong> 另起一行：<code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>Code Style</code> -&gt; <code>Java</code> -&gt; <code>Wrapping and Braces</code> -&gt; <code>&#39;if()&#39; statement</code> -&gt; 勾选 <code>&#39;else&#39; on new line</code>；</li><li>关闭类型、变量名等提示：<code>Preferences</code> -&gt; <code>Editor</code> -&gt; <code>Inlay Hints</code> -&gt; 取消勾选 <code>Code vision</code>、<code>Parameter names</code> 和 <code>Types</code>；</li><li><strong>Run with Coverage</strong> 功能可以检查测试代码的覆盖率</li></ul><hr><h3 id="Java-语言基本知识"><a href="#Java-语言基本知识" class="headerlink" title="Java 语言基本知识"></a>Java 语言基本知识</h3><ul><li><p>Java 的文件里要有一个 main 函数</p></li><li><p>语法上，若你的 if 里只有一行，可以不打花括号，但这不是一个好的做法。好一点的编程规则都要求打上花括号，哪怕只有一行。</p></li><li><p>Java 的类要用关键词 <code>new</code> ，这是一个好设计。比如 <code>new Dog()</code> 如果写成 <code>Dog()</code> ，就和普通函数混淆了。加一个 <code>new</code> 就能知道不是普通函数，而是一个类，或者某种构造函数。</p></li><li><p>如果你的值，它的实际的类型是这个变量标记类型的子类型，你就可以用这个父类的变量指向一个子类的对象：<code>Animal dog = new Dog();</code></p></li><li><p>为了通用，变量的类型一般都尽可能标记成上层的父类型（写高一点），这样后期更改实现就简单很多</p></li><li><p>在 Java 中，类的名称通常遵循一种命名约定，即类名的首字母应该大写。这是一种广泛接受的编程规范，被称为“大驼峰命名法”（PascalCase）。按照这个规范，类名的每个单词的首字母都要大写，而单词之间不使用下划线或其他分隔符。</p></li><li><p>虽然在 Java 中，类名的首字母一般应该大写，但从语法上讲，类名的首字母也可以小写。但是，强烈建议遵循命名约定，使用大写字母开头的类名，以便与变量名（小驼峰命名法）等其他命名约定区分开来，并且符合 Java 社区的编程习惯和规范。这样可以增加代码的可读性和可维护性，使代码更符合行业标准。</p></li><li><p>Java 里面，所有不是整数之类那种特别小的类型的，凡是你用 <code>new</code> 创建的那些对象——虽然你没有写那个指针的符号——它全都是指针。Java 里面几乎全都是 <strong><a href="https://www.ibm.com/docs/en/i/7.4?topic=calls-pass-by-reference" target="_blank" rel="noopener">Pass by Reference</a></strong> ，除了 <code>int</code> 之类的它拷贝了一下。</p></li></ul><hr><h3 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h3><ul><li><p>整数 - <strong>int</strong></p><pre><code class="lang-java">// TO DO</code></pre></li><li><p>浮点数 - <strong>float</strong><br>整数和浮点数在电脑里是有差别的，整数和浮点数混合计算会被转化为浮点数，结果也是浮点数</p><pre><code class="lang-java">// TO DO</code></pre></li><li><p>字符串 - <strong>string</strong><br>可以用单引号 <code>&#39;hello&#39;</code> ，也可以用双引号 <code>&quot;hello&quot;</code><br>一个常用的字符串方法：<a href="https://docs.python.org/3/library/stdtypes.html#str.split" target="_blank" rel="noopener"><code>str.split()</code></a></p><pre><code class="lang-java">// TO DO</code></pre></li><li><p>布尔类型 - <strong>bool</strong></p><pre><code class="lang-java">// TO DO</code></pre></li></ul><hr><h3 id="基本的数据结构"><a href="#基本的数据结构" class="headerlink" title="基本的数据结构"></a>基本的数据结构</h3><ul><li><p>列表 - <strong>List</strong></p><pre><code class="lang-java">// TO DO</code></pre></li></ul><hr><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><pre><code class="lang-java">// TO DO</code></pre><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="lang-java">// TO DO</code></pre><hr><h3 id="条件分支-if-语句"><a href="#条件分支-if-语句" class="headerlink" title="条件分支 - if 语句"></a>条件分支 - if 语句</h3><pre><code class="lang-java">static int fib(int n){  if (n == 0)  {    return 0;  }  else if (n == 1)  {    return 1;  }  else  {    return fib(n - 1) + fib(n - 2);  }}</code></pre><hr><h3 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 - Exception"></a>异常 - Exception</h3><pre><code class="lang-java">// // 运行时的 Exception（RuntimeException）表示类型系统不会检查它public T get(int index)  // 这行没写 throw IndexOutOfBoundsException ，因为这是运行时的 Exception{  if (index &gt;= size)  {    throw new IndexOutOfBoundsException(&quot;Input index: &quot; + index + &quot; is out of bound. &quot;);  }  else  {    return this.data[index];  }}</code></pre><p>RuntimeException 就是你无能为力的一些事情，所以不需要去 try-catch 它。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>针对 Scheme 的 Emacs 编程环境设置</title>
      <link href="/2022/05/16/emacs-setup/"/>
      <url>/2022/05/16/emacs-setup/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">GNU Emacs</a> 是开源社区中 <a href="https://www.gnu.org" target="_blank" rel="noopener">GNU</a> 操作系统的一款古老而嚣张的编辑器。软件的上手涉及一些麻烦的初始设置，对新手来说不算友好。但之所以要用它，主要是为了更好地用 <a href="https://schemers.org" target="_blank" rel="noopener">Scheme</a> 语言来编程。相比对于新手最友好的上手软件 <a href="https://racket-lang.org" target="_blank" rel="noopener">Racket</a> 来说，Emacs 可以通过设置，方便地（其实刚开始也没有特别方便）使用由 <strong>R. Kent Dybvig</strong> 设计的、当今性能和可靠性都最强的 <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 来运行我们的代码。</p><blockquote><p>I am the principal developer of the now open-source Chez Scheme, a highly reliable, highly efficient dynamic language and implementation.</p><footer><strong>R. Kent Dybvig</strong></footer></blockquote><p>本文内容将以 MacOS 系统为例进行讲解，其他系统的操作是类似的。</p><hr><h3 id="安装使用-Chez-Scheme"><a href="#安装使用-Chez-Scheme" class="headerlink" title="安装使用 Chez Scheme"></a>安装使用 Chez Scheme</h3><p><a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 的安装在<a href="https://github.com/cisco/ChezScheme/blob/main/BUILDING" target="_blank" rel="noopener">介绍页面</a>中的描述看似很复杂（对新手算是不友好的），实际则十分简单：</p><pre><code class="lang-bash">## 这里准备将 Chez Scheme 安装在 ~/apps 这个目录下## 打开终端 terminal 输入 cd 命令进入该目录（你也可以选择其他的目录安装）$ cd ~/apps## 运行 git clone 命令，将 Chez Scheme 下载到当前目录中## 内容大小 1.48 GB 左右，确保你的网络畅通，不然下载过程容易出错$ git clone git@github.com:cisco/ChezScheme.git## 下载完成后进入文件夹，准备运行安装命令$ cd ChezScheme/$ pwd               # pwd 会显示当前所在目录~/apps/ChezScheme## 如果你电脑的 CPU 是 x86_64 架构的，直接运行这个配置命令（程序）即可## 确保网络畅通，配置过程需要下载相关依赖库$ ./configure## 如果你的电脑是 Apple Silicon 的 Mac ，比如 CPU 是 M1 的 Mac## 那么就要在上面这个配置命令（程序）前面加上 arch -x86_64## 这是强制让 M1 Mac 的 arm 架构的 CPU 模拟 x86_64 架构来运行配置命令（程序）$ arch -x86_64 ./configure## 上面的配置命令成功结束后，就可以运行下面的命令进行安装了## 这个环节需要输入电脑的密码进行授权## Chez Scheme 自编译速度很快，整个过程不会超过 1 分钟（一般是 30 秒内）$ sudo make install## 安装完成后就能在终端中使用 scheme 命令来运行代码文件了（scheme 代码的文件名常用后缀是 .scm）## 运行（加载）文件后会进入 REPL 的交互解释器模式。测试完代码后，可以用 (exit) 退出$ scheme ~/Documents/prog/demo.scmChez Scheme Version 9.5.9Copyright 1984-2022 Cisco Systems, Inc.Hello World ! &gt; words&quot;Hello World&quot;&gt; punctuation&quot;!&quot;&gt; (+ 2 3)5&gt; (exit)      ## 调用函数 (exit) 退出 REPL 交互模式</code></pre><p>实际上，如果只是要用 <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 来运行我们的代码，完全可以<strong>只使用</strong>终端来运行。搭配你自己喜欢的编辑器来写代码即可，不一定非要用对新手不友好的 <a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a> 。比如我就用 <a href="https://racket-lang.org" target="_blank" rel="noopener">DrRacket</a> 作为主力编辑器写 Scheme 代码。有需要再在终端里用 <code>scheme</code> 命令运行。</p><pre><code class="lang-bash">## 注意，终端不像 DrRacket 那样会自动输出结果，## 如果要在代码文件中实现输出，得用 printf 函数## 可以看一下上文 demo.scm 文件中的代码内容$ cat ~/Documents/prog/demo.scm(define words &quot;Hello World&quot;)(define punctuation &quot;!&quot;)(printf &quot;~a ~a ~n&quot; words punctuation)</code></pre><hr><h3 id="Emacs-安装"><a href="#Emacs-安装" class="headerlink" title="Emacs 安装"></a>Emacs 安装</h3><p>Emacs 的安装<strong>并不难</strong>，从<a href="https://emacsformacosx.com" target="_blank" rel="noopener">官网</a>下载 <code>.dmg</code> 文件到本地正常安装即可。它对于新手的<strong>主要障碍</strong>在于后续的配置和软件的使用。</p><hr><h3 id="开始使用-Emacs"><a href="#开始使用-Emacs" class="headerlink" title="开始使用 Emacs"></a>开始使用 Emacs</h3><p>刚安装好的 Emacs <strong>十分简陋</strong>。需要对它进行配置，才能<strong>勉强</strong>达到一个稍微好用的状态。但是从顺序上来说，<strong>先</strong>知道如何使用，后续配置的过程才会更加游刃有余。首次打开 Emacs 界面如下图：</p><img src="/2022/05/16/emacs-setup/emacs-interface-01.jpeg" title="emacs default welcome interface"><p>上图中我标注了 Emacs 的一些<strong>基本概念</strong>术语，这样后续你就会知道这些名词分别是在说什么区域：</p><ul><li><strong style="color:rgb(108, 27, 44);">红色</strong>标注区的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/The-Echo-Area.html" target="_blank" rel="noopener">Echo Area</a>：显示你的各种输入，进行简单的交互，比如查找文件，查找关键词；</li><li><strong style="color:rgb(62, 93, 34);">绿色</strong>标注区的 <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Mode-Line.html" target="_blank" rel="noopener">Mode Line</a>：显示当前 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 的状态信息。后期可以自行定义显示内容；</li><li><strong style="color:rgb(98, 0, 169);">紫色</strong>标注区的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Windows.html" target="_blank" rel="noopener">Window</a>：内容区。显示当前 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 的内容。</li><li><strong style="color:rgb(108, 191, 167);">青色</strong>标注区的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html" target="_blank" rel="noopener">Frame</a>：一个 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Frames.html" target="_blank" rel="noopener">Frame</a> 内部区域可以分割成多个 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Windows.html" target="_blank" rel="noopener">Window</a>，这样可以<strong>同时</strong>看多个 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a>；</li></ul><p>除了上述四个描述用户界面的概念，Emacs 里还有个重要概念是 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 。对新手来说，现阶段只需要把 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 简单理解为「<strong>任务</strong>」就行了。比如，你打开了 3 个文件，就相当于有了 3 个 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> ，每个文件对应一个；浏览器开了 2 个页面，就有 2 个 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> ……所以，在不同 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 之间切换，就相当于在你的 3 个文件之间、2 个浏览器页面之间切换，然后 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Basics.html" target="_blank" rel="noopener">Buffer</a> 的内容会显示在你的 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Basic-Windows.html" target="_blank" rel="noopener">Window</a> 区域里。</p><p>接下来就是「<strong>操作</strong>」了。虽然也能用鼠标，但 Emacs 的<strong>主流</strong>操作是以<strong>键盘快捷键</strong>为主的。因为它多数情况下比鼠标效率高，尽管这也增加了新手的学习成本。</p><p>Emacs 的<strong>快捷键组合</strong>多数会配合 <code>Ctrl</code> 和 <code>Meta</code> 这两个按键。这两个键分别会用大写字母 <code>C</code> 和 <code>M</code> 来表示。比如 <code>Ctrl + G</code> 这样的组合按键会写成 <code>C-g</code> ，表示同时按键盘上的 <code>Ctrl</code> 键和字母 <code>G</code> 键。同理，<code>M-x</code> 表示同时按键盘上的 <code>Meta</code> 键和字母 <code>X</code> 键。<code>C-x C-s</code> 表示先按 <code>C-x</code> 组合键，再按 <code>C-s</code> 组合键。现在再看上文的界面图，就能知道 <strong>echo area</strong> 区域在提示你可以用快捷键 <code>C-x C-s</code> 来查看更多信息。</p><p>苹果电脑的键盘上没有 <code>Meta</code> 按键，默认会用 <code>Option</code> 按键来替代（可自定义）。</p><p>下面是最基础的快捷键，耐心适应后，会感觉还算好用：</p><ul><li><code>C-g</code> ：这个是<strong>撤销</strong>操作。比如你快捷键输入到一半错了想撤销就按它；</li><li><code>C-x C-f</code> ：<strong>打开</strong>文件的操作。在 <strong>echo area</strong> 输入文件路径后如果文件不存在就会<strong>新建</strong>；</li><li><code>C-x C-s</code> ：<strong>保存</strong>当前文件。不过在 MacOS 下，你也可以直接用 <code>cmd + S</code> 这样通用的保存操作；</li><li><code>C-x C-w</code> ：将当前文件另存为。相当于<strong>复制</strong>文件的操作；</li><li><code>C-x b</code> : <strong>切换</strong> Buffer 。可以用 <code>Tab</code> 键来自动补全或查看当前可切换的 Buffer ；</li><li><code>C-x C-c</code> : <strong>关闭</strong> Emacs 编辑器；</li></ul><p>掌握了上述基础操作后，就可以进行下一个部分的配置了。其他额外知识可以随着 Emacs 的使用慢慢掌握，我们<strong>首要目标</strong>是能尽快地写 Scheme 代码和运行它。</p><hr><h3 id="配置-Emacs"><a href="#配置-Emacs" class="headerlink" title="配置 Emacs"></a>配置 Emacs</h3><p>这里只需要做 <strong>3 个</strong>关键设置即可。建议直接使用 Emacs 来做各种编辑操作，这样能更快熟悉它。为了简单，我将直接列出<strong>可执行</strong>的步骤，<strong>不会深入</strong>讲解其中的原理。新手在最初的 Emacs 使用中也<strong>无须</strong>过度探索，确保<strong>尽快</strong>进入 Scheme 编程阶段。扩展知识我都给了链接，之后再慢慢深入。</p><ul><li><p><strong>第 1 步</strong>：<br>编辑 Emacs 的初始化文件 <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html" target="_blank" rel="noopener"><code>init.el</code></a> 。刚安装好的 Emacs 没有这个文件，需要我们自己新建。我们还需要<strong>删除</strong>原始的初始化文件 <code>~/.emacs</code> ，避免它的内容覆盖我们之后设置好的 <code>init.el</code><br>使用快捷键 <code>C-x C-f</code> <strong>新建</strong>并打开文件 <code>~/.emacs.d/init.el</code> ，然后将下面的代码复制进去保存：</p><pre><code class="lang-lisp">(add-to-list &#39;load-path &quot;~/.emacs.d/scheme&quot;)(autoload &#39;paredit-mode &quot;paredit&quot;  &quot;Minor mode for pseudo-structurally editing Lisp code.&quot;  t)(require &#39;parenface)(set-face-foreground &#39;paren-face &quot;DimGray&quot;);;;;;;;;;;;;;; Yin&#39;s Scheme Configuration;;;;;;;;;;;;(require &#39;cmuscheme)(setq scheme-program-name &quot;scheme&quot;) ;; 指定用 Chez Scheme ，若用 Racket 就写 &quot;racket&quot;;; bypass the interactive question and start the default interpreter(defun scheme-proc ()  &quot;Return the current Scheme process, starting one if necessary.&quot;  (unless (and scheme-buffer               (get-buffer scheme-buffer)               (comint-check-proc scheme-buffer))    (save-window-excursion      (run-scheme scheme-program-name)))  (or (scheme-get-process)      (error &quot;No current process. See variable `scheme-buffer&#39;&quot;)))(defun switch-other-window-to-buffer (name)    (other-window 1)    (switch-to-buffer name)    (other-window 1))(defun scheme-split-window ()  (cond   ((= 1 (count-windows))    ;;(split-window-vertically (floor (* 0.68 (window-height))))    (split-window-horizontally (floor (* 0.68 (window-width))))    (switch-other-window-to-buffer &quot;*scheme*&quot;))   ((not (member &quot;*scheme*&quot;               (mapcar (lambda (w) (buffer-name (window-buffer w)))                       (window-list))))    (switch-other-window-to-buffer &quot;*scheme*&quot;))))(defun scheme-send-last-sexp-split-window ()  (interactive)  (scheme-split-window)  (scheme-send-last-sexp))(defun scheme-send-definition-split-window ()  (interactive)  (scheme-split-window)  (scheme-send-definition))(add-hook &#39;scheme-mode-hook  (lambda ()    (paredit-mode 1)    (define-key scheme-mode-map (kbd &quot;&lt;f5&gt;&quot;) &#39;scheme-send-last-sexp-split-window)    (define-key scheme-mode-map (kbd &quot;&lt;f6&gt;&quot;) &#39;scheme-send-definition-split-window)))</code></pre><p>之所以用 <code>~/.emacs.d/init.el</code> 而不是传统的 <code>~/.emacs</code> 来作为初始化文件是为了「<strong>模块化管理</strong>」。后续所有关于 Emacs 的配置文件都将<strong>集中</strong>存放在 <code>~/.emacs.d</code> 文件夹中，便于管理。比如关于 Scheme 代码的设置文件我就在 <code>.emacs.d</code> 文件夹下建立了一个子文件夹 <code>scheme</code> 来存放。顶层只放初始化文件。</p></li><li><p><strong>第 2 步</strong>：<br>下载 <a href="http://mumble.net/~campbell/emacs/paredit.el" target="_blank" rel="noopener"><code>paredit.el</code></a> 文件，将它放到 <code>~/.emacs.d/scheme</code> 目录下。可用快捷键 <code>C-x C-w</code> 来将文件复制（另存为）到该目录。你可能会对 <a href="http://mumble.net/~campbell/emacs/paredit.el" target="_blank" rel="noopener"><code>paredit.el</code></a> 文件中 <code>^L</code> 这样的内容感到奇怪，不用管它，参见<a href="https://stackoverflow.com/questions/1576887/what-does-l-in-emacs-lisp-source-code-mean" target="_blank" rel="noopener">这里</a>。<br><a href="http://mumble.net/~campbell/emacs/paredit.el" target="_blank" rel="noopener"><code>paredit.el</code></a> 文件提供了<strong>高效可靠</strong>的括号操作，提升我们 Scheme 代码的编辑体验。</p></li><li><p><strong>第 3 步（可选）</strong>：<br>这步是把代码的括号颜色调淡，不做也不影响我们编辑、运行代码。但因为简单，推荐做一下。<br>下载 <a href="https://www.dropbox.com/s/v0ejctd1agrt95x/parenface.el" target="_blank" rel="noopener"><code>parenface.el</code></a> 文件，并将其放在 <code>~/.emacs.d/scheme</code> 目录下。同样可用 <code>C-x C-w</code> 快捷键操作。</p></li></ul><hr><h3 id="使用-Emacs-来写-Scheme-代码"><a href="#使用-Emacs-来写-Scheme-代码" class="headerlink" title="使用 Emacs 来写 Scheme 代码"></a>使用 Emacs 来写 Scheme 代码</h3><p>相信现在你已基本熟悉 Emacs 的快捷键 <code>C-x C-f</code> 了。就用它来新建文件 <code>~/Documents/length.scm</code> ，看看如何编辑运行 Scheme 吧。</p><p>还是写我们的老朋友 <code>length</code> 函数：</p><pre><code class="lang-scheme">(define length  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (length (cdr l)))])))(length &#39;(1 2 3))(length `(4 ,(+ 5 6) 7))</code></pre><p>我们上面的配置中把 <code>F5</code> 这个按键设置为了「<strong>运行光标所在处的前一个表达式</strong>（scheme-send-last-sexp）」。所以我们先把光标移动到第一个 <code>define</code> 表达式的<strong>最末尾</strong>，按一下 <code>F5</code> 。这时你可以看到 Emacs 出现了一个新的 <strong>Window</strong> ，开启了 <strong>REPL</strong> 交互模式，并且成功运行了我们的 <code>define</code> 表达式。</p><p>同理，我们分别把光标移动到后面两个表达式的末尾，按 <code>F5</code> ，就能分别得到这两个表达式的值了：</p><img src="/2022/05/16/emacs-setup/emacs-interface-02.jpeg" title="emacs scheme code interface"><p>多数时候，我们的代码很多，依次运行一个个表达式太麻烦。这时，可先按 <code>cmd + A</code> 全选内容，然后用 Emacs 的快捷键 <code>C-c C-r</code> 来向 <strong>REPL</strong> 载入所选内容（scheme-send-region）。这样，整个文件的内容就都被送到 Chez Scheme 里了。然后，你就可以用 <code>F5</code> 一个个地运行测试你的表达式了。</p><p>你也可以用 <code>C-c C-l</code> 来载入（运行）某个文件（scheme-load-file）。总的来说，在用 <code>F5</code> 依次运行表达式之前，要先确保各种变量都已完成定义。</p><p>编辑 Scheme 文件时的常用快捷键：</p><ul><li><code>C-c C-k</code>：scheme-compile-file               </li><li><code>C-c C-l</code>：scheme-load-file </li><li><code>C-c C-r</code>：scheme-send-region          </li><li><code>C-c C-e</code>：scheme-send-definition</li><li><code>C-x C-e</code>：scheme-send-last-sexp</li><li><code>Control + 右箭头</code>：paredit-forward-slurp-sexp 括号向右<strong>扩展</strong>，<strong>吃掉</strong>右边最近的一个表达式</li><li><code>Control + 左箭头</code>：paredit-forward-barf-sexp  括号向左<strong>收缩</strong>，<strong>吐出</strong>左边最近的一个表达式</li></ul><p>本<strong>节</strong>参考资料：</p><ul><li><a href="https://alexott.net/en/writings/emacs-devenv/EmacsScheme.html" target="_blank" rel="noopener"><em>Support for the Scheme programming language</em></a></li><li><a href="https://www.cs.ucf.edu/~leavens/ui54/WWW/scheme.shtml" target="_blank" rel="noopener"><em>Running Scheme</em></a></li><li><a href="https://doc.endlessparentheses.com/Fun/inferior-scheme-mode.html" target="_blank" rel="noopener"><em>Emacs Online Documentation</em></a></li></ul><hr><h3 id="更多的-Emacs-操作和技巧（待完善）"><a href="#更多的-Emacs-操作和技巧（待完善）" class="headerlink" title="更多的 Emacs 操作和技巧（待完善）"></a>更多的 Emacs 操作和技巧（待完善）</h3><blockquote><p>Emacs 是一个好的操作系统，它只是缺少一个好的编辑器。</p><footer><strong>Ian</strong></footer></blockquote><p>常用内容编辑快捷键：</p><ul><li><code>C-p</code> : 光标向<strong>上</strong>移动；</li><li><code>C-n</code> : 光标向<strong>下</strong>移动；</li><li><code>C-f</code> : 光标向<strong>前</strong>移动；</li><li><code>C-b</code> : 光标向<strong>后</strong>移动；</li><li><code>C-e</code> : 光标向移动到这一段文字的<strong>末尾</strong>；</li><li><code>C-a</code> : 光标向移动到这一段文字的<strong>开头</strong>；</li><li><code>C-k</code> : 删除并复制光标处开始后面的这一段文字（类似<strong>剪切</strong>操作）；</li><li><code>C-y</code> : 于光标处粘贴最近一次被 <code>C-k</code> 复制的内容（类似<strong>粘贴</strong>操作）；</li><li><code>M-y</code> : 在 <code>C-y</code> 操作后，切换 <code>C-k</code> 复制的内容（ <code>C-k</code> 复制的内容都被储存在 <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Kill-Ring.html" target="_blank" rel="noopener">kill ring</a> 里）；</li></ul><p>……<br>……</p><p>TODO</p><p><strong>本文</strong>参考与拓展资料：</p><ul><li>对新手相当<strong>不</strong>友好的<strong>过于简洁</strong>的教程：<a href="http://www.yinwang.org/blog-cn/2013/04/11/scheme-setup" target="_blank" rel="noopener"><em>Scheme 编程环境的设置</em></a></li><li>对新手<strong>勉强算</strong>友好的<strong>过于全面</strong>的教程：<a href="https://systemcrafters.net/emacs-essentials/absolute-beginners-guide-to-emacs/" target="_blank" rel="noopener"><em>The Absolute Beginner’s Guide to Emacs</em></a></li><li><strong>官方</strong>文档（有关 Emacs 初始化配置文件的位置）：<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-File.html" target="_blank" rel="noopener"><em>The Emacs Initialization File</em></a></li><li>作者 Pavinberg 吐槽 Emacs 中文社区的教程质量不高于是<strong>亲自专栏</strong>：<a href="https://www.zhihu.com/column/c_1440829147212279808" target="_blank" rel="noopener"><em>专业 Emacs 入门教程系列</em></a></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scheme 的基本语法和编程操作</title>
      <link href="/2022/03/24/scheme-basics-and-IDE/"/>
      <url>/2022/03/24/scheme-basics-and-IDE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Lisp_(programming_language" target="_blank" rel="noopener"><strong>Lisp</strong></a> 这个语言的家族里包括了 <a href="https://schemers.org" target="_blank" rel="noopener">Scheme</a> 、<a href="https://racket-lang.org" target="_blank" rel="noopener">Racket</a> 、<a href="https://en.wikipedia.org/wiki/Common_Lisp" target="_blank" rel="noopener">Common Lisp</a> 、<a href="https://en.wikipedia.org/wiki/Emacs_Lisp" target="_blank" rel="noopener">Emacs Lisp</a> 等各式各样以「<strong>括号</strong>」、「<strong>lambda</strong>」和「<strong>链表</strong>（list）」为特征的语言。</p><p><a href="https://en.wikipedia.org/wiki/Daniel_P._Friedman" target="_blank" rel="noopener">Daniel Paul Friedman</a> 算是 <strong>Scheme</strong> 的带头人物，尽管 <a href="https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language" target="_blank" rel="noopener">Scheme</a> 最初不是他发明的。然后这个 <a href="https://racket-lang.org" target="_blank" rel="noopener">Racket</a> 其实本身是属于一种 <a href="https://schemers.org" target="_blank" rel="noopener">Scheme</a> 的（即 <strong>Racket</strong> 应算是 <strong>Scheme</strong> 语言的一个实现）。但是呢，<a href="https://racket-lang.org/plt.html" target="_blank" rel="noopener">PLT</a> 这帮人他们现在不承认他们是 <strong>Scheme</strong> 了，就另外起了一个名叫 <strong>Racket</strong> （以前的名字叫 <strong>PLT Scheme</strong>，改名试图脱离 Scheme 的阴影。实际上，好像并没有比 Scheme 超出多少）。反正这帮人的头目应该就是 <a href="https://mitpress.mit.edu/books/little-schemer-fourth-edition" target="_blank" rel="noopener"><em>The Little Schemer</em></a> 的第二作者、同时也是 <a href="https://en.wikipedia.org/wiki/Daniel_P._Friedman" target="_blank" rel="noopener">Dan Friedman</a> （也许是最厉害）的学生：<a href="https://felleisen.org/matthias/" target="_blank" rel="noopener">Matthias Felleisen</a> 。</p><img src="/2022/03/24/scheme-basics-and-IDE/mit-dnj-2.png" title="Matthias Felleisen"><p>早期的 <strong>Lisp</strong> 语言的函数就是一个符号链表，它不会自带一个 <code>env</code>（解释器中的闭包环境，或者说上下文语境），会出现严重的问题：<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope" target="_blank" rel="noopener">Dynamic Scoping</a> 。<strong>Scheme</strong> 不是第一个实现针对该问题的 <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope" target="_blank" rel="noopener">Lexical Scoping</a> 特性的编程语言，但确实是第一个实现 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">Closure</a>（闭包）的 <strong>Lisp</strong> 语言。</p><p><strong>Scheme</strong> 语言有一个很好的特征，就是你可以把你的「<strong>代码</strong>」，用很简单的方式就变成「<strong>数据</strong>」，这将非常适合用来实现各种语言和语言特性。如果用其他编程语言，比如 <a href="https://www.javascript.com" target="_blank" rel="noopener">JavaScript</a> ，来做这件事的话，那种数据结构的形式（ <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">AST</a> 抽象语法树）会让人写得很痛苦，看起来也不像正常的代码。</p><p>其他搜索时的八卦：</p><ul><li>经 <a href="https://github.com/melp" target="_blank" rel="noopener">melp</a> 同学提醒，Racket 从 8.0 版本开始，默认实现（implementation）会变成 <a href="https://blog.racket-lang.org/2021/01/racket-status.html" target="_blank" rel="noopener">Racket on Chez Scheme (Racket CS) </a></li><li>查资料的时候还发现一篇关于 Racket 和 Chez Scheme 的文章：<a href="https://beautifulracket.com/appendix/racket-and-chez-scheme.html" target="_blank" rel="noopener"><em>Thoughts on Racket &amp; Chez Scheme</em></a> 。该文章出自 <a href="https://beautifulracket.com" target="_blank" rel="noopener"><em>Beautiful Racket by Matthew Butterick</em></a> 这本书</li><li><p>还搜到一个 2014 年写的 <a href="https://the-little-schemer.readthedocs.io/zh_CN/latest/index.html#" target="_blank" rel="noopener"><em>The Little Schemer 笔记</em></a> ，作者 <a href="http://chenjiee815.github.io" target="_blank" rel="noopener">chenjiee815</a> 似乎也很久没<a href="https://readthedocs.org/profiles/chenjiee815/" target="_blank" rel="noopener">更新</a>了，2014 年后也不再活跃。由于好奇，尝试继续深入了一下，发现 chenjiee815（<a href="https://www.linkedin.com/in/杰-陈-b55a2285/?originalSubdomain=cn" target="_blank" rel="noopener">陈杰</a>）这家伙 2009 年从南京的中国药科大学毕业，本科专业居然是「中药学」。毕业后工作，一年后考计算机研究生失败，转行进行计算机行业在南京某公司当个 IT 小讲师，然后是 IT 团队小领导（这篇笔记就是做小领导期间写的）。南京公司被阿里巴巴收购后，陈到杭州阿里工作。一年多后进入华为回到南京，至今仍在华为。从中药学到计算机，真是个急速扩张的人生。不过 09 年大学毕业，意味着「华为」、「35岁」双关键词达成。加上这个时代「疫情」、「战争」、「金融去杠杆」等新关键词之后，希望他能加强危机意识，一切顺利。看来我也要抽空去更新一下我的 LinkedIn 了。</p></li><li><p>陈杰 2014 年的这篇笔记在很多地方都被引用，这让我想起自己第一次知道这本书也是 2014 年（李路肯定不知道他的热情分享对我影响很大，他应该不记得我了）。看来 TLS 的出圈时间节点很可能就是 2014 。另一个有意思的细节是，<a href="https://www.yinwang.org/blog-cn/2012/07/04/dan-friedman" target="_blank" rel="noopener"><em>GTF - Great Teacher Friedman</em></a> 的第一版似乎是在 2012 年写的。</p></li></ul><img src="/2022/03/24/scheme-basics-and-IDE/li_lu_promotes_TLS.jpg" title="Li Lu promotes TLS"><img src="/2022/03/24/scheme-basics-and-IDE/Li_Lu_s_kindness.jpeg" title="Li Lu and Wang"><hr><h3 id="编程软件-DrRacket"><a href="#编程软件-DrRacket" class="headerlink" title="编程软件 - DrRacket"></a>编程软件 - DrRacket</h3><p>直接去 <strong>Racket</strong> 的<a href="https://racket-lang.org" target="_blank" rel="noopener">官网</a>下载对应的安装包到本地即可双击安装。支持 Windows 和 MacOS 。</p><p>常用快捷键：</p><ul><li><strong>运行</strong>代码：<code>cmd + R</code>（ MacOS 系统）；</li><li>快速<strong>缩进排版</strong>所有代码（Reindent All）：<code>cmd + I</code>（ MacOS 系统）；</li><li><strong>注释</strong>代码（块）：<code>control + esc + ;</code>（ MacOS 系统）；<code>Ctrl + Alt + ;</code>（ Win 系统）；</li><li>显示代码整体<strong>轮廓</strong>（Show Program Contour）：<code>cmd + U</code>（ MacOS 系统）；</li><li><strong>取消</strong>注释代码（块）：<code>control + esc + =</code>（ MacOS 系统）；<code>Ctrl + Alt + =</code>（ Win 系统）；</li><li>将<strong>输出</strong>窗口显示在<strong>右侧</strong>，使编辑窗口的区域更大：<code>cmd + shift + L</code>（ MacOS 系统）；<br>也可以通过选择 <code>View</code> -&gt; <code>Use Horizontal Layout</code> 实现；</li><li>在输出窗口测试的时候，调出<strong>上一个</strong>运行的代码：<code>esc + P</code>（ MacOS 系统）；</li><li>在输出窗口测试的时候，调出<strong>下一个</strong>运行的代码：<code>esc + N</code>（ MacOS 系统）；</li><li>光标定位到一个变量，<strong>重命名</strong>所有这个变量（会根据 Scope 来而不是简单的同名）：<code>control + X + M</code>（ MacOS 系统）；</li></ul><p>其他快捷键组合还可以打开 <strong>Keybindings</strong> 窗口查询：<code>Edit</code> -&gt; <code>Keybindings</code> -&gt; <code>Show Active Keybindings</code><br>查询表中 <strong>s:</strong> 代表 <code>Shift</code> 、<strong>c:</strong> 代表 <code>Control</code> 、<strong>a:</strong> 代表 <code>Option</code> 、<strong>m:</strong> 代表 <code>Meta</code> 、<strong>d:</strong> 代表 <code>Command</code> <a href="https://gist.github.com/spdegabrielle/89de48580126592264f3741c4240e917" target="_blank" rel="noopener">……</a></p><p>MacOS 系统里可在 <code>Preferences</code> -&gt; <code>Editing</code> -&gt; <code>General Editing</code> 里勾选 <strong>Treat alt key as meta</strong> ，这样就可以使用 <code>option</code> 键来代替 <code>esc</code> 键。比如上述操作困难的 <code>control + esc + ;</code> 快捷键组合就会变成稍微好点的 <code>control + option + ;</code></p><p>更多使用使用小技巧可参考 <a href="https://rebelsky.cs.grinnell.edu/Courses/CSC151/2018S/handouts/drracket-tips" target="_blank" rel="noopener">Some tips and tricks for DrRacket</a> ，或者查看 <a href="https://docs.racket-lang.org/guide/index.html" target="_blank" rel="noopener"><em>The Racket Guide</em></a> 和 <a href="https://plt.cs.northwestern.edu/snapshots/current/pdf-doc/drracket.pdf" target="_blank" rel="noopener"><em>DrRacket: The Racket Programming Environment</em></a></p><hr><h3 id="编程软件-Emacs"><a href="#编程软件-Emacs" class="headerlink" title="编程软件 - Emacs"></a>编程软件 - Emacs</h3><p>Emacs 可以通过配置，方便地（也没有特别方便啦）使用由 <strong>R. Kent Dybvig</strong> 设计的、当今性能和可靠性都最强的 <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 来运行我们的代码。</p><p>但无论是配置的过程，还是使用的过程，Emacs 的操作对<strong>新手</strong>来说始终不是特别友好。Racket 更适合广大计算新人。而且上文已经说了，Racket 的默认实现今后会变成 <a href="https://blog.racket-lang.org/2021/01/racket-status.html" target="_blank" rel="noopener">Racket on Chez Scheme </a>。</p><p>所以目前的建议是，新手就用 <a href="https://racket-lang.org" target="_blank" rel="noopener">DrRacket</a> 作为主力编辑器写 Scheme 代码。有需要再在终端里用 <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 运行<code>.scm</code> 代码文件。</p><p>如果仍然想使用 Emacs ，可以看我写的<a href="/2022/05/16/emacs-setup/"><em>针对 Scheme 的 Emacs 编程环境设置</em></a>，里面也提到了如何安装和使用 <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">Chez Scheme</a> 。</p><hr><h3 id="Scheme-常用的语法"><a href="#Scheme-常用的语法" class="headerlink" title="Scheme 常用的语法"></a>Scheme 常用的语法</h3><p>编程语言 Scheme 采用的是前缀表达式的语法。即处于第一位置的就是「操作符」，之后位置的就是「操作数」。计算的<strong>优先级</strong>由「括号」来确定。括号内部的最先计算。具体顺序为：先对括号中的每一个表达式求值，然后再将操作符作用在操作数上，对整个括号的表达式求值。</p><ul><li><p><strong>前缀表达式</strong></p><pre><code class="lang-scheme">(+ 2 3)        ;; 分别对 + 、2 、3 这三个表达式求值，再将 + 的值（操作符）作用在 2 和 3 上(* 1 (+ 3 5))</code></pre></li><li><p><strong>函数</strong></p><pre><code class="lang-scheme">;; 语法为：(lambda (参数1 参数2 ...) 表达式)(lambda (x) (* x x x))  ;; x =&gt; x * x * x(lambda  (a b)  (+ a b))     ;; (a, b) =&gt; a + b</code></pre></li><li><p><strong>定义</strong></p><pre><code class="lang-scheme">;; 定义变量(define x 2);; 定义 square 函数(define square (lambda (x) (* x x)));; 调用 square 函数(square x)        ;; 输出 4</code></pre></li><li><p><strong>赋值操作</strong></p><pre><code class="lang-scheme">;; 语法：;; (set! variable-name expression)(set! x 6)(square x)        ;; 输出 36</code></pre></li><li><p><strong>逻辑操作符</strong></p><pre><code class="lang-scheme">(and (&lt; 2 3) (&gt; 5 4))(or (&lt; 2 3) (&gt; 5 4))(not #f)(not &#39;(1 2))</code></pre></li><li><p><strong>条件分支</strong></p><pre><code class="lang-scheme">;; 普通的 if 语句在 scheme 中和其他前缀表达式的形式相同，由 1 个“操作符”搭配后面 3 个操作数;; scheme 中 true 和 false 分别用 #t 和 #f 来表示;; 语法为：(if pred true-exp false-exp)(if (&lt; 3 5) #t #f);; 另一种条件分支的写法是 cond;; 语法如下：;;(cond;;  [pred1 exp1];;  [pred2 exp2];;  [else;;   exp3]);; cond 的例子 fact 和 fib：;; scheme 中不需要写 == 了，因为 scheme 中没有赋值语句，所以符号 = 没有被占用;; 现代的 scheme 也允许使用方括号 [] ，在 cond 语句中用方括号逻辑结构会看得更清楚;; 求 n 的阶乘的函数 fact(define fact  (lambda (n)    (cond [(= n 0) 1]          [else           (* n (fact (- n 1)))])));; 求斐波那契数列中第 n 个数的函数 fib(define fib  (lambda (n)    (cond [(= n 0) 0]          [(= n 1) 1]          [else           (+ (fib (- n 1))              (fib (- n 2)))])));; 比较两个数字可以用 =(= 1 2)          ;; 输出 #f;; 比较两个符号（symbol）或字符串（String）则要用 eq? 或者 equal?(eq? &#39;x &#39;y)      ;; 输出 #f(eq? &#39;x &#39;x)      ;; 输出 #t(equal? &#39;x &#39;y)   ;; 输出 #f;; 比较两个字符串（String）的大小(string&gt;? &quot;x&quot; &quot;y&quot;)  ;; 输出 #f(string&lt;? &quot;x&quot; &quot;y&quot;)  ;; 输出 #t(string=? &quot;x&quot; &quot;x&quot;)  ;; 输出 #t - 这里字符串的相等等价于使用 eq?;; 比较两个符号（Symbol）的大小，可先转成字符串再比较;; 若是判断两个符号（Symbol）是否相等，直接用 equal? 或 eq? 就行，不必转换后用 string=?(string&lt;? &quot;x&quot; (symbol-&gt;string &#39;y)) ; 输出 #f</code></pre></li><li><p><strong>数据结构 pair 及其操作</strong>： pair 属于编程语言里最简单而又最重要的数据结构。</p><pre><code class="lang-scheme">;; 在 scheme 中专门有一组操作符函数来实现 pair 的构造和对它内部负载的访问(define p1 (cons 2 3));; 也可以这么构造&#39;(2 . 3);; car 和 cdr 能分别取出 pair 结构的第一个和第二个「有效负载」;; 因为早期计算机的寄存器就叫 car 和 cdr - 参见 SCIP 的解释(car (cons 3 4))(cdr (cons 3 4));; 使用 pair? 来判断一个东西是不是 pair(pair? p1)(pair? null)</code></pre></li><li><p><strong>链表</strong>（list）：有了 pair 结构，很自然地就会有链表结构</p><pre><code class="lang-scheme">;; 在 scheme 中专门有一组操作符函数来实现 pair 的构造和对它内部负载的访问(cons 1 (cons 2 cons (3 (cons 4)))&#39;(1 2 3 4)(define ls1 (list 1 2 3 4))(car (cdr (cdr ls1)))   ;; 3</code></pre></li><li><p><strong>quote 操作</strong>：quote 可以把代码变成数据，这将便于运行和测试「语言的实现（implementation）」</p><pre><code class="lang-scheme">(quote (+ 1 (* 2 3)))  ;; 输出 (+ 1 (* 2 3))&#39;(+ 1 (* 2 3))         ;; 上面的 quote 的操作可以用单引号 &#39; 来更简洁地实现。两者等价。运行输出 (+ 1 (* 2 3));; quote 和 &#39; 都可以将代码变成 symbol ，你可以使用 symbol? 来询问判断一个东西是不是 symbol;; 注意，symbol（符号）和 string（字符串）是两种不同的数据类型(symbol? &#39;(1 2 3))      ;; #f(symbol? &#39;x)            ;; #t;; 对于数字，则可以用 number?(number? 2)</code></pre><p>下面这串有趣的测试可以运行尝试一下，会对 quote 有深入理解：</p><pre><code class="lang-scheme">(quote ())            ;; 输出 &#39;()&#39;(quote ())           ;; 输出 &#39;&#39;()&#39;&#39;()                  ;; 这个和上面的代码等价。运行输出 &#39;&#39;()(pair? &#39;&#39;())          ;; 输出 #t - 这东西是个 pair(length &#39;&#39;())         ;; 输出 2 - 这东西包含 2 个「有效负载」(car &#39;&#39;())            ;; 输出 quote - 这个 pair 的第一个「有效负载」是 quote(symbol? (car &#39;&#39;()))  ;; 输出 #t - 第一个「有效负载」 quote 是 symbol(cdr &#39;&#39;())            ;; 输出 &#39;(()) - 第二个「有效负载」是 null&#39;(1 quote ())         ;; 输出 &#39;(1 quote ())&#39;(quot ())            ;; 输出 &#39;(quot ())</code></pre><p><strong>解答</strong>：<code>&#39;()</code> 其实就是 <code>(quote ())</code> 。当 DrRacket 在输出一个链表时，如果是 <strong>(1 2 3)</strong> 这种普通链表，那就会输出 <code>(1 2 3)</code> 。如果输出的链表中包含 <a href="https://docs.racket-lang.org/guide/quote.html" target="_blank" rel="noopener">quote</a> ，那么，它的输出可能不会显示 <code>(quote ())</code> 这样直观能看到「有效负载」的链表，而是会显示简化后的 <code>&#39;()</code> 。</p><p>这点可以通过观察 <code>&#39;(quote ())</code> 和 <code>&#39;(quot ())</code> 这两个代码的输出结果进一步理解：由于 quot 不再是关键词 identifier ，于是输出结果回复直观显示「有效负载」的 <code>(quot ())</code> 。</p><p>这里涉及到 Scheme 里面字符号（Symbol）和符串（String）两个概念的区别。具体来说 <code>&#39;quote</code> 和 <code>&quot;quote&quot;</code> 这两个表达式的输出结果是不一样的。前者是符号后者是字符串。</p></li><li><p><strong>quasiquote 和 unquote 操作</strong>：如果想读取变量的值，就需要用到 <a href="https://docs.racket-lang.org/guide/qq.html" target="_blank" rel="noopener">quasiquote</a> 操作了</p><pre><code class="lang-scheme">(define x 6) ;; 定义变量 x 为 6&#39;(1 2 3 x)   ;; 运行输出 (1 2 3 x)`(1 2 3 x)   ;; 运行输出 (1 2 3 x)`(1 2 3 ,x)  ;; 运行输出 (1 2 3 6)</code></pre></li><li><p><strong>构造类型 struct</strong>：和下面的模式匹配 <code>match</code> 配合使用很厉害。使用 <code>struct</code> 构造数据结构和类型是有好处的，因为是专用的。符号链表（list）构造的类型还是太<strong>通用</strong>，容易弄混淆，尤其是配合 <code>match</code> 的时候。</p><pre><code class="lang-scheme">;; 构造闭包类型（结构） closure - 相当于其他语言里定义一个对象;; 闭包包含一个函数 f 和它被创造时的上下文环境 env(struct Closure (f env));; 构造函数类型（结构） - 函数包含一个参数部分 param 和一个函数体 body(struct Fun (param body));; 构造二元操作类型（结构）(struct Binop (op e1 e2));; 使用上面的类型创建实例（instance）(Closure (Fun &#39;x (Binop &#39;+ 2 &#39;x)))(define b1 (Binop &#39;+ 2 3));; 取出 struct 里的内容(Binop-op b1)  ;; 输出 &#39;+(Binop-e1 b1)  ;; 输出 &#39;+(Binop-e2 b1)  ;; 输出 &#39;3</code></pre></li><li><p><strong>模式匹配</strong>（Pattern Matching）：<a href="https://docs.racket-lang.org/reference/match.html" target="_blank" rel="noopener">match</a> 是属于 <strong>Racket</strong> 特有的，<strong>Scheme</strong> 本身是没有模式匹配的，尽管它可以用宏来实现这个语言特性。</p><pre><code class="lang-scheme">;; 模式匹配的基本语法(match val-expr clause ...)</code></pre><p>其中 <code>val-expr</code> 代表要匹配的表达式，而 <code>clause</code> 语法的内容如下</p><pre><code class="lang-scheme">;; pat 代表 pattern ，用来判断是否和表达式 val-expr 的值匹配;; 若 pat 和 val-expr 匹配成功，就会对表达式 body 求值，并以它的值作为整个 match 的值clause    =   [pat body ...+]          |   [pat #:when cond-expr body ...+]</code></pre><p>下面举例说明上述 <strong>clause</strong> 中 <code>pat</code> 位置的常用语法，更多相关语法可查看文档：<a href="https://docs.racket-lang.org/reference/match.html" target="_blank" rel="noopener">9 Pattern Matching</a></p><pre><code class="lang-scheme">;; [(? number? v) v] 这行的 pat 部分用到的语法为 (? pred pat ...);; 该语法的意思是，如果表达式 (pred val-expr) 值为真，就匹配 pat 这个模式;; [(? number? v) v] 会先对表达式 (number? exp) 求值，;; 若值为 #t ，就用变量 v 来匹配 exp，然后输出 v 的值（即 exp 的值）;; [exp #:when (boolean? exp) &quot;boolean&quot;] 这分支的语法为;; [pat #:when cond-expr body ...+];; 意思是，如果表达式 cond-expr 值为真，就匹配 pat 这个模式;; 应该尽量用 #:when 而不是 (? ...) ，这样 pat 看起来就简洁很多;; 不然 pattern 本身里面嵌套了复杂的判断，看起来就不直观了，pattern 的意义就失去了;; 同理 [(? list? `(,lvp1 ,lvp2 ,lvp3)) lvp3] 会在 (list? exp) 的值为 #t 之后，;; 匹配 `(,lvp1 ,lvp2 ,lvp3) ，然后会输出 lvp3 的值;; [`(+ ,e1 ,e2) (+ (calc e1) (calc e2))] 这行的 pat 部分用到的语法为 (list lvp ...);; 符号 ` 和 , 分别是上文介绍到的 quasiquote 和 unquote 操作;; 由于 `(+ ,e1 ,e2) 是一个含有 3 个元素、且第一个元素是 symbol（符号） + 的 list ，;; 所以程序会先检查 exp 是不这样的 list，即是否是 (list + lvp2 lvp3);; 如果是，则匹配成功，此时，exp 这个 list 的元素 lvp2 和 lvp3 的值就会分别被赋予 e1 和 e2 ，;; 然后在 body 部分 (+ (calc e1) (calc e2)) 就能使用变量 e1 和 e2 进行求值;; 示例：使用 match 实现简易二元操作的计算器 calc(define calc(lambda (exp)  (match exp    [(? number? v) v]                          ; 难以直观看出 pattern 是什么    [exp #:when (boolean? exp) &quot;boolean&quot;]      ; 所以应尽量用 #:when 而不是 (? ...)    [`(+ ,e1 ,e2) (+ (calc e1) (calc e2))]     ; quasiquote 和 unquote 写的 pattern    [`(- ,e1 ,e2) (- (calc e1) (calc e2))]    [(list &#39;* e1 e2) (* (calc e1) (calc e2))]  ; list 写的 pattern    [(list &#39;/ e1 e2) (/ (calc e1) (calc e2))]    [(? list? `(,lvp1 ,lvp2 ,lvp3)) lvp3]    [else     (error &quot;Error: unsupported operation or illegal expression!&quot;)])))(calc &#39;(+ 1 (* 9 3)))     ; 输出 28(calc &#39;(9 19 29))         ; 输出 29 - 匹配到了倒数第 2 分支(calc #f)                 ; 输出 &quot;boolean&quot;</code></pre><p><code>match</code> 和 <code>struct</code> 配合可以实现很强大的表达</p><pre><code class="lang-scheme">;; 创建 shoe 和 hat 这两个结构(struct shoe (size color))(struct hat (size style));; 这块代码输出 &quot;top&quot; ；可以看到匹配成功之后，输出了表达式部分的值 &quot;top&quot;(match (hat 23 &#39;bowler) [(shoe 10 &#39;white) &quot;bottom&quot;] [(hat 23 &#39;bowler) &quot;top&quot;]);; 这块代码输出 23 ；可以看到 sz 这个变量成功匹配捕获到了 23 这个数据(match (shoe (hat 23 29) &#39;bowler)  [(shoe (hat sz stl) col) sz]  [else &quot;something else.&quot;])</code></pre></li><li><p><strong>注释</strong>：用 <code>;</code> 来注释代码（comment out）。DrRacket 中推荐用快捷键：<code>control + esc + ;</code>（MacOS）</p><pre><code class="lang-scheme">; 代码「行」注释#|代码「块」注释|#</code></pre></li><li><p><strong>输出与显示</strong><br>在 DrRacket 里，输出代码的结果不需要专门写类似 <code>console.log</code> 的函数，它会在窗口自行显示各表达式的值。但在 Debug 的时候，有可能需要在代码中间显示各种变量的值，这时候下面这些输出函数就很有用了</p><pre><code class="lang-scheme">(newline)           ; 空行（换行）(display &quot;\n&quot;)      ; &quot;\n&quot; 代表换行;; 连续 display 的话，内容之间是连在一起的，没有换行显示(display &quot;1st line&quot;)(display &quot;2nd line&quot;);; 运行输出：;; 1st line2nd line;; 加上 ln 之后的 displayln 会在显示内容完毕后换行，即自动另起一行(displayln &quot;1st line&quot;)(displayln &quot;2nd line&quot;);; 运行输出：;; 1st line;; 2nd line;; 使用 println 会把引号也显示出来(println &quot;1st line&quot;)(println &quot;2nd line&quot;);; 使用 fprintf 可以格式化输出;; 其中 ~a , ~s 和 ~v 分别是 write , display 和 print 的效果;; \n 代表换行。下面例子放在末尾，则代表末尾换行(fprintf (current-output-port)         &quot;~a as a string is ~s, ~a, ~v.\n&quot;         &#39;(3 4)         &quot;(3 4)&quot;         &quot;(3 4)&quot;         &quot;(3 4)&quot;);; 运行输出：;; (3 4) as a string is &quot;(3 4)&quot;, (3 4), &quot;(3 4)&quot;.</code></pre><p>关于输出的更多详细介绍，可以查阅 Racket 的文档 <a href="https://docs.racket-lang.org/reference/Writing.html" target="_blank" rel="noopener">13.5 Writing</a></p></li><li><p><strong>抛出异常</strong></p><pre><code class="lang-scheme">(error &quot;Error: illegal expression!&quot;)  ; 运行会报错，显示 &quot;Error: illegal expression!&quot;(error &quot;Error: &quot; x (+ 2 x))           ; 还可以输入表达式，显示表达式的值，运行显示 &quot;Error: 6 8&quot;</code></pre></li><li><p><strong>call/cc</strong>：这个“奇怪”却影响深远的东西<strong>最早</strong>也是由本篇开头提到的 <a href="https://en.wikipedia.org/wiki/Daniel_P._Friedman" target="_blank" rel="noopener">Daniel Paul Friedman</a> 想出来的，相关 paper 叫 <a href="https://legacy.cs.indiana.edu/ftp/techreports/TR133.pdf" target="_blank" rel="noopener"><em>A Scheme for a Higher-Level Semantic Algebra</em></a>。后来 <a href="https://en.wikipedia.org/wiki/Gerald_Jay_Sussman" target="_blank" rel="noopener">Gerald Susman</a>（SICP 的作者之一） 给了它一个名字 <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="noopener">call-with-current-continuation</a> ，从那以后 <a href="https://en.wikipedia.org/wiki/Daniel_P._Friedman" target="_blank" rel="noopener">Friedman</a> 的名字就再也没有和 <strong>call/cc</strong> 被人联系在一起过了。之后更先进的 <strong>shift / reset</strong> 这类 <a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited Continuation</a> 则是 Friedman 的学生弄的。</p><p><a href="https://docs.racket-lang.org/reference/cont.html#%28def._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._call%2Fcc%29%29" target="_blank" rel="noopener">call/cc</a> 虽然没有更先进的 <a href="https://docs.racket-lang.org/reference/cont.html#%28form._%28%28lib._racket%2Fcontrol..rkt%29._reset%29%29" target="_blank" rel="noopener">shift / reset</a> 好用，会逐渐退出历史舞台（参见 <a href="https://okmij.org/ftp/continuations/against-callcc.html" target="_blank" rel="noopener"><em>An argument against call/cc - Oleg Kiselyov</em></a>），但蜡烛和 LED 灯在各自的年代都为人类照亮了方向。何况如果没有 <a href="https://docs.racket-lang.org/reference/cont.html#%28def._%28%28lib._racket%2Fprivate%2Fmore-scheme..rkt%29._call%2Fcc%29%29" target="_blank" rel="noopener">call/cc</a> ，估计也没有 <a href="https://docs.racket-lang.org/reference/cont.html#%28form._%28%28lib._racket%2Fcontrol..rkt%29._reset%29%29" target="_blank" rel="noopener">shift / reset</a> 了。所以我觉得 <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="noopener">call/cc</a> 应该算里程碑式的东西。</p><pre><code class="lang-scheme">;; call/cc 会接收一个单参数函数，该函数的参数 k 会取得当前位置的 continuation;; 这里涉及到一个对新人陌生的概念：continuation 是什么东西？它有什么用？;; 关于这个，会新开一篇文章专门介绍。目前简单地理解，continuation 就是接下来要做的所有计算;; 调用这个 k ，程序会丢弃上下文;; 例子：(* 3 (+ 1 (call/cc (lambda (k) (+ 1 (k 2)))))) ;; 输出 9 - 内部的 (+ 1 ... ) 被丢弃了;; 通常会定义一个变量来存放 call/cc 捕获的 continuation ，共后续调用;; 例子：(define saved-k #f)(* 3 (+ 1 (call/cc (lambda (k) (set! saved-k k) (+ 1 (k 2))))))  ;; 输出 9 (saved-k 1)          ;; 输出 6 - 此时的 saved-k 相当于函数: (lambda (x) (* 3 (+ 1 x)))(+ 9 (saved-k 1))    ;; 输出 6 - (+ 9 ...) 这个上下文被忽略了</code></pre></li><li><p><strong>宏（Macro）</strong>：宏特别容易被滥用。<strong>第一</strong>使用原则是，你的宏不应该<strong>显著改变</strong>当前编程语言的语义，尽量都只做简单的重新排列组合动作。另一个基本的原则是，如果一个宏它实际上做的是函数的事情，那你都应该尽量使用函数，而不是宏，除非宏相比函数能实现某种<strong>效果更好</strong>的「封装打包」。</p><pre><code class="lang-scheme">;; 这里又涉及到一个对新人陌生的概念：Macro（宏）是什么东西？;; 简单地说 Macro 是一个语法转换器（Syntax Transformer）;; 宏接收一个 syntax object（语法对象），返回新的 syntax object ，相当于翻译（替换）操作;; 于是你可以通过宏定义的自己语法，这些语法是 Scheme 中原本没有的;; 比如你可以有 (my-lambda ...) 这样的表达，它和函数的区别是，省略号部分的参数不会被求值;; 因为转换（翻译）过程是在 compile time（程序编译阶段），而不是 run time（程序运行阶段）;; Macro 有点像在解释器里添加一个分支来支持的新语法，这时，当前语言相当于被扩展了;; 从这个意义上，Macro 像个小型解释器;; 更多关于 Macro 的概念和作用，可参见本节末尾 Greg Hendershott 的文章;; 我稍后也会写一篇关于 Macro 的应用的文章;; 宏会标记（接收）一串语法，然后根据定义转换成另一串语法返回;; 举例来说，下面的 define-syntax 会定义一个名字为 foo 的宏;; 当代码中出现 (foo ...) 这样的表达式，程序会根据名字 foo 判断出这是个宏，需要转译整个表达式;; 然后表达式 (foo ...) 会在 compile time 先被转换成我们在宏 foo 中所定义的表达式;; 即 (foo ...) 被替换成 (syntax &quot;I am foo&quot;);; (syntax &quot;I am foo&quot;) 会在接下来的 run time 阶段被求值(define-syntax (foo stx)  (syntax &quot;I am foo&quot;));; 对返回的 (syntax &quot;I am foo&quot;) 求值，输出 &quot;I am foo&quot;(foo (+ 1 2));; 宏的定义也可以写成 lambda 形式;; 我倾向于这样写，这样子可以清楚区分“参数” stx 和宏的名字，更加「模块化」(define-syntax show-stx  (lambda (stx)    (println (syntax-&gt;datum stx))  ;; stx 的内容是个 syntax ，把它转化成数据后显示出来    (datum-&gt;syntax stx             ;; 这里第一个参数先不用管，目前只需知道有它才能顺利转换                   (cadr (syntax-&gt;datum stx))))) ;; 宏最终都需要返回一个 syntax object;; 第一个输出是 &#39;(show-stx (+ 1 2));; 第二个输出是 3(show-stx (+ 1 2));; 第一个输出是 (println ...) 的输出，代表 stx 中所装载的内容;; 第二个输出过程如下：;; (syntax-&gt;datum stx) 会转换语法对象 stx 的内容，得到 &#39;(show-stx (+ 1 2));; 用 cadr 取得“参数”部分 &#39;(+ 1 2);; 然后通过 datum-&gt;syntax 把它转成了语法对象 (syntax (+ 1 2)) 作为宏 show-stx 的结果返回;; 最后，程序会计算 (syntax (+ 1 2)) 的值，得到结果 3;; 总结：;; (show-stx (+ 1 2)) 会在编译过程中被翻译（替换）成 (+ 1 2);; (println ...) 是宏 show-stx 的副作用，输出参数 stx 的内容#&#39;(+ 1 2)     ;; (syntax ...) 像 (quote ...) 一样可简写，这里等价于 (syntax (+ 1 2))(eval #&#39;(+ 1 2))   ;; 对该语法对象（树）求值，输出 3;; 通过上面的例子知道了 stx 装的大概就是个链表的结构（主要因为 scheme 的语法也是链表的形式）;; 链表的结构，自然会希望有个模式匹配的功能，毕竟定义新语法的常规操作就是重新组合调整各个部分;; 虽然能用上面提到的 match ，但是宏的转译是在编译过程中，编译过程默认是看不到 match 的;; 于是就有了专门针对宏的模式匹配 syntax-case ，用来匹配第一个参数 stx 的内容;; 下面这个例子我们自定义了一个 if 的表达式，功能和 scheme 的 if 一样;; 不用函数来实现 if 的原因是函数在调用时会对所有参数求值，但条件分支的俩分支不应该被同时求值;; 这里也显示了宏的一个常见用法，就是你需要「惰性求值」的时候就可以考虑使用宏(define-syntax my-if-sc  (lambda (stx)    (syntax-case stx ()             ;; 第二个参数暂时不用管，目前只需知道给个 () 就行      [(_ pred true-exp false-exp)  ;; 用 _ 来匹配并忽略 stx 中首位的 my-if-sc       (syntax        (cond [pred true-exp]       ;; my-if-sc 所在表达式被转译成了相应的 cond 表达式              [else false-exp]))]))) (my-if-sc (&lt; (* 7 8) 9) &quot;true&quot; &quot;false&quot;)   ;; 输出 &quot;false&quot;;; 另一个更好用的写法是 syntax-rules ，它更像 match ，所以更便于阅读，推荐优先使用;; 在 syntax-case 中，返回的表达式要用 syntax 之类的方式转成一个 syntax object（语法对象）;; 而用 syntax-rules 只需直接写要返回的表达式就行了，它在后台会自行帮你转换成 syntax object(define-syntax my-if-sr  (syntax-rules ()    [(_ pred true-exp false-exp)     (cond [pred true-exp]           [else false-exp])]))(my-if-sr (&lt; 2 3) &quot;true&quot; &quot;false&quot;)  ;; 输出 &quot;true&quot;</code></pre></li></ul><p>Macro（宏）和 Continuation 是两个对新手来说看似难理解，但实际很简单的概念。关于宏除了<a href="https://docs.racket-lang.org/guide/macros.html" target="_blank" rel="noopener">官方文档</a>之外，官方还推荐了另一篇有趣的文章来介绍：<a href="https://www.greghendershott.com/fear-of-macros/index.html" target="_blank" rel="noopener"><em>Fear of Macros - by Greg Hendershott</em></a></p><hr><h3 id="DrRacket-IDE-里的一些常用库"><a href="#DrRacket-IDE-里的一些常用库" class="headerlink" title="DrRacket IDE 里的一些常用库"></a>DrRacket IDE 里的一些常用库</h3><p>在 Racket 里你可以使用 <a href="https://docs.racket-lang.org/guide/module-require.html" target="_blank" rel="noopener">require</a> 来载入各种 <a href="https://docs.racket-lang.org/guide/module-basics.html" target="_blank" rel="noopener">Module</a>（模块/库）。相当于其他语言的 <code>import</code> 操作。你可以自己创造 Module ，不过这里主要介绍一些 DrRaket 自带的常用 Module：</p><ul><li><p>有关数据结构的 Module - 队列 <a href="https://docs.racket-lang.org/data/Imperative_Queues.html" target="_blank" rel="noopener">Queues</a> </p><pre><code class="lang-scheme">;; 调用 require 载入库 data/queue(require data/queue);; (make-queue) 可以创建一个空队列（empty queue）- 队列创建后开始是空的，之后可往里加东西;; 定义一个队列 q1(define q1 (make-queue));; (enqueue! queue value) 可将元素添加到队列的【末尾】;; 往队列 q1 中依次添加数字 1 、2 和 3(enqueue! q1 1)(enqueue! q1 2)(enqueue! q1 3);; (enqueue-front! queue value) 可将元素添加到队列的【开头】;; 往队列 q1 的开头添加数字 9(enqueue-front! q1 9);; 调用 queue-&gt;list 可以把队列转换成链表（list）(queue-&gt;list q1)          ;; 输出 &#39;(9 1 2 3);; (dequeue! queue) 可以将 queue 中的第一个位置的元素移除，并返回(dequeue! q1)             ;; 输出 9</code></pre></li><li><p><a href="https://en.wikipedia.org/wiki/Delimited_continuation" target="_blank" rel="noopener">Delimited Continuation</a> - <strong>shift / reset</strong></p><pre><code class="lang-scheme">;; 调用 require 载入库 racket/control - 这样就能使用 reset 和 shift 了(require racket/control);; shift 后面的 k 的内容也是当前位置的 continuation(reset (shift k (k 1)))  ;; 输出 1 - k 是之后要做的事，之后啥也没做，所以 k 相当于 identity 函数，(k 1) 作为 (reset (shift k ...)) 的结果输出(reset (shift k 1))      ;; 输出 1 - 没有调用 k ，于是上下文被丢弃，1 作为 (reset (shift k ...)) 的结果输出(reset (* 3 (+ 1 (shift k (+ 1 (k 2))))))         ;; 输出 10 - 这里内部的 (+ 1 ...) 没被丢弃，可以对比一下 call/cc(reset (* 3 (+ 1 (shift k (set! saved-k k) 2))))  ;; 输出 2 - 丢弃了 reset 到 shift 之间的计算（上下文）- 没有调用 k ，k 所代表的的上下文也就被抛弃了(saved-k 3)              ;; 输出 12 - 此时的 saved-k 相当于函数: (lambda (x) (* 3 (+ 1 x)))(reset (* 3 (+ 1 (shift k1 (+ 17 (shift k2 (k2 2)))))))    ;; 输出 19 - k1 代表前面的操作，算出的 19 作为了前面 reset shift 的值(reset (* 3 (+ 1 (shift k1 (+ 9 (shift k2 (k2 (k1 2)))))))) ;; 输出 18 - 可以看到，调用 k1 并不会丢弃第二个调用 k2;; 如果单独用 reset 则 (reset exp)会正常输出表达式 exp 的值;; 如果单独使用 shift 则此时的 shift 和 call/cc 类似，调用 k 会丢弃 shift 内部的上下文;; 强烈不建议单独使用 shift ，因为程序会出现不符合预期的奇怪行为，reset 和 shift 要成对使用(+ 1 (* 2 (shift k (k 3))))       ;; 输出 7 - 这里的 k 相当于 (lambda (x) (+ 1 (* 2 x)))(+ 1 (* 2 (shift k (+ 4 (k 3))))) ;; 输出 7 - 内部的 (+ 4 ...) 被丢弃了</code></pre></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨一工连载第 4 话：最高端的地方</title>
      <link href="/2022/02/21/yang-yi-gong-series-4/"/>
      <url>/2022/02/21/yang-yi-gong-series-4/</url>
      
        <content type="html"><![CDATA[<p><strong>哪里是「最高端的地方」？</strong></p><blockquote><p>定理：家里的装修风往往会趋近主人自认为见过最高端的地方。</p><footer><strong>Stephen Chu</strong></footer></blockquote><hr><p><strong>这篇讲装修吗？这可是个复杂的活，先说一下普通玩家从哪里开始吧。</strong></p><p>和买保险类似，从一个发人深省的问题开始：「业主的命值多少钱？」</p><hr><p><strong>这么毛骨悚然干嘛？你就直接说「先确定预算」嘛。</strong></p><p>预算 = 时间 + 精力 + 钱，而不简单只是「钱」。</p><p>玩家们对生活的不同观念导致了投入的差异，这个很好理解。不过对于预算，通常的理解只<strong>局限</strong>于「钱」，比如每平米 700 元。其实在装修上，最影响效果的还是<strong>时间和精力</strong>的投入。「钱」是最简单的，也是最偷懒的。因为装修的过程中，有太多<strong>用钱买不到</strong>的东西了。</p><p>整个装修的作业都要围绕着「<strong>预算</strong>」来进行，以它为中心。</p><hr><p><strong>用钱还买不到？比如？</strong></p><p>比如「<code>知道自己要什么</code>」就是花钱也解决不了的。</p><hr><p><strong>是说要确认装修过程中的各种供应商吗？瓷砖、门窗、柜子……</strong></p><p>也许会更加地抽象，关系到玩家们心中「什么才是<strong>真正的</strong>自由？」</p><p>实际上，玩家们的<strong>需求</strong>并不那么显而易见，需要耐心地去探索和挖掘，甚至对市场进行调研。每当了解到<strong>新的信息</strong>之后，需求还会<strong>进化</strong>。只有知道自己<strong>想</strong>要什么，<strong>能</strong>要什么，才能更顺利地确认各家供应商：要不要封窗？买哪家的窗？哪家的瓷砖？什么颜色？哪家的白电……</p><p>之后还要<strong>协调</strong>这些供应商，负责他们之间的<strong>对接和沟通</strong>工作。比如规划何时进场、尺寸多少等等。<br>总之，装修的主要精力会消耗在<strong>确认需求</strong>这个环节。该环节很可能会贯穿装修的<strong>全程</strong>。</p><blockquote><p>一大解千愁。费用换大一点的户型，比任何装修上的花费舒适度更高。厨房大了拐角拉篮这种特殊五金也用不上了，卧室距离远了隔音门也用不上了，多几个卫生间以后四分离也不用做了，连定制化产品都能变的不需要那么定制化了……你首先值得拥有更大的房子，装修这种锦上添花的事情，人间不值得。</p><footer><strong>王大喵</strong></footer></blockquote><hr><p><strong>会不会弄得太复杂了？施工队的项目负责人经验那么丰富，让他帮忙搞定全部这些就好啦。</strong></p><p>装修行业鱼龙混杂，需要<strong>做足功课</strong>才能找到靠谱的施工队。</p><hr><p><strong>做功课？听起来要消耗很多精力？</strong></p><p>家装行业的平均专业水准还没高到能让人可以偷懒的程度。</p><p>实在嫌麻烦可以直接就在第一家做。<strong>不对比</strong>就不会有<strong>伤害</strong>。装修这东西，<strong>知道得越少越容易感到幸福</strong>。找大品牌，服务通常足以保障各环节没啥<strong>大</strong>问题。</p><p><strong>柜子设计师</strong>出图后，交给施工队就行了。如果不想给钱，就凭借记忆回忆<strong>柜子设计师</strong>的布局，描述给施工队听。然后就耐心等待完工、付尾款、入住。</p><hr><p><strong>实在不想花时间做功课的话，怎么找施工队？</strong></p><p>比较靠谱的是用「工艺筛选法」，也就是一叶知秋。具体来说就是看施工队<strong>默认</strong>的施工工艺是否属于那些<strong>困难麻烦的工艺</strong>。这意味着他们习惯于处理<strong>复杂</strong>。比如看墙面工艺是否会<strong>默认</strong>采用冲筋找平，或者贴砖工艺是否<strong>默认</strong>瓷砖粘接剂薄贴等等。如果他们对某项<strong>高难度</strong>工艺是<strong>默认</strong>就会做的，而不是所谓的“加钱也可以做”，这样的施工队大概率靠谱。</p><blockquote><p>「加钱可以做」的意思其实就是「你出学费我们可以试试」。</p><footer><strong>王大喵</strong></footer></blockquote><p>那当然啦，靠谱的施工队价格也会很高，各位玩家量力而行。但始终推荐低预算的施工也争取让靠谱施工队来进行。</p><p>普通住的话，事情就简单。个性化需求越多（如全屋智能、美学追求）才会越折腾，要找专业的<strong>住宅</strong>设计师。这对<strong>预算</strong>有更高要求。预算 = 时间 + 精力 + 钱，而不简单只是「钱」。</p><hr><p><strong>怎么判断一个设计师是否优秀？</strong></p><p>「<code>对所有装修作业环节、各主流产品使用体验及其供应商渠道、施工工艺都十分了解</code>」的<strong>住宅</strong>设计师可以算优秀。出图纸、出效果只是<strong>非常基础</strong>的操作。而那些能让业主在省心供应链的同时，做到把钱花在刀刃上的<strong>强预算控场</strong>设计师，<strong>才值得</strong>掏钱。否则还是全屋制定的<strong>免费</strong>设计师划算。</p><p>市场上极少有<strong>单个人</strong>具备如此全面的综合能力，一般是一个团队才能做到。这也是为什么优秀的设计价格高昂的原因：整个团队的成员都要吃饭。</p><blockquote><p>……客户需求是什么？设计难点在哪？怎么化解这些难点？动线为什么这样规划？为什么这个非常重要？为什么那个更重要……所谓设计的本质，就是用不同的手法复刻一些好的空间体验……</p><footer><strong>王大喵</strong></footer></blockquote><p><a href="https://weibo.com/u/5838373206?refer_flag=1005055013_" target="_blank" rel="noopener">@大喵一号M</a> 是我见过最接近「全栈」的硬核<strong>住宅</strong>设计师（是的，史老师和本间老鬼之流也差点意思）。虽然她偶尔表达上让人困惑（也许是强者缺少耐心？也许干脆就是她认知错误？）、虽然一年只做 7 个项目<strong>令人讨厌</strong>（或者说令人放心？）、虽然异地项目 200 平米起让人不适（或者说慈悲为怀？），不过你可以把她理解为装修设计界的<strong>壁挂马桶</strong>，瑕不掩瑜。各位<strong>高预算</strong>玩家可以从<strong>刷</strong>她的微博开始你们的折腾。各位马上就能体会到预算<strong>不只是钱</strong>。</p><p>其实<strong>市场上</strong>基本不存在真正「全栈」的家装设计师，这里的必然性是由「<a href="/2019/02/04/yang-yi-gong-series-1/">广度优先</a>」的技能树策略所固有的<strong>超高门槛</strong>决定的。能跨越这个门槛的“设计师”不会以「设计」谋生。从这个意义上，王大喵应该算是为中国最强的住宅设计师之一，鲜有对手（史老师和本间老鬼之流都差点意思）。</p><blockquote><p>……相比那些花了钱就能提升生活品质的设备和电器，你的生活其实没那么需要「设计」这个东西…………</p><footer><strong>王大喵</strong></footer></blockquote><p>值得注意的是，乔布斯时代的苹果公司能请得起设计师和工程师，彼时的诺基亚微软<strong>也</strong>请得起。这很大程度上暗示了玩家们<strong>自身的水平</strong>限制了他们装修效果的上限。其中部分原因是玩家自己是什么水准，能找到的最强设计师就是什么水准。另外的原因是，如果人生的密度过低，别说王大喵，你就是请来王大喵她爹，最终也是惨不忍睹。</p><p>所以，装修过程中请保持轻松，不必苛求。苛求它人，很可能就是在抱怨自己的水准。^_^</p><blockquote><p>我认为自己并不只是在说房子、在讲装修……我见过太多的房子……我所追寻的“美丽的家”，不过百之一二……即使有了更大的房子、更豪华的装修、更科学的设计，也不过只是拥有了升级版的“硬件”，它永远无法替代“软件”——居住者本身。</p><footer><strong>逯薇</strong></footer></blockquote><hr><p><strong>好的我总结下：普通玩家找全屋制定+施工队即可。省心的方式就是不去对比，对吧？</strong></p><p>对。装修要追求<strong>挚爱</strong>，而不是寻求<strong>共识</strong>。不必去羡慕其他玩家。</p><hr><p><strong>不对比的话，我花的钱会不会因此比别人多一些？感觉让施工队全权负责的话，他们会占我一些便宜？</strong></p><p>有什么问题吗？你花的时间精力<strong>少</strong>呀。相当于多花些钱购买了<strong>宝贵</strong>的生命。其他玩家的<strong>命贱</strong>呀，所以他们只能用<strong>廉价</strong>的生命去换取“省钱”又“满意”的效果啦。普通玩家要做的就是<strong>平衡</strong>消耗的资源精力和满意程度。归根结底还是个「<strong>预算</strong>」问题。</p><p>（预算 = 时间 + 精力 + 钱；而不简单只是「钱」）</p><hr><p><strong>我倒是觉得他们的生命不仅不贱，还特别值钱。正是因为生命价值高、密度高，他们才愿意多花时间精力来改善住宅，提高生产力和生活质量。</strong></p><p>你这个观点很容易得罪他人。</p><hr><p><strong>总之，想花钱少，就要多花时间精力；想少折腾，就要多花钱；都想少，只能靠运气；这么理解对吗？</strong></p><p><code>不太对。</code></p><p><strong>多</strong>花时间精力<strong>并不能</strong>让你<strong>少</strong>花钱，很可能会让你花<strong>更多</strong>的钱。这就是为什么<strong>知道得越少</strong>越容易<strong>感到</strong>幸福。</p><p>多花时间精力的唯一好处是让<strong>自己的需求</strong>逐渐清晰明朗，能把钱花在<strong>刀刃</strong>上。坏处就是“刀刃”容易<strong>增加</strong>很多。</p><hr><p><strong>好的。我先开干，有情况再来交流。</strong><br>一切顺利哈。</p><hr><ul><li></li><li></li><li></li><li></li><li></li><li></li></ul><hr><p><strong>唉~随便找了个柜子设计师就发现有太多细节需要操心了。先不说硬装的乳胶漆、瓷砖、门窗等等要选，家里各种影响水电点位和空间尺寸的设备已经让我头大。什么中央空调、分体空调、风管机、燃热、电热、洗碗机、集成灶……涉及的项目略多，每项还对应诸多品牌，让人眼花缭乱。都选顶级，钱又不够了。</strong></p><p>你对自己生命的「估值」是不是有点<strong>虚高</strong>了？至于这么全方位地呵护吗？</p><p><strong>知道得越少，越容易感到幸福</strong>。人生不只是「装修」，听设计师和施工队的建议买就行，省下来的精力去做更重要的事。</p><p>你说的这些“困难”只要拉一下预算表格，排一下优先级，自然就能直观地做出选择。如果你觉得不直观，就要去<strong>反思</strong>自己的<strong>需求</strong>、欲望和能力，或者投入精力想想「该怎样才能<strong>买得起</strong>？怎样才能<strong>兼得</strong>熊掌和鱼？」</p><p>先确定全屋的软装和设备更有利于统筹全局开支，避免「硬装」阶段花钱过多，导致直接影响生活的「软装」和「电器设备」则只好将就。</p><p>还是最开始那个话题：<strong>预算</strong>。了解和探索自己的<strong>需求</strong>是个消耗<strong>大量精力</strong>（预算）的过程。预算少可以不必<strong>过多</strong>地探索自己的需求。</p><blockquote><p>放弃幻想，轻装前行。</p><footer><strong>Stephen Chu</strong></footer></blockquote><hr><p><strong>还是想严肃地大干一场。全方位地教教我吧。</strong></p><p>前面已提到过，从「全屋定制」出发，让设计师在前期就介入规划空间是最好的。若是反过来，让全屋制定介入太晚，会很容易和<strong>已装好的设备</strong>（电位、水位、空调等）出现各种空间上的冲突。</p><p>这里要说一下成品家具。「<strong>成品家具</strong>」比「<strong>全屋制定家具</strong>」要更便宜、更好看，各项指标基本都优于「全屋制定」。选择全屋制定的玩家通常有 <strong>2 个</strong>优势：第一、家里的<strong>空间利用率</strong>能达到最佳水平。第二、有“免费”设计师提供布局图纸和全程相关咨询。不过选择成品家具需要自己全权负责搜索和把关，这又是一个关于时间精力，或者说关于预算，的话题了。</p><p>通过挑选你<strong>感觉合得来</strong>的设计师来确定全屋制定的供应商。因为装修<strong>全程</strong>你都需要和该设计师配合，所以只要感到设计师没耐心，建议就直接换人，不然彼此全程相互折磨，没有必要。</p><blockquote><p>……我也很欣赏这种诗和远方的设计理念，但是，XX、XXX、XXXX等等等，都是打起十二分精神也不一定能永久解决掉的苟且……说出来可能有点丧，住宅设计的本质是对居住其中的人负责，而不是对设计负责。</p><footer><strong>1988之王大喵</strong></footer></blockquote><hr><p><strong>人家就想问你嘛。分享一下工地开工之后你的操作呗？</strong></p><p><a href="https://weibo.com/u/5838373206?refer_flag=1005055013_" target="_blank" rel="noopener">王大喵</a>推荐了一些靠谱的施工方供各位无脑信任：</p><pre><code>1. 性价比窗帘商家：大胜-ID-WSWJWJT88-上海闵行；2. 湖南长沙通过南玻筛出来的靠谱封窗商家：方旭系统门窗服务商-ID-Fx8886zszp-湖南娄底-132-97471234；3. 北京靠谱工长：高健-ID-falajma-北京朝阳；4. 深圳靠谱工长：麦工-ID-mc130509-广东深圳；5. 吉博力排水靠谱供应商：Danny-ID-dannycys-上海闵行-淘-美好人生mhrs；</code></pre><p>若是你的设计规划图纸已经完成，即全屋「<strong>需求和预算</strong>」已经完全清楚。那确实到了正式开工的时刻：</p><ul><li><h4 id="打拆「砌墙」阶段"><a href="#打拆「砌墙」阶段" class="headerlink" title="打拆「砌墙」阶段"></a>打拆「砌墙」阶段</h4><p><strong>1、</strong>制定需要时间。<strong>封窗</strong>供应商进场量尺下单。规划燃热排气孔、新风管道口（避开燃热排气）、厕所排气扇、各房间开扇数量、类型以及玻璃（如磨砂）配置。飘窗的<strong>【上】沿窗框</strong>需要预留足够宽度，不然开扇会碰到吊顶。飘窗的<strong>【下】沿窗框</strong>也要预留足够宽度。因为台面可能铺垫子占用一些高度，然后窗帘不触碰垫子、玻璃要高于窗帘以提高遮光效果又要占一些高度。要让商家使用「<strong>耐候</strong>密封胶」而不是「结构胶」来做外框密封。阳台窗户重量每平方在 400 千克（公斤）以内。要和门窗商家确认不破坏外墙防水，尤其是换飘窗最容易破坏外墙（这也是为什么要慎换飘窗）。泥工阶段前要完成封窗；<br><strong>2、</strong>超过 16 升的大流量的热水器需要大气表。因为会排长队。所以在此阶段提前联系燃气公司更换 4 立方的<strong>燃气表</strong>（民用最大）。根据柜子布局移表。重新布置燃气管道。水电进场阶段要完成改表；<br><strong>3、</strong>邮寄需要时间。此阶段购买 HDMI 2.1 光纤线（对电视画面有追求才买）、六类网线以及信号线（调光灯具才需要的灯线）；<br><strong>4、</strong>邮寄需要时间。此阶段购买壁挂马桶的预埋水箱（如果是吉博力的水箱要注意购买 PVC 排水管配件，因为吉博力的 PE 管和 PVC 排水管由于热胀冷缩系数不同，不能混用）、龙头花洒<strong>预埋件</strong>（如果有）、前置净水器（追求水质才买，水电阶段需要安装）；<br><strong>5、</strong>水电进场阶段需要了解挂墙设备的「<strong>打孔位置</strong>」，所以最好提前购买卫浴花洒用于水电工参考走线走管；<br><strong>6、</strong>制定需要时间。此阶段购买所选<strong>灯具的预埋件</strong>（如果对灯光没需求，就没这东西。吊顶阶段需要预埋件）；<br><strong>7、热水器</strong>电控若是需要提前走线的，那么热水器在此阶段要完成型号确定，甚至完成购买；<br><strong>8、</strong>制定需要时间。<strong>入户门</strong>和隔音门此时下单。泥工阶段的最后需要安装入户门，以便完成入户区域的铺贴；<br><strong>9、</strong>调研确认全屋各处的「<strong>地漏</strong>」类型，最好能提前采购地漏给【水电进场】阶段的师傅做布管参考；<br><strong>10、</strong>购买电动晾衣杆，以便在水电阶段预留电位（地火零还是？），在吊顶阶段预留安装位置；<br><strong>11、</strong>所有进口的设备，比如卫浴、水槽等，都要提前了解到货时间。1 个月以上的都要考虑提前购买；</p></li><li><h4 id="水电「进场」阶段"><a href="#水电「进场」阶段" class="headerlink" title="水电「进场」阶段"></a>水电「进场」阶段</h4><p><strong>1、</strong>备货邮寄需要时间。此阶段购买全屋瓷砖、<strong>踢脚线</strong>、窗台石；<br><strong>2、</strong>全屋尽量采用<strong>6 分管</strong>（6/8 英寸 =19.05mm），在出水口有铜件丝扣的部分再转成 4 分管（4/8 英寸 = 12.7mm）。不用 4 分管的原因是水电工热熔管道的过程几乎是<strong>不规范</strong>的，这会使得 4 分管热熔后管的内部直径会缩小，导致水流受阻，「压降」明显。尤其是在全屋采用环路平衡接法的情况下，管道过长，热熔部位过多，水压「压降」更明显。总的来说就是提前为水电工<strong>不专业</strong>买保险。<br><strong>3、</strong>在全屋 6 分管的情况下，沟通冷热水是否能做环路平衡。环路平衡保证回水管、无死水、水压平均分配；<br><strong>4、</strong>卫生间干湿区<strong>共用</strong>「存水弯」，以便长期无水补充的干区地漏能通过「共享」，也获得存水弯隔离气味的功能；<br><strong>5、</strong>沟通<strong>二次排水</strong>施工工艺；沟通淋浴区长条地漏施工工艺；地漏要专门一条支线，不能和墙排管道的主干上，避免墙排流量过大，从地漏反水进入砂浆层。「<strong>洗衣机</strong>」排水处下水量非常大，很容易从地漏和排水管之间的缝隙漏水。所以洗衣机排水尽可能用「<strong>墙排</strong>」，地漏只适合温和排水，不适合大流量急排；<br><strong>6、</strong>若要<strong>马桶移位</strong>，最好使用墙排壁挂，排污管道做坡度。马桶排污管<strong>不能做存水弯</strong>，会堵；<br><strong>7、</strong>确保一条线管只走「<strong>一条</strong>」 HDMI 光纤线；确保 HDMI 先和网线为点对点<strong>活线</strong>而非死线；<br><strong>8、</strong>强电箱移位需要从总闸处<strong>重新拉线</strong>，保证电线的连贯完整性，不要续接。用 10 平方电线；<br><strong>9、</strong>使用标签机给每条线路<strong>打上标签</strong>，尤其是灯线回路和网线，方便后期接线找线；<br><strong>10、</strong>确保顶喷花洒的<strong>水管</strong>走线和花洒螺丝<strong>孔位</strong>不冲突；<br><strong>11、</strong>关于卫生间的「<strong>等电位联结端子</strong>」，如果浴室内全部管道都是<strong>非金属</strong>管道，只有一些孤立的金属部件（如金属毛巾架，金属扶手），则<strong>没有必要</strong>再做等电位联结，因为没有能传导危险电位的外部金属引入浴室。详细原理参考<a href="https://www.zhihu.com/question/328701277/answer/1482370146" target="_blank" rel="noopener">这里</a>。此外各个工地的现实情况十分复杂，未必严格执行施工标准，比如若开发商的等电位是「整层联结」而不是「分户独立」，那么别人家的等电位如果没做好，会让你家的等电位带电，引入危险；<br><strong>12、</strong>全屋插座尽量都确保 <strong>4 平方</strong>线，让线路功率上限在数十年生活中能保持足够的余裕；<br><strong>13、</strong>和电工沟通，接线位置尽全力保证<strong>锡焊</strong>环节（挂锡），而不是仅仅是绝缘胶布手工缠绕完事；<br><strong>14、</strong>预埋件和水管出水口埋件的时候一要确保能和<strong>贴砖后的墙面</strong>尽可能在同一平面上，避免出现热水、冷水孔深浅不一。否则后期花洒非常难装；<br><strong>15、</strong>厨房水槽下的「<strong>角阀点位高度</strong>」要根据主水龙头的管道长度来预留。建议角阀和龙头底部间的距离是龙头管道长度减 20cm 左右。有垃圾处理器时，厨房水槽<strong>不能用透明排水管</strong>，还要注意排水顺畅度问题（因为有厨余垃圾要排污）；<br><strong>16、洗衣机和干衣机</strong>的排水点位手要够得到，方便检修。两者还有<strong>微蒸烤箱</strong>的电位都不能在机子背后，手要够得到，还要方便拔插。<br><strong>17、</strong>确保镜灯的安装孔位和线管位置不冲突，以免后期打孔打坏线管；<br><strong>18、</strong>灯信号的 DALI 总线要确保每个射灯的点位都要「<strong>有进线有出线</strong>」，也就是两条线。这样总线上的每个灯孔位都是小型检修口，便于后期检修。<br><strong>19、</strong>用袋子之类的捆绑「<strong>保护线缆</strong>」，否则「泥工进场」阶段会弄脏甚至弄坏；<br><strong>20、</strong>管线机的位置要布置 <strong>2 根「线管」</strong>通到水槽底部。后期一根走连接直饮水管道，另一根走电线。管线机的电源线要拆机或剪断后重新接线，不然无法穿过线管。这 2 根线管不能有 2 个以上的拐弯，否则后期难穿电线和水管。管线机不能距离直饮水机太远，否则<strong>软管太长会有存水</strong>；<br><strong>21、</strong>根据所选设备型号和自己需求，可能要确保燃气热水器在屋内电控的信号线和点位有预留；<br><strong>22、</strong>确保各房间空调「<strong>挂机尺寸</strong>」，以便提前开槽打孔，预留隐藏电线和管道的位置；<br><strong>23、</strong>注意定位地面「<strong>门吸</strong>」的点位，线管要避开，不然后期安装门吸的时候打孔会破坏线管；<br><strong>24、</strong>水电结束后，阳台<strong>系统窗</strong>进场安装。封窗要在贴砖阶段前进场。这样铺砖阶段就可以直接收边，窗台石也可以根据窗框位置铺贴。铺砖要注意给吊机暂时空出位置，否则有压坏砖的风险。窗户安装位置不能遮盖建筑的「滴水线」。如果建筑没有滴水线，就去淘宝搜索购买自己增加。检查窗台外沿坡度是否有积水隐患，如果坡度<strong>内倒</strong>则需要重新修正坡度。修正坡度时不能堵塞<strong>型材排水孔</strong>；<br><strong>25、</strong>购买「<strong>静音棉</strong>」对卫生间等下水管道进行包管（不但要包立管，更要包横管，横管是主要噪音来源；一定要用<strong>胶带绕圈</strong>勒紧隔音棉——任何隔音措施，密封都是大前提）。最大程度减小楼上排水的噪音。泥工阶段前要完成；<br><strong>26、</strong>因为接下来是吊顶，所以此阶段结束后<strong>中央空调</strong>进场安装。并且一定要在<strong>吊顶前通电调试</strong>。不但要确定每个风机<strong>出风正常</strong>，还得确保<strong>制冷功能正常</strong>，顺便看一下<strong>冷凝水管通畅度</strong>，中奖概率要排除，不过份相信品牌，安装水平也有高下，以免发生拆顶惨剧；此外潮湿地区（比如海南），出、回风口得用 ABS 材质，金属材质的会结露；中央空调排水管尽量接入室外排水管，必须接入室内排水管，尽量接入管路自带U型弯的常用地漏/排水，日常用水就可以保证水封高度，防止浊气顺空调排水管进入室内。机器出风口视情况安装好纳米帆布（<strong>方头燕尾螺丝</strong>固定，重叠处大于 10cm），以便后期连接吊顶出风口。</p><p><code>「水电阶段」结束后，千万记得拍摄现场照片以便后续环节能随时查看线管水管点位和路径，避免破坏它们</code></p></li><li><h4 id="木工「吊顶」阶段"><a href="#木工「吊顶」阶段" class="headerlink" title="木工「吊顶」阶段"></a>木工「吊顶」阶段</h4><p><strong>1、</strong>「吊顶」在「铺砖」阶段之前是为了保护瓷砖不被梯子和各种吊顶材料弄坏。吊顶师傅会使用梯子频繁移动。<br><strong>2、</strong>确保卫生间吊顶的高度和顶喷花洒<strong>不冲突</strong>，否则花洒可能装不上；<br><strong>3、</strong>拉尺作为照片中的参考，然后<strong>拍照</strong>确定关键点位的轻钢龙骨布局，以便后期窗帘轨道、灯具、音箱安装；<br><strong>4、</strong>确认洗手间的排气方案。厨房<strong>烟管</strong>和洗手间的<strong>排气管</strong>都需要在此阶段吊顶完成前预埋；<br><strong>5、</strong>购买更好的<strong>烟道止回阀</strong>，把原始止回阀换掉。止回阀的尺寸要根据你选定的抽油烟机来选择。烟道旁边留好<strong>检修口</strong>，随时准备更换新的止逆阀。因为随着经年累月的使用，止逆阀的密封件是会老化的。而且楼顶排烟口也会年久失修，排烟口径逐年缩小，烟道内部压力也会越来越大，密封件稍微有一丝丝的老化都会止逆失效。定期更换止逆阀和督促物业定期维护排烟口双管齐下才能解决烟道污染问题。这也是为什么<strong>公共烟道</strong>的<strong>高层</strong>用户不建议做纯开放式厨房：一旦返味，封闭厨房还可以关门开窗，甚至打开油烟机，产生的油烟和噪音也不至于影响其他区域。封闭式中厨搭配开放式西厨的组合方式是最合理的。<br><strong>6、</strong>确保无边框筒射<strong>灯的预埋件</strong>按图纸说明安装；<br><strong>7、</strong>封吊顶前把自家厨卫阳台顶上的别人家的「<strong>下水检修口</strong>」检查一遍。尤其是马桶下水的检修口盖，<strong>拧紧</strong>它们。再去<strong>楼下</strong>检查下自家的「下水检修口」，<strong>拧紧</strong>它们。减少一些意料之外的不必要的麻烦。这个事故中招率还挺高的。<br><strong>8、中央空调</strong>要在吊顶阶段前进场完成内外机的安装。普通挂机空调要在吊顶阶段确定藏管藏线的方案。<br><strong>9、</strong>购买「吹尘枪」进行吊顶清洁，让灰尘量始终处于最低。吊顶师傅一般也有类似「吹尘枪」的工具；<br><strong>10、</strong>门窗进场。要千万注意旧窗户旧阳台的拆除不能破坏外墙防水，尤其是换飘窗（这也是为什么要慎换飘窗）。外墙由<strong>防水层</strong>、<strong>保温层</strong>和<strong>外立面</strong>三层构成，关键是<code>不能破坏「外墙」防水层</code>。</p></li><li><h4 id="泥工「铺砖」阶段"><a href="#泥工「铺砖」阶段" class="headerlink" title="泥工「铺砖」阶段"></a>泥工「铺砖」阶段</h4><p><strong>1、</strong>确保卫生间 3 mm 的砖缝（3 mm 缝对应 9mm 厚度的砖，砖越厚，缝隙要留得越大，这样填缝剂才能顺利<strong>填实</strong>，接触到水泥砂浆层），「地压墙（地砖压墙砖）」和「墙压地（先贴地砖，墙砖压地砖）」的铺贴方式<a href="https://weibo.com/5838373206/LCdl4uita?from=page_1005055838373206_profile&amp;wvr=6&amp;mod=weibotime&amp;type=comment#_rnd1657902177860" target="_blank" rel="noopener">各有优劣</a>，都需要填缝防止<strong>积水</strong>渗入砂浆层。地压墙更容易填缝，墙压地更容易防止地面水渗入立面的墙体导致相邻房间受潮，视觉上墙压地更好；<br><strong>2、</strong>阳台窗台处的铺贴也需要「地砖压墙砖」的铺贴方式，并且也是 3 mm 的砖缝（同样看瓷砖厚度确定缝隙）；<br><strong>3、</strong>沟通确认<strong>长条（线性）地漏</strong>安装工艺、砖的相关坡度等。地砖和地漏边缘之间也要留足缝隙便于后期填缝；<br><strong>4、</strong>和施工方确认墙砖的铺贴工艺，并根据瓷砖供应商的铺贴图确认铺贴方式（比如从房里到入户门）；<br><strong>5、</strong>沟通生活阳台坡度方向，注意洗衣机<strong>底部</strong>必须<strong>水平</strong>，不能有坡度，否则洗衣过程晃动剧烈；<br><strong>6、</strong>沟通卫生间瓷砖坡度方向，确保排水顺利，避免积水；<br><strong>7、入户门</strong>在铺砖快完成时才进场安装。要规划好进场时间，若装得早，搬砖、水泥、沙子等过程会压坏入户门，装的晚会和泥工收边进度冲突；</p></li><li><h4 id="油工「刷墙」阶段"><a href="#油工「刷墙」阶段" class="headerlink" title="油工「刷墙」阶段"></a>油工「刷墙」阶段</h4><p><strong>1、</strong>此阶段<strong>之前</strong>不能刷「墙固」，避免灰尘使其失效。墙固采用界面剂而不能是“黄墙绿地”；<br><strong>2、</strong>吊顶阴角处用马贝 112 乳液补缝材料，补完直接刷腻子。沟通避免使用用「阴角条」；<br><strong>3、</strong>制定需要时间。刷墙结束的第一时间让<strong>柜子设计进场复尺</strong>，柜子下单；<br><strong>4、</strong>制定需要时间。刷墙结束的第一时间测量<strong>全屋窗帘尺寸</strong>，窗帘下单。窗帘挂钩「<strong>顶部</strong>」要距离帘布「<strong>顶部</strong>」13mm 以上，可最大程度遮光；<br><strong>5、</strong>有淋浴房的，让<strong>淋浴房</strong>商家进场量尺。制定时要注意磨砂玻璃面的朝向。磨砂面不好清理，最好朝向不易脏的空间。淋浴房的平开门要<strong>外开</strong>。因为淋浴区封闭、高温、地面湿滑，属于晕倒、滑倒的高发区域，且淋浴区又空间狭小。一旦有人晕倒在内，会挡住<strong>内</strong>开门的开启空间，不把玻璃门拆掉无法救助，所以必须<strong>外开</strong>。如果没有外开空间，则不建议使用平开门；</p></li><li><h4 id="瓷砖「填缝」阶段"><a href="#瓷砖「填缝」阶段" class="headerlink" title="瓷砖「填缝」阶段"></a>瓷砖「填缝」阶段</h4><p><strong>1、</strong>厨房卫生间等「湿区」选<strong>深色</strong>的填缝剂，避免白色发黄变色；<br><strong>2、</strong>填缝完成后，<strong>空调</strong>进场完成最终安装和调试。确保安装师傅抽真空。1 匹空调（至少） 10 分钟，2 匹空调（至少） 20 分钟，3 匹空调（至少） 30 分钟，中央（至少）2 小时；</p></li><li><h4 id="「柜子」进场阶段"><a href="#「柜子」进场阶段" class="headerlink" title="「柜子」进场阶段"></a>「柜子」进场阶段</h4><p><strong>1、</strong>避免用柜子的默认胶。要购买专用的<strong>中性</strong>防霉玻璃胶。酸性玻璃胶防霉效果好，但不能用在金属的附近。<br><strong>2、</strong>邮寄需要时间，检查各插座点位，提前<strong>网购</strong>五金店没有的 15cm 的螺丝和 86 盒修复器；<br><strong>3、</strong>「柜子」和乳胶漆墙面之间的缝隙<strong>不能</strong>使用「玻璃胶」，要用类似马贝 112 乳液补缝材料的东西填缝；<br><strong>4、</strong>使用「吹尘枪」清洁插座点位的 86 盒内部灰尘；<br><strong>4、</strong>柜子完成后，推拉门、轨道门开始进场安装；</p></li><li><h4 id="「软装」进场阶段"><a href="#「软装」进场阶段" class="headerlink" title="「软装」进场阶段"></a>「软装」进场阶段</h4><p><strong>1、</strong>购买专用的<strong>发泡剂</strong>用于安装室内门和隔音门；<br><strong>2、</strong>「门框」和乳胶漆墙面之间的缝隙<strong>不能</strong>使用「玻璃胶」，要用类似马贝 112 乳液补缝材料的东西填缝；<br><strong>3、</strong>洗碗机的水管不能加长太长，否则使用过后，管道里存水会过多，影响水泵的排水能力；<br><strong>4、</strong>洗衣机底部不能加「增高垫」，要保持洗衣机原始标准尺寸 850mm 高。增高垫会让洗衣机不稳固，工作时晃动厉害；</p></li></ul><hr><p><strong>没想到确认完需求后，还有这么多琐碎的细节。我生平见过最高端的地方也就是「快捷酒店」。似乎还是老实当个普通玩家让施工队负责剩下的比较好呀。</strong></p><blockquote><p>……苦海无涯，不要恋战，速速通过。</p><footer><strong>王大喵</strong></footer></blockquote><p>人生不只是「装修」，有大把更精彩、更具重大意义的事值得投入。装修太完美，人生就不完美了。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故事与事故-计算机科学</title>
      <link href="/2020/04/14/ian-cs-course-stories/"/>
      <url>/2020/04/14/ian-cs-course-stories/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript-的设计错误"><a href="#Javascript-的设计错误" class="headerlink" title="Javascript 的设计错误"></a>Javascript 的设计错误</h3><p>下面这个示例代码中，变量 x 和 y 由于只在函数体中可见，所以在函数外部对其求值时会显示错误。</p><pre><code class="lang-Javascript">function f(x) {return x * x;}function g(x) { var y = 2; return x * y;}f(3);  // 输出 9x;     // 输出 &quot;Can&#39;t find variable: x&quot;g(3);  // 输出 6y;     // 输出 &quot;Can&#39;t find variable: y&quot;</code></pre><p>稍微更改一下 <code>g(x)</code> ，去掉函数体中的关键字 <code>var</code> 。在调用一次 <code>g(x)</code> 之后，函数外部就能看到 y 的值了。</p><pre><code class="lang-Javascript">function g(x) { y = 2; return x * y;}g(3);  // 输出 6y;     // 输出 2</code></pre><p>这便是 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">Javascript</a> 语言的设计错误之一：写了 var，这个变量就只在函数内部可见。否则直接写 y = …，它就是“全局可见”。这样的代码会有隐患，会在今后引起程序内部值的错误（例如若有个外部定义的变量和某个函数里的变量重名，程序运行起来就容易发生逻辑错误，因为函数里的定义覆盖了外部的定义）。</p><p>解决方案：写 Javascript 的时候应该主动忘记没有 <code>var</code> 关键词的写法，在所有变量声明语句里都写上 <code>var</code> 。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>言语之曰</title>
      <link href="/2020/04/14/fun-quotes/"/>
      <url>/2020/04/14/fun-quotes/</url>
      
        <content type="html"><![CDATA[<p><strong>Ian：</strong>……它完全没有防止你什么…两个人同时写啊之类的事情。就是说，这个事情它不管的。它只管这个内存到后来要释放掉，而且只能有一个释放。你不能多次释放。差不多这样……那至于多线程的时候，你要怎么处理这种（读写）冲突事情，那就是你自己的事情了。</p><p><strong>Ian：</strong>……这个…这个有可能开头有点烧脑，但是你用惯了之后你就会发现这个实际上…挺清晰的…没有什么…不像 Rust 那个什么，你两个解引用你都不知道它在干什么。</p><p><strong>Ian：</strong>我觉得它这个设计是碰出来的。都没想清楚是怎么回事。</p><p><strong>Ian：</strong>……你不觉得这样很危险吗？就是…程序员写成什么样就应该是什么样…它自动给你加一些解引用。就是隐式的东西太多了，就容易…就不明白了。到后来你们就会…乱碰，说：“啊~这个地方…为什么加一个这个就能过了？啊？它为什么这个地方不加这个就不能过？然后呢这个把这个取掉，然后又可以编译过了…”到后来就碰来碰去碰对了，就不理解。</p><p><strong>Ian：</strong>我打算给你们加一节课，把 C++ 的这个做法讲一下。这样我们就有一个对比了。然后，有对比就有伤害了……所以在这个方面我觉得 C++ 还是做得更好一点的。</p><p><strong>Ian：</strong>我感觉它那个……看上去它好像有很多新的概念，其实它没有什么新的概念。它这些东西都是在其他语言里面有的，只不过其他语言没有设计成这个样子。</p><p><strong>Ian：</strong>……这样太难懂了，它就说，我要自动给你加一些解引用上去，让你的代码看起来简单一点。但是，那只是看起来简单一点，不等于…你就能理解你的代码了。这种自动解引用就会让你…造成你的困惑。</p><p><strong>Ian：</strong>就是它……隐含的自动干的事情太多了，我觉得这个 Rust 语言。自动做了太多的事情那个程序员他就不知道这是什么回事了对吧。所以我觉得这些东西还是应该是显式的，不应该…自动解引用。</p><p><strong>Ian：</strong>C++ 完美地解决了我对 Rust 的不满……但 C++ 有个讨厌的问题就是，出错信息太难看了。</p><p><strong>Ian：</strong>这个课听完之后你们应该会发现 <strong>Rust</strong> 的<a href="https://doc.rust-lang.org/book/title-page.html" target="_blank" rel="noopener">文档</a>其实写得很不容易理解。</p><p><strong>Ian：</strong>……如果代码都得这样写的话，你的那些函数…要把你写得很头痛。所以，这显然不是一个解决方案。只是告诉你这…这个移动这个…这个语义是怎么进行的。</p><p><strong>Ian：</strong>你要付出表达能力的代价，来满足…来达到它可以好像自动把类型都给你推导出来的这种幻觉。结果你的代码为了能够表达你想要写的那个思路，你就要绕一个弯子才能写出来。所以我不觉得它的这个类型推导是个什么好东西……但是总有一些人他很迷信这个类型推导。因为他也不知道类型推导是怎么回事，他也没有实现过这些东西。他就觉得好神奇啊，我可以不写类型，多好啊。但是代价蛮大的。</p><p><strong>Ian：</strong>……就是很多本来你可以…Java 里面你可以写的代码，你到 Haskell 里面就不能写了。就是因为你那样写了它就推导不出类型。那并不是…因为你的思路有问题或者是你不应该写那样的代码，而是因为它的这个类型推导是有局限性的。它为了能够反着推出这个类型，它就规定了这样的代码、这样的代码你不能写，这种子类型关系你不能有。呵呵~</p><p><strong>Ian：</strong>……但你们不要以为这个…它这种类型推导是什么好东西。就你这里不写类型，然后它给你推导出来。这样的代价其实蛮大的。</p><p><strong>Ian：</strong>你就要找到你的 bug 在哪里。你把它修好，你这个异常就不会发生了。不会发生了你又 try-catch 它干嘛？然后你 catch 到它你又能干嘛？对吧。你啥都做不了，因为那是你的 bug 。呵呵……下标越界这个异常，你 catch 它是没有意义的。</p><p><strong>Ian：</strong>……然后呢，我不是去把这一行（代码）改对，（而是）我在这里去 catch 这个异常，然后处理这个异常，你觉得这样合理吗对吧？正确地处理下标越界的办法，就是你写出的代码就不应该下标越界。</p><p><strong>Ian：</strong>反正它们这些语言都是……有些时候它会学到一些经验教训，但是呢它又加进自己的一些误解。嗯…对，比如说 C# 。你看到它把这个（Type Erasure）改进了，学到了历史的教训，你就以为它都做对了，其实它…Java 已经做对的东西它却没有做对，对吧。就是…C# 它没有那个 checked exception 。</p><p><strong>Ian：</strong>总的说来，就是说这个 Java 的 <strong>JVM</strong> 里面它其实没有这个泛型（Generics）。只是说你这个编译器能看到这个东西。但是它运行的时候它其实是没有的。因为最初 <strong>JVM</strong> 就没有这个东西，后来可能又加不进去了。加不进去它就只有把它叫做 <strong>Type Erasure</strong> 。就是说「编译之后它（类型）就不见了」。然后你还以为它是什么很先进的功能。</p><p><strong>Ian：</strong>如果你去查这个 <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html" target="_blank" rel="noopener">Type Erasure</a> 的话，你还以为它是一个 feature 。但是我觉得它就是一个历史遗留局限。然后呢，被当成 feature ，哦不，呵呵，被<strong>宣传为</strong> feature 。（你）还以为 erasure 是 Java 专门实现的一种功能，它其实就是一个没有完整实现的 Generics 的系统。所以这个代码编译以后，这个 <code>T</code> 的这个东西在 <strong>JVM</strong> 里面是不存在的。</p><p><strong>Ian：</strong>……就是为什么加了这个泛型之后，它才报这个错，对吧。你没泛型的时候，它为啥就没这个错？所以这个就是一个……我感觉就是这个 Java 它这个…它的类型系统的实现…其实它并不是一个很完善的实现。因为它最初没有这些东西，后来又加进去。加进去它的 JVM 又没法改了。为了兼容它以前的代码，所以 Java 有所谓的 <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html" target="_blank" rel="noopener">Type Erasure</a> 就是这个原因。</p><p><strong>Ian：</strong>像 Haskell 之类的有类型的函数式语言它其实就是这个 interface （Java interface），只不过它把它叫另外一个名字（type class）。所以你不要觉得这个东西是面向对象语言才有的。它是一种……其实是一种通用的、制造抽象的思想。</p><p><strong>Ian：</strong>有些东西吸取了教训，但又加进了自己的一些误解。</p><p><strong>Ian：</strong>你看它（<a href="https://github.com/features/copilot" target="_blank" rel="noopener">Copilot</a>）好像能猜出我想写什么，我都没打 <code>fib</code> 呢，它就知道我下一步要写 <code>fib</code> 了。就这个东西比较危险啊。你打的代码它全都看去了，它还知道你下一步要打什么。</p><p><strong>Ian：</strong>语言的特性有些是通过解释器实现的，有些是通过编译器实现的。</p><p><strong>Ian：</strong>所以这个灵活的定义有好处也有坏处。坏处就是，不知道这个东西怎么用的人，他就喜欢滥用这个，对吧。</p><p><strong>Ian：</strong>有些东西它虽然提供给你了，但是你最好不要用，对吧。</p><p><strong>Ian：</strong>你把它写成这种 <code>for</code> 循环，你就每次你都要利用你对这个 <code>for</code> 循环的“深刻理解”，你才能知道，啊~这个是先执行了，然后这个判断才执行。然后实际上你还不如你就写成 <code>while</code> 这种样子。</p><p><strong>Ian：</strong>好了，这样我们的解释器应该就写完了。虽然功能特别少，但是这是一个很有原则的解释器。</p><p><strong>Ian：</strong>为什么这个函数是递归的？因为它处理的数据是递归的。为什么这个函数里面有 3 个分支？因为它处理的数据就是有 3 种情况。就是这么简单。</p><p><strong>Ian：</strong>这些练习不一定要做完的，因为考虑到让有时间的同学多练习，所以数量很多。要是你为了做完而没有学到经验，就比较不划算了。</p><p><strong>Ian：</strong>很多设计错误都是因为设计者为了“用户方便”而产生的。结果带来的麻烦比方便多很多。</p><p><strong>Ian：</strong>现在就像你们刚学开车，我先拿了一辆有点毛病的便宜车给你们先掌握基本的油门和方向盘的使用。之后换一辆毛病少点的车照样可以开。没必要去记住这车的毛病。</p><p><strong>Ian：</strong>要记得，函数是一个动作，它含有它自己所需的一切信息。很多函数的参数是一个函数，它表示“具体要做什么”。它不是一个字符串，而是一个动作自己。</p><p><strong>Ian：</strong>一旦你做过了这些题，你对函数的理解就非常深入了。因为你完全用函数来表达了自然数（及其计算）。</p><p><strong>Ian：</strong>……先写 Call 吧，（解释器）三大要素……</p><p><strong>Ian：</strong>这里有一个信息流动的方向的问题。</p><p><strong>Ian：</strong>这样写破坏了 pair 的抽象层。你可以试试用 first, second 而不要直接把 pair 作为函数调用。</p><p><strong>Ian：</strong>嗯……好像你（@拉拉拉）不用这样表达吧？你看我都已经说清楚了是什么意思然后你又非得要说一句话，然后让大家来判断你说的话对不对，好像就没有什么意义了，对吧。你现在应该已经看明白了这是什么意思嘛。嗯…好~的~</p><p><strong>Ian：</strong>嗯…好了…那个……就是说……大家…嗯…你们看明白了是怎么回事就行了。然后，就是说如果你们要用自己的语言表达出来的话，却不一定是对的。所以，尽量试图不要去用语言表达这个事情，理解了就好。</p><p><strong>Ian：</strong>嗯…到了这个阶段我觉得应该……放开一点，不要总是想独立想出来。你比如说你…你拿了别人的想法之后其实你…也没有损失什么，你也不一定要照他的做，然后也许你能发现一些……做得…做得不一样的地方然后就…就够了。然后……重头想的话，真想不出来其实…效果并不好。</p><p><strong>Ian：</strong>所以…可能将来的那些……练习啊或者是…下了课之后你们要做什么，你们…就不用有那个限制了。然后也可以…搜索引擎里面搜一下……看看网上有没有其他的内容。嗯…但是要小心就是有…有那种…就是“啊”…说“啊~我来给你讲一下这个 call/cc …”什么的，然后就…噼里啪啦打了一堆代码出来然后…结果那代码又不好。然后你就…被误导了。</p><p><strong>Ian：</strong>你可以想象这个 task …… task1 你在跑，对吧？然后到了某个时候你突然说停……停了之后你要回到哪去呢？是不是应该回到启动你的那个地方去？</p><p><strong>Ian：</strong>到现在你应该已经理解，是什么语言并不是由语法决定的。我可以有一个 Scheme 语法的 C 语言，但它仍然是 C 语言。</p><p><strong>Ian：</strong>我又开始看 <a href="https://mitpress.mit.edu/books/little-typer" target="_blank" rel="noopener"><em>The Little Typer</em></a>。发现有时候你必须已经理解它在说什么，你才能理解它在说什么。^_^</p><p><strong>Ian：</strong><a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a> 是一个好的操作系统，它只是缺少一个好的编辑器。</p><p><strong>Ian：</strong>…正好相反，真正可以发挥创造力的空间并不在底层的编译器一类的东西，而在更接近应用和现实的地方。</p><p><strong>Ian：</strong>如果你理解了句子是一个函数调用，那么你就会懂得何时该使用句号。很多中国人对句子没有清晰的概念和边界。本该是句号的地方他们却打逗号，所以你不知道他的句子到哪里结束。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲聊-计算机科学基础</title>
      <link href="/2020/04/14/ian-cs-course-gossip/"/>
      <url>/2020/04/14/ian-cs-course-gossip/</url>
      
        <content type="html"><![CDATA[<h3 id="关于表达式（有返回值）和语句（通常没有返回值）"><a href="#关于表达式（有返回值）和语句（通常没有返回值）" class="headerlink" title="关于表达式（有返回值）和语句（通常没有返回值）"></a>关于表达式（有返回值）和语句（通常没有返回值）</h3><p><strong>Super喵喵玄：</strong>举手提问，在给变量赋值的时候，没有返回值但是程序也要给出一个 undefined 这个是为了告诉我们这件事成功了么？是否还有其他的意义在里面。</p><p><strong>拉拉拉：</strong>是不是和 scheme 的 void 差不多？</p><p><strong>Ian：</strong>是的。就像 scheme 的 void 。只是表示这件事做完了。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研讨-计算机科学基础</title>
      <link href="/2020/04/14/ian-cs-ponderations/"/>
      <url>/2020/04/14/ian-cs-ponderations/</url>
      
        <content type="html"><![CDATA[<h3 id="研讨-1："><a href="#研讨-1：" class="headerlink" title="研讨 1："></a>研讨 1：</h3><p><strong> <code>function f(x) { return x*2; }</code> 是一个语句（statement），而 <code>(x) =&gt; { return x*2; }</code> 却是一个表达式（expression）。为什么？</strong></p><p><strong>我：</strong>这个时代的计算机会对<strong>表达式</strong>求值，于是可以认为<strong>表达式</strong>是有返回值的，进而通过是否有返回值来判断一个（串）符号，对计算机来说是否是<strong>表达式</strong>。<strong>语句</strong>只是声明一件事情，通常没有返回值（计算机一般会对语句的输入返回 <em>undefined</em> 字样，以表示没有返回值）。</p><p><code>function f(x) { return x*2; }</code> 没有返回值，且它的意思是定义（创造）一个函数，所以它是<strong>语句</strong>。<code>(x) =&gt; { return x*2; }</code> 的返回值是 <code>(x) =&gt; { return x*2; }</code> ，所以从返回值的角度它是个典型的<strong>表达式</strong>。</p><p><strong>老师：</strong>“回复 undefined 的都是语句，undefined 的意思是‘没有值’。<code>function f(x) { return x*2; }</code>等价于赋值语句。它创造了一个新的变量<code>f</code>，但这个动作本身没有值。被创造的变量<code>f</code>却是一个表达式，它有值。要区分‘创造变量的动作”和“变量本身’。”</p><p><strong>老师：</strong>“打个比方，‘鞋子’是有值的表达式，‘把鞋放进盒子里’却没有值，它是一个动作。”</p><p><code>注释1：尽管类似</code><a href="https://www.haskell.org" target="_blank" rel="noopener"><code>Haskell</code></a><code>的语言还能看到</code><a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="noopener"><code>Lazy evaluation</code></a><code>这样的惰性求值设计，不过老师提到人类在走了很多弯路、踩了很多坑之后总结出的设计结论是：要先对表达式求值，之后再进行下一步计算或者传递。应当认为“活性求值”（</code><a href="https://en.wikipedia.org/wiki/Eager_evaluation" target="_blank" rel="noopener"><code>eager evaluation</code></a><code>）比惰性求值（lazy evaluation）更科学。</code></p><p><code>注释2：有些语言的语句（statement）也有返回值。比如在</code><a href="https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language" target="_blank" rel="noopener"><code>Scheme</code></a><code>语言中，语句的返回值就是 void 。之所以这样，是因为 Scheme 的设计者希望该语言中不需要区分表达式和语句，这样整个语言的语法结构就非常简洁优雅，其解释器相比其他语言的解释器会少处理很多不必要的东西。</code></p><p><code>注释3：从字符上看虽然表达式 (x) =&gt; { return x*2; } 的返回值是它本身，其实不应简单认为是它本身。真实情况是我们输入了 (x) =&gt; { return x*2; } 这一字符串（a pattern of rules），然后计算机对该字符串求值（解释），就得出这个值是一个函数，于是计算机返回这个值，即这个函数。然后这个函数的输出形式被设计成相同的字符串。就好像我们输入数字 3 ，计算机返回数字 3 ，这两个 3 不是同样的 3 ，前者是以字符形式输入的表达式，后者是值（计算机对输入解释后的结果）。老师给的一个形象的例子是，我们输入的是榨汁机的图纸，计算机给我们的是一个真正的榨汁机（求值的结果）。区别这两者会对今后的思维模型有重要的作用。</code></p><p><code>注释4：该思考题中讨论的代码用的是 Javascript 语言。</code></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人小练习-计算机科学基础</title>
      <link href="/2020/04/14/ian-cs-basics-assignments/"/>
      <url>/2020/04/14/ian-cs-basics-assignments/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验">  <script id="hbeData" type="hbeData" data-hmacdigest="ee7975b1962e7a16a140cd4ec2b8d624de2101eb1ca62b7472f5807b2092fabc">8f3c52660547b7604c6f4bb801626506b22d0cfc6f9c2e6e164d5b5f09a9e3d841189e8fdf3a2d58c90248a8ad10e665674f8861bd980b29a280f9e13ced6a77e04c5cf9013774f64b4b28bcee9358271e0bbe77a85dcbbd54d14a1b9da3c8d1eb22256bd8cb620674a48cadf3551927fa17a1e8f70483e71bfa8cc4e8383171950e2b97ffe4532b70d23a890f93076400b229c6f51f07f79335fe2fd4f8fd6a5d88f0ec00ce30e980f8ad4fd0b3b871791f2bfdd6dc4f1fdb1ff2682144723290ec271fe7ca5f313dcc7a58bd459a8a5ec0b3dd0dd42a3ade86fee8a526055817c558339acde024ca1e0753d08e1c605af06899ca1a485904e3def7213bd5c2fda6e3a7dbd0d19492b509be7a0f23a7ddc2f4a793553690ec4ee886fdcd7c9ec95aa5ec5bfb6e347a934cef0da6bf32d1805f7d100f5b0d966657c11044e20f4531c5fcf36bfdcdbe2004188bca686a28e56079cd2095a90e91ef73b83d292b7a173ab02f28e98a4e3bfdb985fff8b031e513da80b0a6d09ea2028f712e555c26a59a6dd17db575d2636f3a16a63f56c47b5c9c1623a35fd2a9a112b74edbe377ccc012c6c07b1eb4bd7bd261c5b8ea3de55885d1db63e19cf866dcfdb236c3f7eadfbc2f23175b1dd1c53319c5408dffc4e3df661666cc09b56fea5b07b128fc7393aae1ef4663ceaa81bc39e2b70676773a08d22728b5caa37a8457031e8efc038fd45fdc2b690c0d64b0e9c6dbd9d007e27da9a94cc94744d2f7fb1480488e0b1b9e855f179b1210d52685d1f12372b42e68f41073c4c646984227607f3ec638126dc6e50109989363826ff705961fde84d7787588e4addef6157395217b03673cfab18bcc369ec56c1d5b30cfb11fbc7daba86a99772e92a1edd5aa853546f408c116af6fea8eff3a4966294f3228c27206c5ce8e7b35ce2e23fbcd10460c6d26d9cb094e0a8740c793a4f3cb4cc993c2e6aac6f264f9689bc63e640c6788ce2db91ff6faf2eef95f65e42d093fd3c074a8dafbb4f68b83cbc51b69f16206d462184be15cbe5e37bcf0c4d92bbf80331289bff33f9004ef1ebfd481b14e27f413f509182c95de3d954d416d15e8b2a440558a032fa3ac16351bc8e6a377f0e43ce948ef1c08936226a8f4f1050da79850d2784b79a061cfae6c98b85ce5e50c608f2711ac9f9dfccec428b0d028c58e0f4c4f2142308fde75930fcded325527dba95313a8458b8551c5724ce1882b03fad2b26aac3d5ed4ae637ef3c973ee5d9ce807dad2ebb6f1498c462e8b68ccc0147bf22664a97efcce86ffd518daea59cf696e8fac0829ff56769fdf329bb49e9ee81a4540fb083c1d413e371b5a75d1743a681206119a6a6daa9923de8d877bc359f95a94b803a9ec0207379dc89d3260fb4b466c5f8c64ed3dbc6a318f11620486fb0beaed51ee15548f5281a6c2bea30ba4f67af89e8956201c55919b05b44c6aeb4a48daa83880de8d2fb6d00721346992783221ed01d1030e630d28cbac959d24dba04c71b5919b425d388506058efd21fa4d3b2ee82c6354d7bca36f243cd31ac4d59b9c6aff9ba1c6b9b0e4cf209d81084f8a7338001b5db9c596c48f1d4be956ad836064ff11e36a3d7744eb12c3adba74eab0d24534597bb719e9138c71fcea6ef503439281a7dab545dac906bc2e7df200da7c57dee32ea7f09260dc519fd32b34c68853391746d9df41ebd302aba845e2e7e3c9b11bb2c3e448d5b01d50e64b7f33ebf2c70698616090d28e782e3c4b19a9c7973bf90517e0faf74fec76ace020e9d875caf944ecb38def5b97a31a22a96a15bde0c1c65683e09a43b529505d7136f897906aa64a75141eedbcb3ada14400416f618cea5a986535c5b091d71421fa224b89faf26f2e8d487acd88e5abc1957b5725f5ff16a22bb514225cb11f40dfe865de115bda437e6be7fcd2e86ee220419367a518431b88e3c8a44458d633456dc6a315516c5e9b090d157f1c3ff40e830d3861569778a4901917094f6f63a24aac55bceca5911d2e57229d9ae01613d72f3f330a09574dab266789c33696e862b0f26a56c0e7ad43bfef847601136d5be12abe91de0d50021bb0f8b15b72e1aed3d0d17326b0c5f0681493eef50715a056bdcc3fa42a8a7f5214762b277c8c80fa35926df0bfebc7ae6fd2ba2cc7d63d17537ef3fb517f4ffdd832881e2099e155af2e69818c74768670b4097e5e2b976b5f889483a1db6e513b24cb4e64969dd184421d4d42836ba80efaf083d753880bfc81a448b4cd1e3da86ab9fee02b441503fb83efa6e4063f1057c6e86a91f1cedd30edda6eeccb125b80aec7e904d3e6136341080f79c36fdda33c627be52fb8f63a9cff1401492babaf9231d6c03221994592ce28899c3875e187cc6ff522eff2b0a0fca1f9500b294f6c0228d12e356c9f8641985b8c0b1bde871f731ad435ced8c2205b023175b945d7c30adcf61c4406f4673c4df3cd398b5a1c71beff17d2e069e4301d08422e8c137c8b144eee159833c7e84c8fe4fb5ea9b7fa91f8c187dacdf0aea4a7b4b27d541eb563c2ac2e3feb7a4faf7cf562df583f2b7f9422c82102d731e0492d070a7cbf83cf69562de327fbc555891d5881203ff78630872b1bfdeae969c78ceacc8d74d2c6422d23ac99ea720212bf4ba22af260699498a1ec6539be2ef7bf34593c767cc21ad9dfea40cc73dd6448a7242b5d712b8aad09bc457c72323394c4f10df9e7394814009a2fee2df009829a1a2badf6bf76ba5b98366d6c00fa417327faa8f3cc9fbf78a1de2fbca9daec29de36bfe67a41af696580c540b2becdc94b9995b4255c86731c27368e6d0e361ae33eeac38486b1df93d9d5caa37e2c34d7187d0acc2a324e63fb0847069f91f0c65cd9d49ed21c0103a11b1e612353b6f699325cc32f8b0803afdfc191ee6632aab71b3cb0514e00bcda0ab2bcbd966f8f33847c66f8bbe642c817a87a0eee0bf76175e9455e15a5ff4108bb544b313a40c33e05bb668e2dd17759c303d7e695be55f382573e7bd114399f3163642357719e83d88e86c23500cd4350e0194bb5b80a4bd6f3d7b579effa4d46f470a724821e4cebd1c7041f4fc9bbd04f9e4f80ab9eadb0753ad9465eb57adfd58ed62870aa3f23b3c26e82a4867b223b378899c57402058a3e4295acbda17de6fc908276738da409aa8a80d9033df5fb46869004ca1f7e4178a1f2ad6ecd0c088efe6d924bac8751ffb7cee7cb9c84a17ac4a052fc486400726316155644f3452bd35ce25502d74ceed540d8b35df50109a7e028957d707c0b0e2920764f287b2bbe3a38563fe70aa36d56c1cb66444900d6664bf574e260356e707b4d15c47e2a3d2240455bcd2d6d117aa6a64c38bfd2105ca90773591517208214dba1f06f2eaf31f47945af8b5cfe79ea73ebcc9e5d103dfcfa6b4f3a536a1b38283044e82c50ebe699b01eb355c128f424d6c795853890292113f21451810682e31d67a69652e219dcabbd07f2ef97eedf42fd82ecd6da40f9cf72fff594f95e6d5ceebf7b9c04fbf54ddf33f014949a5c2fd434e26cbceb8237c999eb962552fa5ab6e3f5184cf7368d7d819eb9ff86d0b56a33be17ea7545041450499067d7f351af9bc29f967819efe06946a676acc7b05ccfef6445a3ed7b3e8a2154dddfaba0d1521931bee00d4950b91055d22120000d3abe83f7d3731a420e5b3e4b924d34a58e46ea80ccd7294d89481d5df3d4e3e0ec422509b16a6116af23436b854508183446ddf7d0acdea1dbf1487f7f8db8f8e24daea3371434b0284317f8dcdd1bd689bb0c5fb5b8ced6d8a41af13678119b60202619f17fa13ff18562bf2f92e1d8b438e80b745fd02c5f61c579f559072c3c1f961767d8fd4dec884cbd8efd6f36f942d8731fc5074f39d72d375625fffad5261520782401172a7c534dbe57b5587a60530502f55aeac23f0ba619f558ec7ef200a5dcd89d030c24f41a4fc606c5ca95c8fd73f0f5e369f940ecd52cc7a14a31e6409699cd29a8b9e0785497db521cc60923765124e7c9d18af3bc5a34da62784f837021924df3d083b609a164dbb1b92ca43f41f8a5333e75b2f768fa82e59ae35f5d346ee8be2106605663eaad3162879e2f490c788ae553a26ce480fcd1e98795c082d83cdbe0b4b63fa87372bb134030f193079b457b5323a7f137746bbf91216e9d5975f34b7d3fdf31e9de7abf570ab5276f3821cf25e9701f73f98dcce6519636ff62ac8cc93d7f7ad45db41ced21610e001d827e8f945a341028308bf61907d114374b8f7376722ce753f7939f9d2c887d392e379e90d7470b977cdc11e3ac693231157b9b6a2ac0d9a6307ef51da13f69202ccd5089656673f748473a12697d53a5ceb7a0fcaddc9f3488b13d8b8f8ae44bc4a1aed32f534ab81f3e2363d3211a875b2bf8f7e7aa622f281f8cf2b4829c9b7108c6d9c3c55ac36c87d8f49604edc37090d0b6da419a562857116c2fab74dfb6752a455466842050cfa31e2525e7149f773a86c2f30dcd93a29907c42cb28f1ec8bd5b1e34c11a1e3130b70423e85134441c3fda398c9271f74202e355c506a028cc6cfede5f53a55f6a504de81d56ca4572eb7cd93f943a71aa0544f1268ff4939367b3f318861734ab19f93384a49e9ff5e34e01df96bdb278983776e6cef096a2d6b931d13d74d385415d684cf2096fed6633650a5128b063058964b1be6f44cc6e1753b39b45954a02d24bd73c1ec30ed4d0cee764dcdc784bacb9f6a706a48db12f91c5b32c5b96e95bed7c4cbd7a53f3f9dafd43fc807b3205ef0d26ec8504052882b23a50cc272598a21d12b727105637c8e443a1438cde4143657c5857f8e47d5585664e26eaba31f423f5de286d0ed30dfe44bfcaaeb4a3ed627f62e21f71874b820b3f6208a33682ec704e8cdc2b0058b46b02fda5e1423fa2601d5d85e6b4fe7e40476f59a567420cdf7ff442da11594f1d1ca85bafaed4ac62750e557310a025f23d3dc4dc9f301296cafd92152473a59d783814613c0f467e4dc4282c4615177e4c4fdc0bf43619354cc640d683edcdb2d5d7040943f727601c605c9a72b97ce919d008f265ca20cea53b2c638b7b4c9eabd463a6c120d362bfecaa2fd243f10f003470f68c17adccc770140c9de6cad823f09757cb407b0761e6bb903ffcc3d76140a68332284346820ee579c8811469e6348643961d075c1d70f7f38ebf87449ade66351d2fd575f2a3e9a26cda70ddf31c4bf4da40f0427a11640bde53fd65cf7955a9293662540b1467e6592bd7c8cb06892aecb19c38417e4f97d7e635149a9b9faeff279d6e7fab6e6723ba5e832f35731bf2bcebff6a0511d4f3dba2e46c4877b467580d1f7dc04749d441928a003fbd3c9cbcc4a4e0e7423afb8b1a977e16ac013b2669fbf378ca7c797184792c30b9b6c167bfbfc79e7ca07b19518a7847986e03afb381f55cb5368d214ad10c240651ee148d6051a05325e3ff75d7f6d6da73ce5bb67f614982954389873b20c1935aebad257db90945ec213ed7f1d5c3d18686cd44099b2225a9c936f17bae0b8980585ab62fb859a98f47f336fd261d499ce30164b636801451ea50f17388adf4d7ca5667f0b8e56dd72a173affda6d903ccbe8d667d19f05c12aa1a24fc500d54c97ddc1a350dbd9ae7b5524b14a88b0015e6b3a040dee82cdf28ce56cd962712100b99e7cde6efab0ebeedff4031e8629c1a9ead80dea083d5e8530ad1f20cb2b045254a644aea72b3f4fd32e6abf2dd9dbfb722b4664d50da9ded08feba55ab751776cc7040580fb87b25667f9c3a0d653e83f3549ff702a7afb377992dda9b4a82c3f9f50adfdf3c642121bb7e92cc4ee50f164309ab71746e5256caf4910ee5443a048d7a29d6ea88a8a78762f0e20e2f00ef627464de1c4a5814f007ad059c78d6a762ca0ddbd59b87121ec5edff309089d8be7b91bf09680309c4f20792ab9be9fc6b9a6ee247f41432ffbb762d73ecb9ce2dd39023c457d1de5c828b2710da2802527996ed7eefa3ef4952e701b001758632f19a8e16145ceaa63722a9eb851cbdaf7d8bd46f42cb1eca1a147cdf4d3f9745a6770d9c7dad15a40b3f9fe51610e6907f82cb70c161821c4543d05bd532f7d8bb0dac36860703d738c7be7e08756b10bb633f647050faaeecdc5e5762534f6ddd012c527530569628da7fe2f389e52b24d6b7732059d5ab359987c64d08be78ff1c87a87ecebe397767bbbe534451d499bae188c823ad98aeba9e59e7abc10d6033232cb9e59416d6191a5f506030e3d60500693c41c00d88fc0b739e9e28e5240e70cc5469b5ba815b9ea0f7736e95b2f899f22e3dafaa4d57066252a818711cfbf781d54a12ca1d9d655f0dadc13ff705ed44d8b3030b51c5485a5400621ee25059481ae6b7448748ee74583680ae6ee7252e9865a4c8201ebd7038127940d076673e39d9e16926347ae2eb20b0648740fca14aac85b7f462478cf77e889e4fccbfc9fe0a6b7e5e6e800c7c753160fd6d0f833519cdc511cfc562b88376e26a6fc366311ccf7cad643be08a7846af1f9adfeccb664bf2943c661589c051d96ad9156673e17e4d936a9029632c5e4af76cfd93b06eb4e2ac2f923963463a3cdf5e9af53d91cab88e7dfabce2a001574f07fcc06c4abefb78304c4ee7a4130ed73e4da1275258d9e1b4648c5320754b1a4c2a7b2f04245b722133532f517b205b7ab1d0a4294153c2f963ca508c2c0154affa0ae5708ba948fd0ad152cd9c70f6d01e5ca568591d15f041bf9198f1b865ebeb2a1bd1c801e7c0f5111f00feb7f54f4b6efa89ba9c2c9d67b87aec9da6d3cdbf3e1bf8969c539ae8cc2bc631afbded00e05359e9840061fe8f45517ed3926b8120634a341230c02ffae9b5661fe3629ba51340ccadb60194bf967204ef0b243eeca2b12299e30c9f505676b8f24f86127be69a7f9bb3525eb90d5205ab4868e9d7554f13f13a6df8fdbc1cf7641c632de2ffc54fc31d0473bc783c329a9ebd70ceb962e7c4655c3de7ae54bae087a0c416072e335924ea17268a069eaac81eca023ad58d580a6cbc16118c5b504988e8ba4942d21875fc3f08912d04c796b35cce636970859797326dda641c50d0d533a96c933001bde10e5c408ab027ce1a78afcdfa6c150060f295797ff3e6685687933f0b59022734eff5ac45077094ecb5e1a2cbf6a61c61242041780b8bb53aa31d079c33af0e2531d404f4b0c826070b44c9d4964073ac6380538ce8d9c2a99e41215d55768fc2655afe3f435c9d3fd65761f797250be9e35fdf6d7d6a775e502835efe7013b333a96125060cbb8d8fce76dd770d2ec652bb33a1e9cd764af94863b4fbf4de0d17b7345f995385db811f2f60474a59e749c8d0a37fba1808fa27884c4d4a2d2479737ec8a13fa7b4763d21e9ba207741149e65eba4b695d58830947e77081baf1ea11be9ffb3e66305ea0350db3730e65cde870433aa3bb69883f0cdc948b3448c7c08c010f5624c6c45037aafbeefeee0bc8d17d13705c92ba7aa1d014d76bbb6e22838852862f9271c3618e8661545e1345863ee0d27333c1d77a6316b617abda3f2473e3a339cad084f38d891529e4a204e087e6017ea0cbb6ac5d08900cec88332629041fc4061958052c81215407379823067818cbea01c8540bdcea5b087f3a1b63806258bf60001055f821ca9679aa298592a7eaebe96d02d28f696e3b927945d3b14f50fcfb63c880f349c42e837d0d17b3042cfaaa82bbe5e0206d6dc0cab8e652f3169f278a203e289a61570d555e74f3543e1cf9a600cd7e78243a37dc6b59137ed1cac9c7b01c1eae00d504ba88f72f4d74e5601f3b5fa0413823cd2b68769b019863c65db0ea40efc842643255c819c2b3c56e2798b9c2c5373f1bc5f3c7f62f4bff6f36cae59055ffb33214cc3678b5472eb67f08064225abdaa1761f1058e39b065f7bcda9a60836499d1d4af7242c0dc075c49fac7fbda7fad2bf3f707e3962945b67d7b58bffb5f62cf414bec0bd2d50f678dedbae6db25e075744dd0c16e997587e31ef907de5d955d88e5086066bba6b55c1436d4a2cfc07e74ae2ccbc7a38bcffe690c5fb03dca84370bc98b2db2efcbde1f7f349fca47d17f2e508a9c4a3a6a7bec5532d71731b9a32e59fc785b071c30bbbb94b2233d2364cb4c88db10e4591c53303c0553ff71c4df2078c4d565ddb64e1aa61770dc3f480f92ea34080359633d2b98fe5855018da38ab17bc2d02a83aa617610d0e7e9851090b603b993aa689f23f17847fdfe68e1d7c580d88ca956ed943844e856f07e9f17db4582bd5e4200c3bf8d643e1472f96a801f19475efd451156d3e410e760547dfd13b95073d0bfbf50ee23505f910882ab90c674c70cff88c3e7d0e421f04e41fb8834de21974c61e60622364d6ebb95dac4ffa50d27a65f531f39b5000ec1bc0b5a90b85e1e220f11158bb17e7a44ddf7ccfc050f46a1b30e9e6fdce2afbd28b5a4aafa8631cc6a6fd45086a63073949012599dce126e5bcd62751d64ed0966f32cbfe3bde1fba8b8cbb7cb7e9124fe164fddc2a2085d3ff4d8ceff202ab1e72b855c183d011ade76a45bc9cf393ae739af55a9c8ef15aeeb2c127062f846f6f852b8eee31c1a6de938a2578d4d9f237d4b0b323771820f110c107be0a2bddfe3a1fc13bb67e3cef6c7449b6365bda64da791793ccfeb8640b7c96ceeb4adcd6592904868ebdddcf634b3757663174827ba96d49eb14faf9dddc617453d258ff7a9a4d03c99f048cb5c5af81cfa73044638957709ae86d9a23023e426d9107575fd46df81180d0cb777d5f8566d188500ca0d5b7c280b4f79a330b59c2e95ee2911c96e9063f82f5a7f5af81b9ef4950df1283d70ecf59d3b7a0d985c5df5b0b9611efcbbc56faf8dd6c6fa711079b71844f08fcc0e604354c564530b49113c8d145ac7e2fc0c2f56b2bfb58f3875be9f67a05c8b927f5e03403e30fa39a2c01fdb20b83b0d34e5784e621d451e9e7136534a6c97ab2d5485ec7cb8560fe748e6a989e93b42e5146b09f5fc36da897fe064116e3b0a6ba0cfb271c086c531916731591770083dd4c89a6a0869460ac6b31f711afb3f56f985fe3e021e9354c5b51ccd07e4b0c69ba4f3b393200eab529fe4b550030587a90c62425f95070bd5708aa88bc8bb47d5c06fd374af7bbeeb1eda8c13075335582f8fdb85bc87ef3f15312a4741dfef23d663f7206ab472bb00af92f711f0519e31583ff32059c85cfab9780e54342076a12a8a22fc81b3862637d28acca4c698ff9780f4281feffbc1aa7f83c0b0373ba565742d9f9e22ea7452612a274f49dc03e1aab862dc851a370b0a6f4606ca14c82003053d90d5b362dfcb66eae57086c3610b1345d590f13826da6344362e650661a2f7eb6200c9c9dbbf46e8851e9b2c71d89299a246f3a4a1cf21adbd1990e10f8e9d2ae8c56863f0c3d29ec68063312656e95bdf4d4103927d6b9b35321353a113cbf011f57556f27f5c2f40662fcf000e2164699835168c8d809e2d0b155a6afce6794e3927de33417ec8f509eea9172b15fce112366dceb2fb671af8ab6f3a9e0c0f2975ec9027ca906d88eea9bef6acf25f51a98ae032a4f6afaa460e6e0a324ec48dbf9e9d4a8e5b2160f773684a0cd58b4a3e82ef05ab0dfb46035a06fce0e61544e2e0961c708df0ab4391ffe694d097ede30e08a4b2656f8e0924af4443f2d3c2c01421071daa4c61c7949373bd6cc5b722ccb0a4fc0043a6ce90901e5b003c7eff20dc9e3cf739d4c471b215cb03bb217e11d8518e0d0ea36e51b55efdee32cfdbd3c696c878c205c7274d405213208bbe88fab4302756b1bcdbfa7aae523c84194cf44eaa26b98980a76cf92f9f808dfa12b8d28b2e5df616d6ba6c61c54fb0dd609013cb7f2be4e6ec351484083254d93154be5c1a61bef272aceeae85cb60b206bb2b8fa1388f555860f2af9fec372985114dbc6c41e3d53e62b2f1b8c08b6a37f0048c7648d1f9b75b23742bd3153ad785599bbc56126b64e9db6aa82749bf8fa719d977ad8557531556bc073ec48df6dd581e4bb04e36d2d51350ca9dd67b2cd60591ecc2101baf2056e7393ba9c58c8aed95ba043aa0fbc20695c348b5e031ab4f24be98d3c9768789c4ad70e549c28541c6670bd33db658e3795875be276f24dd3581a0561f04acad8ab6163ea27e6ad65fd8556c2e7721ff7bfd7e344d910d9a176436e460ccdcd53b0f245fcc4af241184b8b11b405748f9f3a674fb4926f95998ecf79a12ae3665d18ced2681362466a174329a809bbc7b040d10527fea59b66ea9cd0211af538434067c193a74b00ef522db91b56bb5920c8eb40b7425b6e8a964f4c43c46ba68252278e7a6ff74312ee69e79c08aa5fb895d316e9d13a2c495d1207fc8aaaed5129912e583ca99cd50abed163eca0b825c9778070e97e3ed9ea94dcda527851b889d23d9a6e5b1b93b696a1d48576786e546fcc2de4f538307d81ff43ea9ce894b8ba54f7c91d70ac56f073bbcbb7c1860b929ca7ad439d9d3de74a98a25a1ef397064dceee31bbf6fcf3e6c1f6c93ca3b3ab05cc7006fa9e36a325c61c5d970897f20267c12533b444d6e146fea32035da0e9803fe38c7b90c04cf2fb0abb6c39ac123e4a24c5fc4bd671cd48a3906bb7f08d1e6f5c8fe24fb837ffeef9fcdd788eefcdace107c2da14ccd92530323daf676153ebc174229e03eb41d7d681daaca643baea79f306ba84f7162ddf23a33299775bdeedde3fc87afcbd257fc0a0e932067c88bfb77f24a8b5e9dbbd03fea65983121e163c4016de94df5402d5e343cf5aa83cf6a4830f305cf673df7e3ef5fb13a000942092b6bdd30093ae18277df5d8997e4e47f2ee39db48c338af6b7a942f967985a96f2670c8684098b894073e1ac3f8257ebffde967b54e6a2a1448ad03d4bb42b72f39c0ca6d5c499e48d81c867def1e830904bd67078c428c58c7e18de68bd0b20c417a70a26541b7f06d06fb5bb965020e7be93745245743cbec4d90178b84670cbcdb9cefa9a65f5f4d8cb4e6f7b1ffca497d7c80e947690c5c0886e9ffb2abe320a2fc2fc965b01480c8bea878aa5f8119d6c893ad670f893de1d2c84c0916d94706c2ad0ae5b58a93de3b53daebc8d58502d924f0c88cc7ba9c51af67413d5f07581f2ba1651e69ee885ba10288c05295c6a53ed9886d4d59e808634da09f9533a5b18db5e485b51fd795f133ffe9a90cb415e6e35220f1ec26ec6da09dc34eabf033838123e50c2b29cd639cd45bd5c45bd1eeaa9ec67f961da569acc333b6fd2bf787bb680f84256975006012e081afba98d5814327eff771edb088478be4d1f79ef7daa0e520f288e7cf7321792655235003879c51cc444a2d0f6b8299488fd08cac92ac9e74db8cb46c631f9b86206576ec19dd0e856d026d97da43d180004132403201b35f9949542e686da4ce763205b60d96ccbec1ab87fe93ffbc43dfa9bfbf51b0dc779da26da57431bf2eff17b62f78c095748ab4c9bd73a8b37a8ac767ab46e13b0dd0a7a0d67c8ce77013b50e86f1be591ace2795c740ec9162e7c06225ae92f76ee271f13609058856d073fc6c952188bdd013f09c0214fd598f8f72f70e68d38922bbea8586ec7815bc3797d70621c88d1ecca0c74f4862dce8e1856fd0ddad75148904867ded40ab896672d29914aaab33af4b9531330958b02196cc1002130bb1f5da82007969f63d9f3e450b51472134165d970fafc26526a98da5c563c77851114487efc3bb317f2cb632954cb8f5c2cd710594ed1f476f02025dcbabbb2d11b18c557fd5073ffa15e54d6e986793926a378ff354c7f3706869daff4f4dd4e9f76c9e26fe7b4ba77f73b595eb6f816e9e2ad3a195ce9e5f6f644560173ee7e55246ff6743a625f3e9321a7ce6ccb1d5303f8093c991056f02d41bf4e4c504602fd1d68f821de0405b51431dfd774733ca544d22b5c6f22f2d5ba6c6a011562f88ee45ca4450b4482e737738979def00f4ba7417255651888bddff01fee64aa591732bfe2fd23de859886953e5633f50dee9c3fc2d2386bd7c3057627b9be8fe4db8295970b65a8ffb0097a3be7e6a017a6048d92c56b6146920feffaa55b632b0fdbcaa4bce28d8161a4d4c40c630eb6b0249acef57827f4ff5891f969f849fe0ccffcfacd2aa3c38aac2049c4e1e25085ec47e07fc5e495f140b2e09236ccf00395e2623c9b38270c86892cdd94e4c1f7b83f1b260aca1e02e7c67f8a8a53d6e077f3bc1e4f817456c60ca5cefc9c00b6574ced2ead5c6f9d5f6ae0954343766c955aa0880a2264f7b73454198e60f787578261138462c4a7c421e24c3fc7de398130297eef4f9edfd7ef9287a4955b89a46d28dca2d47158b7fb4c1b2c7ef8441560b343d5c2c53517757a2bb5ee9149a97b58d3184c0ab2723f4c2eb250489fd360ad7efa779faf0cefc7d7155797442d2823f230c0e5097e5701af8ba797f5beb5fce434b39f609254f516b44894e855cb0186523cf80adcca44345f1b1371050c7b90115598c150dba17d7c2f2c46599aab8e1ef4ac4e9ce7d8e2eca17c86f70784157c6bdf8f9632cd04c6f4300ff1c94fe589e86a6943283294970832510cbb2608095503478de4ad1a8111cc8d7f476b489e2d73e2d4d7898285be27725114b5d0654609c0d35c8329b4514f3a8343b6bedc7f1995341a399f0137572b39c2f6b1f3021985118086f93741a48ba278231ec3bfcd26ae275183f944796e75c0ec50ef9306f06b09c66eff1a748a529f0b81c4155d676e8241f4fe1a9ec16ec481eee5299354586de363ee9763bb765ee0c0511ef90f36c2d54b651c8d843a706cee7f0328592cb642ef8032ee87ec6ab6a088eedcc48b076bd23dd6257de7bdf6f9e0914f95f8a59c9e37d3e4e90ffbac5e0b3f1d449f8abd8fb92afaa1ef7e9683d6db965c60523bde476baa09a689d12ebe563eb0f18885cb757b3837ff2cd3fd9149b65815d99245bd8015fe92967fba5e1e125b3f985a657a73eb5ee407b191b9f02b9f91516430cc07a611887ff7a5866ea3dd3d84eb00c13b90576485705a96b1487a8ba29eebff0da4abb706f0b5d00461ff72c067a8b242d69e1cd55118b464bb34b1736e850b09f1b2f754bea2823d6359860c1cf6a4b1e2c7b7eeb86861fad6cb335bb07e91fef6dacf0b7a533687ccef805b18c75d335782d01414166fe91a2a25ea2fcfb673178d70303750f2dffc985a788a9696cc7b136e714a2da048d84d515a31a92e2f022fadd1e9d19db78e9192122091f9b9c1fc9d98a4050aac5395b85b4282421da2e28caa0e9d2e6f0672f15d647462d37e7a17c11e6b3fceb911ebac1a9c9e54e3473ed9183d4a774155eb1e38382fa98b137ffd64121b38cd8bd5d130dfbc2fcf60abea6d812ce5280be13e38aae9d22f31ba08dfefa157843d917c0c9a72bbeb4491c5e1fdb60afe984000d27f6899f6c55a0f62997cc00a6c8f6159bd09a375b086001d7e607913ec152dae357cfc8066a845d9b78fd11efbc39dec2d6b3be53a9f39d45625fd4aecfdf20df8ff8cd221e11a95675a45023ab5f24b8d5bf35a968f905e6f70935707e8338cbcb53f18458cee8dc11924254c442ca98293b42abf4600ca536d01f74b8f5a6983b48d55b41fce34be500c602fa412de21bfdaea2fa20893bb53dbc0468ca7e1420c455e7ae83d0f188924bcc405ce8989cc73d0d1245b7c145179d78d1294aa1a5d0d33450f88a0232cff7133fac6a401c5d40024073571245c0339875ea6dd73e835952d91da2ec17abeaede70735cc140a78f96202088d46307c53d4e57217158dc47c5215fd71041b80f40757e3f30b936ea95cdab050098a5294de7ccefdad412933a119a6976c7a941b936c1d18ec7f77422a2b224e143a9b3ad4c67a26c0c7a2f2d5cb5e89d6386393331f86bbbd6477f43837c3c83b62056fa1020c32e5175d0f61a268ecd15aa930cdd0febe00918ace24a6649f25205d8829218e30f4cbc51392b4b91061c434a0ac4c52f46158135b777b9509a8637ecb9410f9d0986b4f41008bd814739049c4b5b5ec80d3a7ad50f69e9469348544891d127cb44c3ea756dd5d2515d05f79a770f7e97f221b7994e6cb6953fdecb227459dd123619fcf9487501b58afd38e0cb8dec24f23ebf31286b795166cd643a8200fcbc0c1d98cb3c13270ef06b1134c91e293cc6c80c0cbd44e06baa5474ce5232d55024a8cb1bb771dc6a2720c4189b03b0b12d03580c2a45a87ec202fefd3fafbdf553b0d7a66d99b1311047ec129995b9fe8906c5e73a2dd3b8267d1442d3e9e997b94fe559455795cbaecac61b55fa04e6c839c2997d9a980a19f043214dddce38e02466ea22053e8c9342b63e01661e1204edd4737e19b6138a8b6b7acb18383a4e9c228ab53a030ffda74ac28667f3408cda6fe54238e8b4d3cc2bd38d0640ce8bdb03cc09ee813a88dad7803a09f7a506b4a36d98340b42e1d8c502be7e4700fb404e1fd95a06f51644ab1f92f2e8e80e1c795e2677e08dabeef086672e6a1ff24c082b05434f1defc809a668857909ffb99c2e93e800ffc78cb147d777a2e89073faf5d9f2b0a89b9a559162cbf9f920fc4e195b6f22a30abec812224b7996e0da7b2bd9c758e3c4c86a7d6d44d032969a2404f7b726e6fe193f1bbdaa03ee82d1927eada8f7a52686b3574eb78107544a93f44baa042744db5237af64023a629de2bd5303c55909eedd0b37d295b4fca955443b4a65a0d070cd24e7ade07d7dd6f7dbd4ad259b659edadc1eda447f21dd3363512066c1e646d7e6196f3cfb0f686758a0dff29ea4d2b6fd477cd847f6f11387114a70bb1a623c976b9531e415a5258097d2df8d17f2e956af14363e7fa75bcd6a3281e7060d6a034e839bc5d5cbb5699d0025f70b8e4ed18a71decb60f254143ac2e832d6542f55a64152e5c689946d58f776411466891563aff394ecf023b82e7b94a46a63a842c9b09f99b533ec32a4bb07920dd350b40084bc5549761b6e697f203edaf885da7fbf56725a82473efb17adb4b24314db5573a2a98e7f768cab9e94787e2219d731aa8cdeb0cf5a484c42743f0c8f645d2630e4d057cd234a10a388554b236b03d4834a3f8abdb24d0e41a51c6f046b1ae9537920f69e3cec3877c9fdff2613dfb516cd174cee0c2e36b6727f1d395bdfcd263537c17ae4f412fd86f2c8f6beb3ad6248d65b2b4178c2b6b7c93d318b25198fd4324c3522b0edd458ff786bc0609dcd2aa5d4912820aaf88d2f8f64aecca0463abeba5b90e79374b21e502e3ca38d3a195a44e60a4a6b50d0f92e8c8133e4d6daf4e2f7358ce84ef79ead430407b4bb0182b0e9eaa5f9339f9df3994d933be90006c5eccfaa5210cff6323d575d541457fc81563feb8290ed5209e79c89b4a21055d25753e65220f8e34a280f6537acd5c477af5c0979cc6b64695f7240f1c61aee41327563f805c750e971de75eda0e3c4f70b998d46a11855fc8fa06f20254d5e315b7ac4f90b24c4dde6e7da2a0759283e928b37973b2381a717621e3a0379563351388f916bba937f857f00fcd70a256eb8344bf772004bad3a29999422c70567477898a8c72a2ac15851136040d1349b58c0d721ace7f509529e6eda43a19dc14c60f5cabd95fde036df2789d849868751357d781ae84db1e578fdcad52ac9af35e5b16f8588e102122cf2577cc5a1d74d97bf4bc5dc8719de5b294bf61c8648dde37a9894cc5aee5671e0179d3bd5ae986654f9d402a3a1037ef289bac6463a2622191652c287d46c7c2ed05dc22f7afe8fe0d881d920a2c419cb1cc7e584c39835edcb998f81bc79b84ec5b873c62a9801650a3fc23881922a70569c7939b1b881b91d6945443efa95a1baf0e08e991fd5860d6eda87707909d2b5cfda40bba6a889418a45ab663e8eaa1d11ddc350bdc850998964e61f6e4baadd34e78a7c9315305f7bf742cb2c0bd493520c3e00e3172bb61d2491ab20b6dcb046d75969de9fa62e2860d5a9ca940adfb4ba99554e3208a2a57d128ae02ea8a459c0d785faa3c549591b614aa524ba59884e2043176ea9f2441f091b193fc4108f10dae32ec36f4a35d49186861844f230e3c22477c8d39b733c5d469d6d4a61f4ca49921514b79f11873d1b4aae74c00bb7b0b559bed77c5d47196912ebec51041ee20062f4e4f4c488b8876fa5ef589da3fbe25217920ee0394deb3b1b50873568a75e7dc49d9c768d2322184cf554022dc9dcb4463b3c0d101f81f2571bff1d569734fc50595746518fc03d0c282358f9680461d6743babd552b41b02e904bd2680480ce5fce857eb0b598276aa2fd851c8c115ffad679771f45741a12946f2ffbfb714654f6b14f966b721776d1d89eae23ae91c08511987d5094c27ac136a4dc7166fca0e63ac644a191883e4e1349bd56390be124e828c238e3f9eed71a3ef6396d1a9bb6d0ce7d9012752bf2c8d6d7baba4361bbb81338c9c925804cefe6b11d3f0daa8e15f3b53e594d0bf80a448f771aac6b58b69b50982aa070b424ee4e3b1f269fdccce76b12cd1fa3dbef4e4617a059b26cd8efd5c621dd94acd01e25cd51d655a0ceec7d2ef7554cbda29dd594e3c03cd35d0238cb2f6e9f85ecd51517a5bed7c7c34cfec95cb19d87e432914d07a44efbf58d750f40e63d6ca15108b515c4e3b89645edfc08478f1dc7e1dae175eb46416fba1c790f7a60aef2535e8e3dfb99987213c74ba5df462f988bbe824ac6d75575d4f6c23eb179d7570e1cf5769957f80c4cc80baec7e9e2297e63de53df39bb55a1110806b0d2477bd1253682fdea56a30dfc83f8d584b5ddf585e217c36ab9f8531093d0e70df88dd9eb941d359d6ccf0528097e06be38ec68f804abe05713f06ad445e9f71f3c753f70935605db8f872d8328ad6edb02049aa76ba6c5fb84b9c5bdb09f21d647ebe11b65cdb14556c6cac5bd043254b483dd92fce22da674d23f2190b317720c7b3c62473a2091be295e845547645252f749b78ccdf6f4aaad66ade41ffe6e94da1cc5e1211db14356bd1d4e3a9a3197349942c80df09934ec81cb5871c992e9245fabad746d412bf93191b6930daf1fc348a941b07e77611f308e386473a39df68b70b200d942922909a432359a081387c4837ae48ff527d4df867ef727c7e77222a585d0fad107f9aa594f105feaaeb4c3a265b4ae1cf1ae707e41578e101fdd3bf1a7ddd06b47cd30147e1ed8df678a6dfa0be76eb8ec2ce54fe5e94627101f654c44141ed24e6609034826ae73b72a62cf346e38da54f0a4595e67f1bcfa9c05d5b20ea868132670f12d8e6ee70d0dcf4cf8fb2afe9a5aec6fb7f67a75013f8dc59c45d81f9edd2f7c0c4cfa0a725151a326ae94f004e8903e67902ba85387d8dfff0a7c4c6921c0bc3347e67af3c938943a7c4fc62999a2a5ab89ae49d8523c552e2b19b89328b43d55a2f93e928baf32d80003be51e0e05251b8024948cfbc0c70f9aca1aefc559559ca6e3d947e8b926c280619c9e9fb75593532d23ab2daf09936b3c083e614aaef1a53a499ab6355eaa4f6f08e07550d252243001db0c2d5c81929eefc9e55faeb5b1b8aa98b5b304235ce446d40c12a8ffacbe3523424c2b7533cfd16bb8c7f44fa7c32b8f99ed4f48720f418733aab289d73e27fc278b6ccba7ea99e603ee57c6d93ed596b1c6294aee6f346bf3b50ad6217a2e78568c756de7733a21ecd45063fd19e387c50f84fdccbc408276a6048c06f7afa1ac1f75946f6ee1435e62358e881570a8d4aa409776fdb98479e19322f5d7a1f7f517ecea40503fe480b98a4b4579422926d369ab8395ef2fec91072099006fc33b2b763dc9a0976d4f8aa9e6ed1b7f14d73271e54c17cdea4aee423d799cd5855b8304de42def9d191110da469e7f90f0895d12ff733ecc2c6e39375ea0876c2243ce33af7533d571f9652e5dbb48b779b982eef130344455553b7b2bf93067bfa591ea8396f290e5f2bb337fbd8a8ce2896696961f3a3011c508fd7a35c892abd549e488dcb781377ad31dedb40bf48bd7d6233f055a9ece5d578a49bf508eec622f059ff04534beb2034d5f4921826608e15ddcea556d6ea4fc7066736d75af37d85524aca30dc689866a01d55187d90060ab568f02d85d2ec3a3554e0b7c7baa27284aa8c494e430ebf79a7adbda0e3af8b62e2d7d0c843a592727823cd9cfd0a86ecf11c0af80b38c4f5ac20cc3482409afc955192510248e15b96a80fa4a1b17cf4d97f03605e684c3b17cf719a5180ad3f5829bef25259e3e1e11a59411c81556da3ef834cab898ee9ecbf1ccb490b11907e5e1e2cd2d570f2a533435f77dad1cf7a23251b1dc7be79c23683ebdb0b98019a62db03f8c1267f2384aef7364aae7ee5ed2ee8b5a90513fe7f8678610d6f88145fb09a70fca5056c5a4fc873ae86c6f8c58d037fd1d86eb3e503f9f0d57beec5d829c5bd06ab5bf2dc491c336616007af47331fad9af1d8d51bb55795dd41062dad2b8ba1604db6ad5c781739ed1de4168feab46219d095f0d0fc997ca73913b75894eda39d1e574229c49968aa67f7b8969e6fa7579469edc9076790e26b6ec7b14c90590e80a8e0351404b952e0c33667d1996665f58f55d23c0d023e36fc9a03cd72e8923bcb3e0899533a45ff6f6e010af9625b9435b0f16ec881dc8bd634e2d41dab8d792d64ef8de731c336debdf211a883e61c2cdc28add1a4e8883ad6f5041929df55a126e30ca8decf2e7efd5f065415510203fbe9e36d5c952a5bb615c30fc042b78602c42dc3a0192d71adbb106b8a488c419330c15772cbb6035be70b3a02979372faa65e0fb7cb2e61393923d95c81b68fd23a802b60ab0ca1458dcf2e35c0428de3f69e83671d4397df4c7964a1b4f35691d110f6a808aa569b3c4fdab8a101577bc043c53ea3a9e6bd7fe2c232522ea4b2d5bea6d79bfdc3355bb8074071aa188f2f3a71c0b7568390b06494f85462580bccd3e8c86fbeeaa242bd12732d955edfc9c7dd454d17c730c5593b129268b5d84a8723842439ce5999acd2b7a656395433451982836a392da8f0589e229d87650afc39aeda1384f5ecee8c84b73820c201771b864a51f9a117e45e768d377503f828dcd4b0fd92c1c717b7ff414d1650df2fd439e9b7719bb707c27f62d20bd0d66e6b9ff7c62ccf570b5d8c726d851b553f567b0994ccf980fe9e7ccee6bba7de75ed93c2db7b4f71d14d9bcbcb6cb20471b2b971ab9a09fd89379144f06702aa559c28d56e51df6cbc848aa3f7525709d06429117900f51675f90cc42d7f94b3375e5608efd4bcfc1f2e4e73b6340b9990eb1d04747b755f8ee8d981de46685345a8d5587a430e230b0727e4608830098cbeb7c06403bfceccdea52dcb6fb37e0f23653213fdb683072dc7429fba05d946f898e250b6cc1730b889e0ddb2e602925d69865c425535fb8ceff1ed920894228adb0d6983453e8bd87a83c2b32f94a2ba076893089490754f4bb45080fc1b59942922935e26cec0aa517efec296099086e6ddad4cb3ca430c89ca4574490077aec7a48990a2f7cec33b312d44f5e02f25857208a536a54871468dd00fa8365f5eb59acf47490277d7417149c8304217850ecfbfc3cb9dc3032013af02a69aee364041dc8bcd8425b324f8a77e4ab15e9711b3392997e6af64e8c25e3f93fc52de10235a8f40a9c0d73b840e4c9ee0a3283d894e0385c4fea535566c9100fa5810550d17dae4c9741d01602c43cf33da899842fb8ee9be17dafa8a01baba6e3c721756b261ba72817ade74f9251ee10f9fbcf39c89929e2104fa65d67e2a4c5417c45cea7a26585fc15c11cd5bfc61c468085c7419cc50e7f098defc929e6245c840a1e5488dcf34fc2b9e9465902740e62e9afe12592d180c4c267cd705f38fa188cd60c4231352519c63e34990c7e2465ce67d7197fddad50c2f13174059fc913db3e6ea2422eac6cd58006221913594a3195fc6a7dbf944dfd5284135549cc9c17ece003157c3b0e2b5e9f25e652f03b1c65ab8b24dad2534f0cc6a4568d1a02b3ca2df539baabbf2e787fcbd0f0b9cc885dcb1cbcc33d2e5c31024a19f9dd4b2d10c4e104aa65a4c4aa361b9a8efd6cc8dba183e56d295649a6f84e65c879f4559baf49c77015f3616e056bba4c16c9564afb0479f4620b9f8c0de5abf020d0255679d744cf54a7b11e35b6baaeebf1035d6d6d29421a38da9c91fc67fcb9fcfec46f05701b6b87ea860e490f97066f78d8528080e509c471ce3824c3bae8fa2f2fda0c97e712ebb2c9691fa8e3e0ce14e6d135a09ef7ecdbb593bc1400846ac98ad5ae48c117aca62431d419aede783e55d41ab8edaac181acee1435caf03735508574666d3e9f44dc1ae829ed456d2aac08b0ee3248625bfd0ed25a24d2daeba0e74bbc7ff89eaee6b4a05124d1e20e0cfa945382d13058a7d51efb4822343c2d39ee6d44d8508839b510f119c8856b0ebdca451428d82036bd93724cf9d331cfa7e9cb81b1bf23baf0fe27956cea6503e29091d3702a5aa4487618f7656f4e96fd6154e6b95ee3623ef4bba0a94ec32c8f6dd03300895652d5140918ddf42598c755d6bd94d4d6fa354cf4c4221d1d738b3cfb540517356f2cb55039e72f0fb380bdc6ede6970c0083aa5f3f0f29560a989026f1974dc972829cbe003bfcdff360383b3edbaf72dd1bfbe701dea755f669ffbf9dbeab18d007750f2aa79270e6ff80ffa8ddd784964f59646f62cf8bb2c38a4cc15851cd1617fb789c98b444e2f8d728562ced9a1efdf98858ce5a86278e0e719995d24cafa6a0f02560b8c0a73a13262c96783a82143dad04eaa62ca35a7f1c58a2806afd977bc70b2bbe1f54682673cfb4ff3610b9bfdcfaa817d833b033f5b4377140e9143d204b9cc395572fc658bd2c3a1712f92199b8d8153e66976fa9e8154c3236befa02ba2d628338152bdb4f050460fbf4d6eb3002b398a3b671eae453172e4f0f16c8668083b85638b42f529cfb179fc0b4c930a17f6bd13cc3439762d9e28500aadf3fed6139293df8c374d7d23d6935d8ab79da978f0e61f4d56c8de0554892cc95ed12d450ae6645bcdbbcc787fa138fd9543884c5abe3c865f9966a8d4b282f4bc53f9c690c9117845522102da4fd53d0e4513dfb511813a130970a82c1db3902a5901afaa06a29f9f3dc1ffaf7dc5cf895f06fae5233d420bf0c188aef465ad7f3f4b46f05cb00531a531331f7d2daf0eb6655d52f48a26457436ac645d96c06baf697f23050a5156e52f55ddf8044f8c1850482b8ac95b0ed52824174c4bbf331d6ca41fd8cf55177db804668fdcbfe05b8b0429b07f91a9080fb5d0c947e1217ff94a8a67348fb30f60f40a50ba82b9b73bf96f7f529c93dd092ffa3c2e0e4946bd0b1bf1cc4d844e4cea5c449d51a3a96b72ddde3b670b6276bc1e9337b825b5cd63e2e2a230812ed7cd51f7d379053a6df1ea4606ef8fac96b72467b24c06676a842993af92d3ed1424eaf0e17edf0b7ffa73e18f2e0930b286307a52e71f3cc01d11d76d694d059acdc534ce6ae476cd3d9f282f4b2271178feb89dbce193ba328b37f8083e371df586f58038877b84e8418705e4d4d3665391d68149ffa0de0327056d1365bbf9410341455467146ede7a07c7e087e65e990dcd00317b6545c2260bd2cf5b9fa76e30528c836faafd1fc79a30881627195350dc2926362a6c8f8e0b65d3087626b25270a074d5f49d6e5597b2e491c8984fb0b178d56b68364f8edbdea05c9f0632c872bd38f39b693af08b4b58207846e9bae9eccc6e6332be4417df43f77d040f14b93d75f7f148e9a3ae5dd23bd6027c0d6286353dedf0fb3a9167988eafc77efd14d59ba1abb19945e2fbca5b91e445ddd8a55715f385205781d6925bc8aa73def175d59ce3273df1c52a1e309ecd9efdbfed084b6da0c5867b468fac7b351e1eb4099efb75a439d757b42e4d8fc2e0925a9a6b9a570532ed7b1423a195cc9883b706a7afc70a87a77fe4dcaab94c84c12ccc466cfb28a584a9836fc83c4de90527ca3c22eb650873f425781e88cb1e3192a38dbb56c593e65c2f15758b725f1263356f7891bafe604fe7bbf0ba35cdc91d48fefcfb3925c81069a049610f7409a608354642dabd02549caa12664967bbe524975e07f3827ad6c22df2f0d536eebef89172fb0efc729d13c4d4430a363c8d5ef6b298f5305acb6ee602d7599b39713762916fc6039cc7d4feb4ee27774229a1d1a8ec91cc4d3731aa0c1eb630460429fb592a78b25f158b0162f2dddf584690ebeed176fcc1f842fb50c5ed24525e68a09281271a37c0061583d643c0447886959732ac74222da9ed21e4b65efc4ee53679d5705e7ff495905bda8fd122332df013fdd2f2c6539a417f604af33e4ea32909cda35a5da5e76c7591ae7fa240709115db082e6cafea8dfdfb23915b3a0a6cb8c307b6d82954a38fcd78d91ff408e092bd4441b36c53fd1da4767f19704d2e6e1f878221ab9c9cdd7220cc4eabb938d7476eb4bcb99f2dca404a0c1360f4e77b0328de80d32e16de011b78b49ef0e74c9460ee685d5f6c7f2e6cd2ebffac53392041b43771728ab8f095ec6ad3ebd842632d20b3758362685f27ed88e9182150007d4ffd030b4fc5f65efea4844895cdc3c5347c0176d68d6b938c998eb24890828959678c98b21f984f35a7769648fa22c7e4109aec835d3e6a8c308c4a24ea75356cb1a40bd1be06401cd134e9f71fea2cf3321a04d6f510e946ef760b78ee4e43c1742fda14c8fb047ccb1ef849f6b93e87f01d8935cc2a2e9b54b9942bcacb4ee5ec9d6567fc3ddcb0d7a7a90a4041413a18c0f7640439309a59f4c3737e46d32510fed5c09428a8ace39f7bbe75716bcb29b0a24257761c830a1e5a0a4e6babd64287a6637b09297149602d7764041745dab2931a57b4e453a1be186b0d04bcaedc4f0f79b59677d7e51f89d2d9c538e1ad3b116988f231ea7e1022677b394a87ae11a080c45f17f9727e62e2056749af7e634e5665687eb90f67484a90383e2d1137d9f5418133326ac06ce561ff25decab049f9b1918e79778a0c6434d2c478d58d723351e002b68b875ce9056c1b61cc58b056eb98be3f19888ae3eeff43dc774dbc225a633c4465ae64660ba5b1907d8c4a57d327cc2d77e0a270fdbf991a1d457382319d2e341e3ee35a9244b4febe9a5bef6e0afa8c021bd1e03cf79cb7dd0cb8db15c6fad1cf0e36f79f151e5d8b61aed5f9123f7421713e6c00e1f17ef018802e5f359e885a3cea2dda3cfa284962bc8e7eb38ce98e700404f2296b5869756ba27d4520be95c1771f4c73e5d5289341a745642949fcc03bc981a32ac2f335ddf7a957f64fd9f743825089353ffc525fd77208b30e8ca82de5b7fc51b016daef5430105f759ca5ccc5dec74f67dcdb44b47fe9d252483f6646689b8d54d12eed7c952e66d9e9baed83e0e6e5db7c3ab05fede9b9adcacf566301273f53155a2a5a5cede1a88eb4df55bd6cdec72eb60db6376c96bdf5af16f6778d8d4e3546c99be9458d97523f978942c0792c7a07d10f3f91b9b6c7b0f936f1a7f65a19bec18e7e5380f0068e6235bb8516d880bd1e34cccf4cf1430b8cde8fbb667158ed7a2bc1fb95a8ba494dcbe25999f18ecfea52282029d833cf23dc7a18c2503e371f7176103e77460d8a7b94c0acce24b074793a59a10acdeaa76eafd5f5d231eba56e3559279080e2a80ea2c8a5945de940f49d5f98ba9b42bcc1c4ad0e656866657b060669d257d3f675ab492f0a61f19d695c806aeaf9d60daf1638eaf7d1bfe4198d671b21a317685288fa5ad5d6d9cc677567f65888339291434b0955a8f575ee3c6473b3bb8f16fb059e04b6e35b0cd9ace154c4acbee0034c77fda79611d3eee227e8737fbb6e914b4ead4ce26ecc562af62a46bebdd3d3838fd35ff92751f5625905d3d2d201c7d6b6264b8420d12234f7861609c319c1fb776417a3e4b3e1d8daca99ebbc0196398fac0a706600ebcb1930f8336c2700386b1bbd942246c66ed77e43897df43fb06d7376237813baa394a4905368427f131705779790262d5804a992d2e3e5030b7c6e307eae3716f4dbc4f55d67fbefc31c5e9b5c859b0b88118094e5e79a65f11a28c2b052643bf97196b3de692ca72592aba915de36941490250cd07d8162458b477309157a34921d35c02d3640351be48a20ff0b8c02d2fe23c189c2ecde925c08db86126986a1f51c66ac28ed1905a89e7eb5167e903b0d5a49551b33e96b2b2efc95821e4914aa2db631f6f5e650fe5632ab193b8d6237eb58277266df539ea871329cb3ff679de8233a03c41ff7891ccd5b58571abad11e130e03f65fa1bab49e10d15a3a1593d041ad7eff17e7445e1cf9aad36f8fd8f7a058af49b54a5828cda1c78dfa3ee7003f5e7c1a624430b488181c156d05c3fad57b897fb558f206f062404cb40a0c61f700f7479f8c807d4584935c291b0ebc5c9afb00db230499ddbaa7727aa2739d42f1e5191228521ff54b620b0cf62fdab9bcac57da2758a377b05cf38110d358f6cc597a0bc442a89ce4df298d52b79dc0c11ff3f5db357662d2d249e9382eefbcba0233c41a076ae1081360e3a65d6cd0414a388bf9333f1fb30c37353098f56804da6a919075c521526a87b7da45af5d88730e8346bd97383119ded0cc522cf20a60b371dd0f6de13dd8989d58c9d8575d7af7e9a3936c2bc4f03967b6585438d288021578b68c33874fd932521d5956b8f0b4cb4af409f823ce55d2656129d3e5e9e0eb0a903ffe5195a0fd8f0a5c1d89bd57f6dab6756bc93c0889ccaaa19d935f63550c8146bcd1d09c8955d1a691d67a2b6a4a09b51ff26f2284b0876b9923cb9da873f61198d6cb97b3131ca4d66661baca713eb8de46f7260db61e0ecc447ba8853f701792076c63dea6fdf00ddb1324a9b18a48ec7fe8fd19da4c5f0d150c8ef782746c06aab250552bb47cebbe23874bb31e22112530789c14a7cf1dff3ce12a16ce971bf71e0b1cd4b4f12b52a5fa3284fb44b337f6c958be110e0da6ecaebd0a3ddf0b672d84c80274a4da33b0666b019d899e64804df7939dc6d5ba66c65e1639f7cb27e18f582745cd851c9ddbbeebd03551d6e9259aed0c87f8825e39c5d6795f303cdd30334ba76a3869d349375bd052d16062b7da25213889298d9303668a7700bb152d270d87ee2f3e81dea4515d5a75fa1e16dc4087bb46b9aa67ca97aa0c18e22b6b4af167397a80c09ebe7bcc9c8751eac9fb6d217622f9302e6cd4095423050019048426459534bae3f7de023b662ace8977034e8bce77a5a0ed790e0a89e7e58ca3c59b9b7ac2be6afd4ac88902c52783bcc05a5b88083d23324972d8157b7d8c5467d73d6356a461339bbb083cb7b1c52972315b5a458c0ae0a2e017aa36df54133215e154f88051bbe32d581071ecc8f264cc330d865c13e1be4640fcf5b99107e8e938fcae6542278f396763c435fc6688e46a2044eebc61aa52267b4225fa179b45aeac3ae5930b126641e164e5df7a3f40a0be34b13604d2bc7a1e58c9bfd2d49817cd4073c2cf31ed7f9dedfe70f4a888237b64742fa9654f8af319d3273768608d058255d1ad219ba2cfc1bdfffce801c893dd3c9a26758cd527f0ee4d7a38dd471253d7f5f7589fe7dba5abef6496d8b85f900b5335c952dcd29668ba8f8461c4272401d98125724944c265e4e201b360c7468048ab165b51265d066dfacf6d8ef241be3e16b17e6f7610fec347354a8446d37cb9bff24f1998cbc947e32fcb93d12c724559d4cda42a592a85ed306937e5af72ab9b19a801c208ba19c518c6e391c1c5a33edc8cc3eba642d131d860d8759223916958402871d2671c9b66c8d95bf36cb3e11fc3e45571786a3c6868aaedb47a089fcbad3cfd19733a1d2ea280bccc2ef6a4b0a33989b765c445e24b55f577200ccc310206d8d04611627ee723fddb6a895772bdb21b0b5eef17a76a368bc4de832ca2f26ca46ffbb3c957b9f676729c976ba7cbd93b6df121254e400daced394af8911248167d58397ef1baedbbf7791fd91da72dc9cd164248f71c44437c6aefab10751aae2e944c0996ad17784f0f1c35657d3c8433b3eee61455f8ae246e96d64e131ca4c56821875d4fd0834ea2fff068acc8672390c4841f095e6861d926fdc276f3e7f781be063834a6ffded1beaad43aa144bdd43841c3859418c29214f82448f81c8b5c6a39aec2cfaac1010c440bc9c0163d88ff2e1cbd4f72b02530ed4f200cc2711a8b7a2bc11bfcc7d4674b53a5b959319a77b7219be80cc22bb2015b2040234f0befb597dfd90f6a5b4977e707c06e1f6d24696f300942c65854cc99eadc041e575824242c7129559e09debd9bb7247e5eda251dca88e46c46f9d374f9b2cba8300640f9ec4baa80894301dd0df101febc13953a06f6a3a7c9e8555ef0bb59b95a1855b624e15963a81592559e0cc43f212d9c35982973d544939645522fdd7ff1ad14a4922251dda78931bdcbf50799b649e6d2a72bf663f861c56f97ff6599319f33f24d6bff4900253c308e538dba72b58e12ba3ae1a353393fbf5db9d38c9ed67505e49f020f7d824209ebda6929464c3a58ff0f0f7aacac3837504cafd4aef23d0c191de61832e23ecb8077981c329e618da185ab97f43b4b5464a7a4a82995b9ab8505c0e1d900b85fb865c7a3b6c702eeec6ffa3c7a6b15a65f8ca5aff71b05447dbfd3037e848b5e32f6afb203a20f5fe067681ef71df575216af35c76a582e8a11dd211b8aba8348accf5a2b5b5df19dbdc682b9234fc48dafdbf1e15e9d043d11cbe7ba07d9f7e2d01719c3894e1ae1ab9f1c2947a7b46a05c88d69716501c106b59541bb5f2c6e441a11dd005fd9f1ceb1d391be591c583b8cc37f2121048a39390ee115e26ec109096a344e33d4b623cf78115b3167cf1c7fa51deccd68b5e0d4bdf8330957def84672a74021832db03a3ff5acfb5a821c3c835a2a69ea06af876532baddfc81843f2a13998b590b083ac0f97733ce6548ebc6327b21e41d94fcfa3f2d4e831a4dab59a8fbf6a2395dcad5c9ee91d1fca73fa616d40c93d7e825172bcefa84f30e3d605aeb4afd7b0996ab00d0ef2eda17c12bf7198120d4929a4e55401bf9bbacc822ddf5c33aa7c2c9ba318012634a8547b692f913c50977ae2b90caee669929eac58fab34ef20b5786e86ebce2ae8068bcbfd83e20b6b8e046fad9461f05e65e841f4f0352b2afce454d7586a7f13515b37d1131465be1a1e5f09b733d69dc3c023a2b7a03ca5148534358f3c3758ee2acade82ea3448729c6327be939b76db129e08c19bd1f6a4bc2b90026adf9033e5213694a23fb0d339e53e7c6e6a40f16f9020507e1f4468896659c5224cb019c5f199456eeabfd9609f2c0dc8fa8cd29728cb15c177f5794b7074ced1f5226baba39c8f5b70f31d08d04bf440bcc4dbf5546716ebe4bfdbe4ded0cf588d507f17b7e45fc5e532f71cccc0b2717a40edf5bba6a44c3d371ff7479fd59f02ded8b3638391cad365c07674fedfe715f84e92401833fc94f6211b1787ba468be3db5205b244d957b37fc06c6807f7608f42d4915d16d49cbed08514e996e13b574e6e28fc77bb613195689320887dd7f306cd901ad4575ceb2481358d9110281325441561864ad99efc492a1d01a53849c1a1332e48613a503173628254a1514dc494b7d96edfcb16361b2e2ed325e82943300f2c705728343328f77831265a855b5c85bb81549c0e11a8869b30b542d71e6bb2f300b7a3d5436307f854b3dd1e2de973250e4bcf088ae724e1d565969e055e9d6aa245ae86d6a76057e1ac074ab0e2eef254257c62437570b1ea10e118a8de03b0c60ee1b4c3969f829572596d535572fea4c16ac53d3e25e21027a822f8fb966ca44244dfd8492a173bd8b590777b77be5317e28b7be086e76eb61cf30299cb500bccd352a96f011c945b644f983389c52c728ee5b7049479c5ee51a3de1fb9f051eaabaef9269fda08954355128d916afb5e711a75e3c35b95e8a6de209554088755651a03018bc30e6d3a9082e95df1d235052bb8dced4440576d3c2ed3def9e9f13e1bc1ff15fde6de72a52efb3874cd88ad130ddde8a58354e967ec01cc8d6e21644597f0adc4e83ff25d4016e0371f5bb74cf4a9a0f19afe89ed8dc168bc437de8d4d69dd805e59b19a0a90c5ffefd732226e960adae08e60b22e928c7ac9399e39845f4caddb53f34eb01fea61449bbeda110cab8691ecec87b53a754429c4ff1e47dc8c74318fd8e50814ff9e3805a2b856e6d4254eed7fe8ad2712b39f644a6f236b759eb259455c62c6cb31768da844b1de49a31228e4888d171d169136f60226a9e31735bd075cee3ce4aaccf0c7d95ea737f6fcb6b47080e2e9e389e0dc78ab4ecc6c7cda2c9d8775d21f792dae2aec16b8758b4477069d89a959d59e7d38b972512dedc57372143b1233929159022b25fef9b28254fa99a1da4d17b6033e06e7ae735968e95b661206dee973c189274224befd8e5a8e53f8b05d46d855cf9a78004273760e3bb731b9bfb62422a397ef5f71398b09d5158fc0adee3fce25b3a988a3a1e0bdc9b84772931b20bb0ab3f2e1f22305fb15fdf23513be25c185e62517ec40f352d421b30ff8f587b3b834ccfd3e54a29c10e3cd28b39f5625583a43844bfb2cbbda8d910977f0cc4a98884496496b8d1390ccfe23aa0e833298d77816b3d77cdf8d6210191ee50ff334f8516e925ec5837ea76ad383f1b2176d90ad26efbcf9eb1befd2a8b49b0d92f00f31a28509e32fc9a0760380e44baf41d4bf620b71f5bb46e58a79cc0957d12f4a479607f7409d592d895aafe9db03fdeb988a6a57f63b7cb1b7c205af12142aa3274b8262f686dbe83077880027dc8f8414791e54bd9e0ea90b72069ab05b33f7c8248352b12a9ff8c6f3c409ee8586cf668a43c6644376420f9c41aa6d0db3316cb02d6a59d1dad36267f14e3d367b65f6d816eebc2131af4c77a11f5c8a72e81aa222420966b1edea76fcd35995b72fe8a024b288fc98b806e0ca6e411ae71dc367811635f04020af051ebe61c4a3d9fb9fccca92ae0d1c47f8d2bc6ab609d77e59a84a1e28291e33526f94fe04d989ca605cb6b5897b63c2d7dc35e0e506d2f852bdf9ea39f7694e34674c88ebc1a62a0c4373c24fa087956f1f7caaa3e834dcd49bb147dd1ba106b13e82ea7f6f34a1d4881922b64d2af666bf60f82a668f5f28eb1961ee69eb9ef2331baf1fb8f3fa37880e4dc367dad3adb8c5bb654026fb23ce269b782a03532e0eea6bf1b568ce84996972fa1d0f5a9f09295d13bc2c1f43ece5c765393b71ff73a5b2186eb707323eac226f0b359ffe0d2b5c8b07d66a3dc13cb808fdc41857d5b283f4a2eef4c0dbe3fc784b2fb5da5056d301825ce891508f5ab1637cad12158ef9dd914b4c42a3002d37291a290b58b59167959b508083c01c46ec9ed56e956fe080f713f3bb486e93ecfac221eb15123bdfa0912ba4b95644e96fb442fb56ab333faf4850da412e7cfa0d1f3bc3af9c8752495cd230b3e3222488c0f44de5e09b70568a4f1ae529ea658c878b038728b2d5438abc4bfa05d380d2b8cb3d44f64581d8f76b01048dd9240bbe60bae5f56de255ff9e51c4da6e4538ccea4302416aa7472b6b4bab0c02f4a233757981b5744252123067bb31789cafc82e1ad0f1afcf25ac8d253282a24db8e8c22f918a9d4cd93501432996eb0de2551d472000dd37cf9fe61a7ee1dffc1f9178310549c4f66d6e823cbea8fd8361518fb925a21399bf12c145cb3355ef37a82121a182eef232b86cea0887da3d38a8c8f9f57c7c96f9bc4fd95fc1faa4043620166abcb047435dc86e470e4f4ab74cea9d10303b30dd51c156de4b80cfc698eba7229580beeac54db316546bf9358a9868d7504806cfbe3e16ff64c1d1e7117022ae7c02d58aea9317831719f326e291ac0ee55fdded1da7c8b71b1fb67e71d362301a765793052ec84ecde36662f50ada475ccd3f29442e9c0b64707678f273f3ec253c0dec2a4e3a9d3756987252e7350315c3620128fe5446964c8341be147d2d2f2c2b8c1c996598a5b694d27c2994ea786dbce255cddaaff5a2a84d17b5672cf26bbd576c70adf158ccec320a12c50a682283db8df0595f53e26708aa2a220b87ead26dd21b93d720da966facc78b532ce419e098f2fdb94b92e65000ab3a9b09590a5e2f3eb1b96f9a02a0bb1095a66d49827a117e70be7b4cacfe92671a7ac657c3c2f6c50a2d3acf83d04216fb80ec1a488d773fa89c255edfdbfba966437184f50b411ae102cc2f62adf0a9e12ec04ce2a6d2caf14b3fc41746a231a69ab409de664afaf68e93d88427f976b68bb5fe72991c699828889a2c0b89eda9941fcc6ff14fdd74a16d9946bcb2d5fc0f7efbd1ffda8169ac176b6374448956386c7977781cf1e182313c6c9503595ce36ee7f0511feebf27b397a3bcb57732a95b21075d00a7de397f3615f418f86d7fa7feca6eb079a793b25ff606ca25703dcc25f97f13c0e2ea6f25f2aa5e61ec439b730f2cf0f198521ca9cc041577742f33dfdaaa7ed6c086c5518cf79522c5a02b19c4adaa75329755370fe0ac1d11676bcd9b0f08a24f9259f5801971776f4dd22402872c3faa4beb5c4c29d3286828ae4cabcedbcc11329736b83daa89cf927b49e2f4f1dfc42b0e54ecd90ff114a486ebeec85fb0734e098a90e08640e37b800e8bac7290f35c4a97b903829ff53a39d6f22d8da2e856cd3656aff191b9fc8b24c9f877101edc864fae8b7941838c7f1c5899d8a77f6cd253d61c38f6ae690986e2c4211261c265813fe4f0b2360c5d792e2492a3d3d49992049692b039954614ba22f0fdc38924b0b10bc398c73d2c2c2590fa395d43f7e43333d3419b99f95a888c18f3d01d6f095cae9e752451049b6853ef50bd3d22aaa764df44a9cd065f501ed10cd61db646969e9bd6fae3e3bc6fdab7322da7b078306744e1d0e6cee0343f8248acf4e4b1ddf05ebdb29442ee155e4cd765f1c3d7f12c6dd0a051f008b6d94ecfe67abf2ed298e1600176025a36a062f324e95eca2dfe6e888a7796c04a2e32253fe7e71222d98ef4fa0ccf0d7a7b8b2082d1e447bdbd002bfecdae089b5ba98ea0bf690ba360f36885c4b732ad7a92bc762d09e36c02e2dedbcfd5c2438b7d751e7a6bb97adda4d7a0ecea8d5ca3479ad8e19d362eb767c8f70ac503b7d1ee81e4f54a59facd7d4d9466c34b9ef584da107719728de07f448351079f9848194315bd99e08bc9b55c077bb0cb07c9822a84535cc80eb9589a43a1434cd792500cece55873d3b7870223c747119c3dbbd0dc00dfe54a0dbd326a0338f52eb4fe1027fa2fa039a4a7db3d332c556e5ba2dbbce57c26a217619cfee5ef38526a3f255d4091f50f5c8e657df8ead9e278bab07bcd9dfa0634482e7d9fd29e5bae60d2255b429b2c64f543ad383c9ddc8432067d0cd6b69bd0dbf48da49c7990ecf3b66b80fe87b2b8c90283456f12f7ef51f152922d1f4ea332b908e0102e04359d24f1b52591eddb1e71af65851ae23aa6676fc3c43c1ffc7645c4e19993e0283599a07cd2145b4f728e64f704c0e0c047265ab544a87becdaa3a8098f744fe00c8cb116a66de124e3cc5824ce002a8ad2a10e587c83397b63072a30c818a78019b6cc3863d0ef4b70172ed7c56eea92394e6ad91cbe23aa93216ff3d3193636b74fb3952061777907bd2bc9b12c6aac0f71c93e1b5506330a077d8b241a4af61217e1d146cad4a2b5e41a6ddf107be6bf1603ac39c9a7c90686048bbbf68fddc79d231da0af8b40b5b461f90717aa025dc282a559d79a911fa891f31cb8d0089f5a9819d6a8b94e1bd742304ba030e87ed5a6d4f1b35bd5f6c556a08170acc2719a6564e8592713933b88cd7624822724a385bed7578c5264f6f91ca9c3f987e075e2ae1d0b2bc9475e1ed8c23079bdf1b7830941c0af34af829996b443e98a7665f6c196d2d1da368dd0ba53c04cd3e71b3a57487b67384c41853bcf3a33f98a5d59005516ff6c14f941781ca60ab2502ba3af7c299636c1d7e9f2911ba6ba4ce997955a0ca2f6d306a846d6e72dd9b8c28099f3c7a5e4d9e0cc118a4f0e03d9d9660a2e4962adf4e0bad97fecb098e7469f3688b010d4e779951c4ab335bfb51b357cc0e8e79030f1be4249318b4fc26ac9d92c897f08df058449a7be93df618829a728821cb3f06b1c14bb4e8aa55bbb48a8b301d5c674e21dc55661daed2b85a40696b0e83ead30ddb378df80b07d9a9c62bdece004f09dd5c3e47b97c04ac096d208f4f6ac22e0a2ad021621a939401a88345dea3a1135ddab57347a310e99ab5b96a5e52becdf43b1a5aff21fae74b43c227155cde017e6179dc83d8d5057ce12928c75ed9384ec8e543bd9b5b52f2324a26335fa10476e23453aa0314106d1ce2975403de969df2aec51cc3a1f04a9820da5e10b2c43730aad0e94f93c60230e2c3363b76f3301e17de4ec6cac130be7b8d4e697b03747ae719c0d04e7fd3f375217292ec033dd0d0af7018e8e0d8d442e8af2da6e30358456ddff5c2719c5e59815f6bb8b5df0df3ccdd9c8e2176d1afa494f773b5a56c84b86562bfb6834034b79133040204911de6a179298fde07c11e85eb2dcbe71c83be507866844f394663314de29ad656c51d9c800a82120f1e0f3510083965742acd651f9953a6d8e1f4ec603cc5b60b25d6f5e997c374a945547c619d955789a481c759c2e713143de5e541aa9e6c74bfb7cdf6c96cef5f9e1a341a5032b810a9a583ad65b6faabd115130d32d31c32c17c117dfc37cf3c5dba966fbe40fbee11f99687d24078e38cfb6554cd0c95943791cd323afb7d82421c101e462965949c36a3b6cb988f3b9dcf0b7c77272302f6b8f771c3c575bd187f7a06fc788db7236aeafaa80afe6b3a14a21fd434b77814ab81b1a3c86f3b7bb2ef0b7b22d07e1a53f67aae2ccb1c9dd906139dac401f04618da94df40db3778c963934efd3f65c244257a36fc72f3eb0fc3392edc1c944152f648748aa8529a26f7376e4a7b7e4f1374f53ed9f9eed37cf8f8a1e0485c2545633280711c1b25e382ca2e4dd7a38a0d90df13394ee9b3e0bb0e296e19a774b72db542c839e23e65a71f414c7ccd9708b3d56fe4fef6e8ff482a4928bdf5d405057faa22e5479a6742e542a84a83ed7c1ae50043edda3c46a27d7eb219ffc228d1793f5f7996b92b2d2432235344e41a9d627aa19927463bb4a51fd521eed9d5305c917d9d5f682a3ecccfedf942d55bc53a3322af68109ebc395b32d8049494d6d995a5f11edf98b3c6618ff8d0c173eb5f80f6407cdb23264a7dcf558a2d95ee32c297b6df3d4e99d4b8b2da5a902fe1569d3548b893ec883e567cfc216230917482799ab42ba817c2381c088e6c150ab012bfda3c7d92ed4665961d719c934b0eb8281cb5029f1fd722bf7b364413a58eb73484a3d7f87e2761e44894efd2197af165eb0e09a4e992737ce560f5e7bc4be3fc99fc07939b32e13aeb0eefe031c61984856e49e3814e8e43f2fac6fb6ab42112ea9d1cc0161d174922544a32813eff9d179033a5128e65600cab5d9a84de8fa211a92d556033255ddaa8963567565a90975d107a1190e8055eee6eb623d045c7c4abe9a513162963c3d6d4d7f23dc17b7de62d0532349d2c3e8b3a2b5b3702059be3fd13e4dc23918ae27d49fc0b7f6d0d4ea2a56a8d3e308f93fa5a83fd8e042f5441857a076862d51bf9e6708cd84b9eb548861cdafe98a7c7458c534c6366023368884cbecbd38039b57c9995a45eb4e180d2f49ebbd55a77938a6d4a50a68fe647e404ad7fbb8aba216e77d438e3f3c29814951295ac1f4adc0265e2e11cdbc5a2ae55add31840c5163b6f23bb153dee3b3babb7a81acb25e74a2bf2118457be4089dcc3ab6ad54e411f7b49f4b644f6498890189ba38a4b8e31abf323bf4055423a0ba58031b62ffcad8900d25d79089b9f4de0e94cac7fd45cb0f26fc8693961bdff375fe7f87d39849acfc29f467f1ccc3cf49e059945a419258794ba8bb74babb8965b1441266235cef8470777c439ed442d5b45f5ae9caf4c233dae4f1a49f35bdaf85dcdac95a069de0950be5e4733e1d271558117cd791843fba0c45eed2cfc4c250ba0eafe97fbe70d298a0a115d768ff4d71a2bead383a244fe43fa697e5349d83aa19f2b97e8d372f573e8941ce1fce3d1c079e7764e055c4f14740c7155dde624eca8c85d5bc569840ec20c7a5b81a6783164d0c68813bf7e4216f0ef35d1f6d657398fe0a0393661b58b5765adb7aff686ffca34b0cae10562b045cf0380b5467d66fd269a837c401a539483a5e886c4148d00379523260d4000e2034859d99c7ed40ca97f48e76b374620f7cfd31f06f7e00445bcf7bf5c93945530cbeaf9825b6ddd2b103f8ac4d29efd5eccb44e09708a8bb3d44f1a5e11d0d37509fc193c1387143a0d23ad5a498af37af4dc5c52941eaf7a550746948106eab55139c4b12524386c7167819ed4e6ca357d67ddd7254aedddb0a60fa2b631637b6c0b452840eb96b8cc23d46af9a65fe578ca27691c7d147b4ebf4842718ab3b410728207fdd808980e104ea8863d557b9162e281fe666b579555de2d5d617679b7a08c9d10156a0fa432520b55cf7215ae23158d9c19f210c31f67bf6381d9acb7082516f83375c4ab1c942d02650e9f4aa4bd3424dbaaa15dd9bb5acd10dae4faf0c609017d1ca6d1f0558ba6872188bffcb97b57097156fb8f4a069467f7e83adf5aa9114de9b252a7dceb6e2d2cc469b52936a1a696236dfece8ea41a5b9f7ad1429febad597b55b8d0c1e3d6bb3527861c819e483fb0c15b0b176c132025ac1abd276cd1108aea8d83e2bead396be0c77f0024ac8951778277364b4e929a99ad0babcc3bc562dedfff0685692479441ab6f5c4f7cc4b3514e5ceee8d04a762e7e14a2cac48b954e69d645eabc62244dc8b79765d973a4d3bd60b5cd4478cb4a070bdcb575d50ec852aeac1891b545b614f7cbb93ed50d4a79f984c0a356dcb2bee36867df6d1b27111fd665a2bd17c0ca99492951933e7afd9bf780d1844bad80bd99c2737767b5c2a4bbecba77a93b4ef612fb99a56d05c2b900f185d916d1290a41648e1d400b972f7929f9d4a55d22bdce173a951ccb651b7ce9be2506b88242cd3ce8f4b622db02855c09629d612fa8415b2a464e0b3f62497476b8dcbe562813b10c1ba8a3f63359fa01df8137081ce8b7030f44bc1f0ff23418ef55a446993ec51187f95e4e8b45c883fa5d11073b11297937eacca356c2a575966db29dc08edb7ece7a827031607eec0cde7c6bda1dd47e15af2de4cf2aa44e13b6051c07abd435a439fb7eaa06bb10714f70e33dd50df3e35720332a1540a2abace43e29d69a6a0140468e71c1dc1f983cf7723d9aa42eed858af9ce3612d24df815375506a1e799e1033ddf23c6905b75b36a3bbb2552c8b0957f3cdcfa4ad17e8f4c99fc4c55f85101f88ab3a971b5d173ea9ca6c54e319a522f8ca70a93154ccc5a83179f18c6de5d03953b2024883080e0fc2892c1c9d132284d4b915bcf0ed44a682d7e7870f489462f191ca40cf2b0c679264fa516f1238b832d7c510e2bf99373bf8eff268ec7ac993f41687b1798c346183459f06dc4bbd4e5683691362a5583dfe2cefa047abd80b099769f03767ed9016efd7fdc4b955178df2d82eb95db0d76151aa571684c1ec3ff8bc299d0681ac03cc621fa5c4aa9290e819ec73b576deb3a19e35773ce1e0607cdc139e41fad2e93355c2a725f44208502ad505d8661347cb46ce83d2256b44948d7c529c0a27de2354f156786b65d50d165e31f3e8dbcb73cc5e41bfd01f5aef9e9c2e799aa3689fd7b352995b55b9a41a9df716018e98abc8aa0233481d494082ef132441f0bd680bb1d3f27bf57ca8d21cf05b8b2774d8b0599cca0601ca1142bbce568f773773d0667a264df0b651abbb64c521af5f6078de5a23bb397983ce61b6d5225854bad32164d3922fb88148254ddef495b3d9dc4d00c1e40a064e3a28a6d1c9ec2f4805d04a70e8fef28bbe211a10c512128a821c4a0e3b33c26fb6147e00497633dcd77f1dd9538b5acb116cbabf7668dca01e006c83d0a1c3f04300142270f1111e42e8d7d7c88fcfe8dcd10f9c8e46a42c0cbc22f156735d340ac94f565d3c434b7a452fec1de69064e482ee80c26b27a3f70efa799adf3c98f1fd80152026436ff16e870291c67ec165e6dd7c3485c49b71e609f25bfbdc9e1c181675c95db68e4331bd3ebf91eb821e9ea48f6f03127c67055fb03bf9feb4f6901d4bf15ed8f3701ccf39afacf8277003e029fd1970a853e554aca69273f0c0496b0e428cb29b17943f1648e9fcead1d539632a9d504f6376827fb8698dcc83bca04f2eede11a88bc63c275e9923227ca5e4c9fdd0085acf1bd8ab1cd0da6bc1c9b1c711d80b14ef85a3265e367111e65cb5a53b2f71145e4ee91f487d9c70c066d84726d794b6723d6ff74a39bbde61f840cea69ea11ac94bb7de262bea1f22b76359a3ac2829a310086eceabc1efdc372836de62c445a51794d408955604d385944a119d646943c32485245fda2744ada8c8e5c8a79efd316b9a765d7cdb3f4809164d1e3a1a170726d4fdd588b776dac4ba76ade688de84d59c18abbcf7fec4af2cf44bfcabdaed27e06b15e7bb4ca75f50365698226c2625482ad755141e734468dc8513e319ff2c4f84584b2bace731dcbc58b2d1bc3521ea73236e119cc54c8aa07dfc5b5b8d09cb32bda9c68aafe73c0f6cecadb55b1e09bf0962e88ba9e9cf0e860058c0a39428b09fda12bf24300567defa7a6ddc57ebb55c64f381d44a6ab20289e2bce3f8802e04259cbb66939d069c62f94d5f1dd5224b4cb71b1feab9abdd822b1118d370e1746531deb8f9798d06b3dc753e4a21b4b4be241005cdfcddc9f0b573bce39da28d37e4e6e760fdf302bad2c189c23fc4feda92c9f259b5a1a023af9c1a61500c59615f5dbb8113b13100a898c2e7d2f590af0add0f70d9cf75cea0b89e8d94ad2c46cb1f158858a24ce76574ee79b735ca14a048908e66f46b77b67c052b5daedef2030b51dee90b88def1294aeb1ed1a7816ef39189ab3e9b2239b3c20b9150d2520d5ca551f7b59ebc4bdaf0ca5f6c1b98dcc33dba2802bb62916b0c037eeb5929a1dd44d7f4b7ce396a6f175fecd8d4d37d40faf85a64e5325b78b27c822d74bc20544d5e6b1b5d7f0901cd42443eddf4260cf3c0fbffbef32123846a0e25ecbbce80bd5ae15eefc77ec5ccea5a1494553c2a54f9d1e60e8cde74f67bdae8557240f4811833d8229e3cf8a0a12a04d7602f74887c132b15765fc545062f706a41585ef70faa4a0e04b0a3cf15c0d6d8140c7306dc032d65e2b5196067253a6b9c0a0bb56513c4ef87e93011f580dc4971725337a409c5d09c7bf584722441978f1fe76a7d155743d7e20df79f1f1c95d4865c395734c9c688da89d990d74bb31b067d1aec227fadb60780af6e0b5aaff51c0c7c5c65cb61d9bf7dbf4b15ae5dbf25b8513568c0d22a1e4f522dcc8fef21443c737a4ef31163df092022482f44be2292d0176d439afb05fe638ffb9bdb1d1e7fef0e76fa79ba8444f7da4cf78e2431241098e8bc879592b3a98a93b8612a0298bd2c73b6690e1fd9acc4b8e053baf35799d5fffcfbf070ad433d3f30fb56be5d10d98e5cbe2514fc370a33edcdeaa9426b6fef375b0e14478167082757dec629d435925570dcc8458f36c402125d1124514a541c40f66ad838a7e101f1cb59c474bd5abaac83e36f520991080618728b490727fffcae32ed098815e23eb357a91bd237ede37dabbd6b992e062cbad832e4c91f8685e044253e2f21c29d8248a0e6a2fd92cefe3c099156befd0cb11335181760f4f7fb937417abb8a35d69190483ed15585128760ff740ca9b00e178b8fb690dae852d6eee24c1fd631b8050f5de642497576af8a68af58f2cc9b93bcd21ef32a84433d4d07087f982bca4f4d11567d1ffffba99c4786cb3f7ea6f3483d3d3dd7ff44602f7a80e211529f842f2b08d5e96c91de60db2b730373662382b9f788311707f0f3d4412d33e66575fe1d46d501ffb31d36d5699bdb1c57f3a57059e90c2b40152ba0866ad5959cb43a5a3fd9df165fc58a3701b9f2d60eff74d53cb9821b25b739246ee63ccc86dc72f2b1e10538e3cc028053958c5627a54c573a6d544d52632f65b8b2225062d8186f049a9a8b42c25ac9138c7d37f8be3fc7906461e0c8e1596eeac4ad37ee61c1854bfb6b74cc455d467ea6166006c89727bdc68f363e2845a99dccde5f7961aaa35ecc694c438422e22a17e57e6b8dff750e76b8ef1ead23549e4b9f96e52818fe7a4ce7404434fdfd0aa1c7f333ddeea3b24c83d5833542e1335a80e516563ffad4134436dc799d6b176d45a499d9a6662aaeb1e1c49d43d9aa12b30ffeaf5266e0935ccbd47906d145fe59fe52f400a2a34049985e672348172958b281716e2d7770901ec514532c14532cb8eb9a72ae301052149ad34bb944c801f331ec2251eebe6d2e2e1a1bfa2f784bad1ac67c33b93267f829e49e082e85434ac32c5756f4724fc4b7fc7a24cd2e06661062409bfcb00512ed4b787a5ac87e21244610aa3a2de9fd60c9297749552c58e1d1a0beaebae9fdda4a74c5f5df555d12c081079e61fe828cf564e3952346b2c78004350afd10e52671092f5ce242f085b3cfada30d1ca52db25aace2f880f04e2a8ac8667e1f57e81089ca103aa5f38cf32f23e8a3bd39cd7165dde5457e3495afd4b563d5d84c4b9b31d824c3253eb7728307c583379050e8b807c8e67eadce963ca0eb3f4fe2a4dcf44f813a248e122640197c13fb934d00eeda0cc7cd8e7edcf1337e640faee043a1b90ddf92ace4b91c88bce6d377627aef74e3f7bf64e94e636b448f24285cdbd1f1e7d1da1dbfb7da26b6dca9d30a90e588440f18f82be2381fa556757c496301be6e9df68b229819745beb233d887ad232c9c0e3731b29411efa4833cc851d491ab8901883e25e2271b2d1e849b3283168edfc3c9b4d1ef79500e0a0350b253e938f9116cd17cb4e5b5f6618909ced0461cbc3409aeedab7ada1f639b5251578a1db3b817f415b43091f556bb10c20d5210b1f5a4a3b05fd8e2aee2403cc792a8d39d322237de67772c380856a0b880f5b5e7b7aac2f236da71ae28af1b42d315b807fd2e1b59794ea240abbb0b22f2d90e12c9e91874ff124e397aea5fef8e35a55f31021c23f46e25f3948970999e430429a4f5764b19ac61c5080b164e69aaab4dd6b15fab09a01af0ff12a9fe541ff3782ae855ed6b3906b8a18832eed4fcac8e55bebe4ee8e4674a2004a297e925887ee032dde9b276c6991b30d48526e8370648baf834254da7e2b8f4986dc1a8da0a8e4a81a6dc1ae827df48d880db937cf45724bcd5c6292e2f31f02240e8ec98d162870f579de6a01140a9515e02a8c271a0d9d97658bc3ac32c64c8f0eb6f2b63319ca5b8d1ba3630b88bb4205b5a834938ee381f03598133538bb9456249f49373212afcc7de214f9c06a28e01fa81fc16b8ea25d3058b0a17f3770917496a4b18de79efb7ad2b08eb38f33b7a4a1c0b4122f2b8783694c1260e659e1a296a209061dccc7827016a6371929fd817bee4f306acf4c095e33462f8045a2d066b5c4b253f0839bb46b338f4a09fb4a62c0fb4d76f740e94febb83335c1968a651a3af7d0cb071b5e904c50726dc3743916b2b5e67e19d68c8cea49a8389ad8bc5a52f9efeda9bd38b156e52e99cb44b2ed0413c38cb9a27c0ab63cc6bfeec402476f4b6eb286dea62e1a721693a7c533e5b7beb53f33229f28a9e93cf54063bc88848c8b2ff8e2c876af9e65656acd171a0c6416e2af78cc4ec5644f6693ade520f6bad4f852a1177418ca3bffd0aadd79c9ff980ec323fb52c9d74dd3bd0bad6b1f2e14a74dd997efad5936134137fb6d952d4b79552d77e20a48996a13952b26574707e6f0a2ccc617975652676df91397dbbf296cc29c33b2ada6804d60d19cef96edc932ad417ced72f75e9ee933b5efa05afe9756795ef7f4042a1f0acc318e1a1d1eec815d1817914522716cc5df8ddeb7021aa6ac87f84f5a5e1a767eccf22a617ba204de9a672c9c7ca89387c06f5a74997993ef986e1a80d905b930de48f73315126b3e48011e0599ccb63a01b2077e3b75874020183e14bef197017c8ff844c9aff30e97feaf640501e84e2612e6572d6ced6e8594383e7ff234a76e4566e1e8a1d5c93a4f2132be716f9128247507502b9d87b6646c02599ce1de2adfd884e10967a7847c56753fd8faa070d7309e59ae51772c5747b98625308cccc3c085c73fff2b8153366f7b4de37b51c44c4039d48157c7c04ac62e7328fe6326cab7a7457bf5447b14e9ad3f0c7e04f2392343386dc95fbc3909097443a7677e3732d7e6f4c4bb23cb93062c1f61919a70f06d3454fabb7a756bc9b1c54bcb6ab349e9fd706a36707555b67a0c66ac9b445c19f72b87407acdcf78912c3b913f702e6bc39d4c3dd5beaf42b18d417fd20c998cff8d5d33ca22a426f16a402e2b535cfe5d097afc679647ac27aa4fece83a62bdc7753ae8c2bdd5577ce2ea6a9d3c3da5e088fb8c146d8e7eff408c725c673efce5bdcdb3444ff7785c0c9ed6aa9b2b5fff63b9b4095eceb46a7df9fbca021fa33618c21220e4fb8325cd0826921d20022dc1c8358db84ebb6806238e5ff554460ff75daee3a7c28683eee1329b4a453b94d3b44fc437e8110ba3041780fc490a51c22eefbe2549facab3cbe069ab7eb34f437b6aa2d9db579e07ee7c31c09ce508ef266a5e85069958c5d06787804020daa5d0ef3a8b512039d1283da76384d72e9c8a4e7154b3de0abb1ac26a51d578a1045ceed3c871ef26d117b660ba5ce165cea25ecbfae9667773350e38ec47ae2d2232b2ef57de6cc38da15eea7f6b75616da41c6f90365658cb2b6f28dacce351d69d6ffa899220f1f9f35488912f31f795fd3b3d5895c518b6e5ec7f6ca43d92f4e5accccd46211a240d1e15c95e703d0d37a11c2a2a4f87c5f319a673f307ae9ed2ffcaaf3d4c7e1eb7db30392502bc20c7589fd2f688e40b682e75a4098c2fd4f114a7c258ce4572c4b08aa8fde26c31e1730ece8d27b113ba2347a92471e3fff2b8b4137109a735b394feaf7418bf7d9f3f9dc58f4ae6fe16b5b0c9ac00aa43b334e0f7b3e02e39a90c24a62988b8395b92f487524d4cb2cd1f2e62754f44a4775a07906b71c14a44ac801551991810a4986ba2f1ca2cd675e4e71c9a423c8a38f9eb5de025462490b82ed1bcd0ac2a69224b58301b3557231b8beed22506feca4140dc2c8301011e76908b2ccc60348d8070c091643346581a7817bf4984006c555772af6f514d2ea62040d6898bc86d3aa996bb63b22f187ad1248edb0b89470bbe982f62720b170faaece78f4bb39ba5237a848bb6c9889889a5c8e3d2419daa92f945a886c3db672f9545fb3d4ea47abe2f90bd54baae216b2d9c1b4cfd91f3a3eabba0e1c3e749f0052c92c3f7d6d7b4694456aac4c5e86bd239a40daef239b6bd3dfe8999260a72555b7863d59a4d32b6f6532ec03faa5234f4289efbd5b7583512801a2b9ab768726c5b05b0f15343e04a1744a42716a18925175cd4b55c3b3a16889d133df8a86e83fa763c77496b73cad3cf4075587548e98db96596e638aca2759c028c411f3367cd9c904cdc75d3dbfa78c1f2143ca1823f714fd734bf1dacc859c4241cc41b54bb3a1e0365c7aea33e4232bc29f73e178ce52e25418a0ea2498d634345e2424e7dab4cad9daff34ccb6046d750e65f71caa0726f0b9e6fd0e09dcc1d7b774adcd333aa45871df07a0c8d2d869b9660f72b5c63dc207c96d6d17915004432a5f4105828282f3bcfb4e7822831409aba5bec95664be4ab2786edb641a893f1f92d52a348c22b931f5a12b66a462648d3d43d58156b19a7fc75177c6ca8d13beeb5826b35d392bca9be335089874f04a9f8e664d08df37a8a804f71fce1c1e2fda637ba57d60550ef1f3c2bb3839631de4299e71cff3958362800a9eb4536efa5f25ea1b150f5a6dfe38dddb800522e391d0257c0bb6d1298b064301bb43acd583ea1527b0e3450e6d2fbbba650a5b172666001509d8e2c12aa7e3fbc23e3c73b56c2823cdf4e0eed0ea0166833a2b6f1ea0f5268b7893ac438b0cfb0f8f99ff8c59caefc401ec6927fd5ec7db5d4add47089951d4122d0edbcb39e4cd2fa3e069efe7ce593a89b0dc8356495c79c5ef63ff4d43085c20348c07d0e2a40ed30e171fe588bbea7bb4d5c87b7e58e58b4b90a351789fe428389ea7eee02ae2bf9f2672cbff8e2cf47ddb48762a73d2f29d729b01f4c50d60137c0949d9e4ee8a2529229878470c34685a911a7d9789f1a6c1fdcbac5fd931cfb182dc9f29e5836351394bb409ec7a2e1619e30cf41ec521752c223a28161f280f95592893644c5f69b47ce056352dea8ba7ad6e2e46830ae0dc9048848761dd1602459e5729c614d43b84e317876f9ebcb17b4a21af9b76cf562fb55cb1a8e94a7ed006d72349cd1be663de81c591edba03f15dd29df5eea677a5adc1be4e3b64433610a24000cd89f571419e24133dca74ad9f865f8f8ecbe4ac4eaebe6ee6e1039ec0d68b8919fd5080ff48da55f6a65aba270d724e9327ed1c3ab15dd9ec346b29ba3038f344672526663448eb3b2d76ff9bb87091ab7363b4ed5e7e7bde6016b0c3456d5288e0b55ceb429401073c6ab6c30e90e18a62ccfe8c6eb4e2a2e201a90b661ee8abbc45a86fd300cbbe4cb99b1780031942d0ac7555e9df5055712ab0ed4cccf2f7e2e5740060173357ec9eb7e5f8b06827d82d38084b2163308353f058ee70dc7f722950edd7968bae81b3acabd3b52d80394151f83938536ca3ae7576d2c7b34ad243ae8b1b02b3e2bb627115926e0fb402327c5d76393ae7d9d3a5f527f65d763f9889ef15af977d1b5f92ddc0ce241f99142ba9cdce6b1cebe6012b5a042b0371c571c7a98e059d77acbd6f8e38bdd041df7916f6bcf3d827d3c9ba3f2a3d3c293b3160e0642f6e2cc53f3be52048c2e26ce704a69901217161ab8134f28e911afcb705551d6854b9eebac34fe5c34cce804d7a0bc1eb3f3ece2f0838ee2d67fc35fedacc871736e4ad53be9f76a7cc47eb9f8676196e834b9c29260b3b9abdf9aace78a2c624cf49b3d82984b923df367f640afb180e98eee626220479f0a2c94209efcff371cb67076477af004e8940bf5a858b22b9d5ab74094905676a5d4d16170fb54ad325694e504f744ceb4ef404256f542d27593be98aaa00d6f586dd1a0429537f423aacb8633a5a61df73de7ff2be70d85081a1578c815d9ad386ad4e6e1743422f1cbbd3b68c3306ec36416a1967841d3dd8a845e9ebd439a2cf7175803a007ed68eaf865f661f8fe8eb87929b6dc370640e6049e0f098dbe7756211819cc9e120501ac6c3b7b457a3f8dcd1479780d3506711f2aa4daf049c4904828f61e8c619558ae50b54a16d5555b8feb9a3273441fafae3f040c4eb183161b424ea27900347c52ed989486902ff82855e918ba7915feb2a16a9473708d49d06c1692f79561d4e1121c7cd817a2bf801f9e7bf41e4325fb3376ce28a5fb112160b53099b47e72aa64dce1d73ce0b6c273c46a86c8ab1c568239c98badeeae95178698413057438192362616080f1a948e5c20a59793116b8ed183a0a30f6ddf7e2b5f2652e04a2bff1eac2abcc47c10d9c4863760195fb40aed0660671d2411680050b9f3c41d0fa1cc9a8c13c024c71b5e0f6707507eaac59edc0cd683cc6e79f23e270d7ac061977c508dddf0b0eb7981bb80b74b5dfece62e7e11e00abc4ec8feb3daa8c466a480e918c2054583ee8042c430d03c41871a04a75d6e8a2be55ef9118bce529956a0c91d45269afaaa078b9865882629fcf746d540cafac86fd44ae53eed0689af2adfd0d469e39b5311e29e38da85beaa18068a1bf01d6ba1e9c03d8a6fd2e3607e17ed5bc00e974b6f5cab33a9fcdad33561ce5c6c17208109cdd616cd3b92f2cdb6d33b1c4b2f02f008ea6b2f83dc4b33b0d19a260b18964c1e14cb1b6beae4c49848ab20bec28f7257fc6732d30ea15fd2680393daba9c0eb387f79e50c668cf56dd3191464cc83bf6271c0097806a7b6e832ac90e60dbcf934e6820061684b87cfa742a862819dd26eabbf2b1c15db710069e6c04e183802f1dfdd1c2a82cebffb81192fcb2be04fc78af19f5158620db4f9d1e8339fb8e18f53e42033a7e3208998cdaf84121fbef87f2d95936b96b8c3479f0a37b6c29b42ebf0c33a5e5d81ab5942d85d9684101f4240b36945a2ea0712e279e3a16c21fbf3dc35817a00f847c81cefcb4bb5d77196901097173b8e603e91029ebdbe77f00f6f20612e71529297fc9c10e56fb8e7bdb585a510bfc8fe5ed66f9c2d732e1082f7c6116f5ca22d52ffa6b5c96937cc26e0ff3257fd955d683b77ebd4a8bc6d8972a15c94eddf1f3baf5aa196297b1adca654ecf7d9c2ae2483025bc5e3e700e74b09ab05559f8842fa9727c56ede22ed7620e8bdb481c889a601a6dd753e1b1a6191e27685beadaf57d0a21d3c653c05f659c33960eefd6bbd105a994d80ea29a20a410a909d37ea3f3ff52b7a13fe3a4cb8b50859bb78cbc04fa530cc73c5cddce73c7f2a88bdf460bcd05f9c4945a34b80006a4bdd46c4eaf007f236a90fd0de86aa08ac33f5d58807dc71dd3523641b72251a290be6ab12922bddfbe949b81f5ae1259b37e863dd85aa153a54884624a6ad1da728b8f4fb558cbec43a4442e930d0ba94ec48bff143cd9828fb0c78b14bf34da82f8056f589f5dbad81f35655428a8916f6b1396e25d70b9c1ddb53732be8df757c67aa7da141d80ea7d36139aef826882a66958ca6ca38ea2bec7bf4cd34c683aca7a9c9f0c763c073edab8ecbc4f90f831dae4852a70b5dee378d84a500b8f1072eaf30f34b86f40f1c9fd6fbf6e59fff47657b0fad1b266276cc8087de73cbb09f4b2cf212bb1b9a031da635165dba8ebfc1929209ee67e914e9d254ee1c369942cb6616b6fda5feacffbbe3b40b532aa81e4440066fa020bb76e2fd95104e98ec12cd2ac9565a64a72152b2d2a441260640b3b4f4ea0e783b5308155ee87c7081ba98cd2adf6011c5c0cca2ba8e3938177f5f33a8b13ddab0c96050f5ca916edab09f95321cdf67774851c030550f1858e2aab62054d9c05c31b1b7201f65cd161b4769c7da371a7798d58c99a6b7079717a04b89dffbf5bca531a3d9749b9bdffe7f759d296050ba6b6de4bba01168eab598124e543e3aecdc3f30ad7c74696755e81f0620ce3d6d8386b2828b2b7b48f2bdbbe508c1b80b542d6767c34a8d5857ba244200f79863671b60ef1be15f0d3f7031e1f97adc715d62c4277136229918cbd62662b95ec8cfadb1c2be27b9fc344bd4d05ff4d05d88cdb3eb63389449b190bd8b49243998492c46899d466db4a0867f52ea3d2a92b8de848f4fe165632e34cca23127ecd57e7333ea2721ddea4fe551fafd26b13673c99e6bbfd6cf8ab4706006903c394d5d44e84677af03656a81cb511ffc0b8dbfc3e9139057f0ef4d6354fa581f9f5b2954d8b8122cbbb6e12589fe35b85a546572d004b7658a0395f74e7ba3344fb4fe9773f03653c6f3b72addd38d8371a93bf8e6a003231ea0d7fdccf9da4408ad478de6660615e5bd1cf33d8fbe707cb82353d528634f4c9c9feae650f9fe7f1b085a24f98be8227c926027301e13c99b56ff4f6a277913fac9e742eeb2a8c346725a1f7dfa88bce31c56e128027b841697cb4012fe8d483bef4a4c60988c275765ca81cd1d00946afa3414480816b5de99cd9684c6bdd008e1253bde934cc6f1068a7f08131c41facb0ac5405ba0f60f7c9e0e03d8d42ba7da1631b31a3a38709b5cfe946046fc46ff692bbb407cc896f0d5b557351811c23cd7ce63b8c2b463c38e65d1572d8552c5acff0f6101caaf99a436ef70710b3094a07bb60f2e1b16eb4d4fed7fb021dd2d1cf35b2311f1bb7f174dbe1d26f595076dbe9fde6af80b2174336e446008b25b76f30142829936d44b38f6149e3dc318879d711be42210a09d9a7af4df030bc6face4c3abbef9856eb4377c0b615f577c05f230b2225b6c7b63dd6164f957a5d13ac46232adfa86e66b2b14db4dad9a4bbe8fb9d58765cd637a82ed7a99dc5659e00bb20ed9a279299dd6970424409b3afdebe549a5100634ea4873850a5e8e73a6bab261218820d69f60474da8486dd0613d8cbd0ad2654f1d0baf848a01a71a8731566b038ed01730a7cc8f703de8660c181b8fa449b2abf1429101dc88c44b2e591d42a416f393b4b6c47b49d85f9c47e169313c84eb8acdf6344bb0d0b313c7b9b8e42f9e6d42de864d19bbcf217430b01b149b49a298dcd3a38ae229fdd718e25cdb1da60f44122908e6eb92cb6c61fe9098f80fc163b299bd751857bd0b8ea8a6a6e9781bdd2cf0a4d383dbf5758ce588b1cc07ac29c09b692f33840d8e27d122a13e73354cd602cb26ba2190511d352f43d1460baebbbd34699cc2843333bdee314fd97c20f04230f10476c3541cfd377782be4fd1e54c2d6ad230e64172e4a52ff3e7fb88f03e2937e23b7024b94a189742a168666ad4433a9430478772ab5d8a4f3a3157db30754f74d81602a4e1754b84097edfabf8ef7bad656b35f9f4bb87469e0a95d50c3d3f56e4252d046c3e92d83fefd757062b28738ce0c12114fef8d6874d332e2cff9119e5ca35dba082ff7aab59dd03a39119f38574562e904381914f49ee1024ac144076fe919e2d66cef8c1ea9391c23ab1b3b9be441c687c661cd4389c5ff6e3a61c00545fedd19e3699206db17c503ad4c8bc5b33f2816b446753a57f7fd0f8e7a0dedc81f8d6a2247bbec75522f490f279ea5299c518db9c19d4a57b22f03db41381d1377ee3ff8c4e87342d1a91f4b5e2987588f9ba1ac94dc2b1858d331de6cd2be5ce89763618d53ba28ec11a926cf69dc9aeb26b8fda3825a5c24e0dc77fbc361a8052af47431d4b62f7b41064125294217d0e8c8f9dfc4a0a8cf497ad8640fefdef72f13df270b1561da342fe8af09528248f51ce3e384652db9e3882b6cd8b0734f13dc63fc5327b88fd16426235ddb3169356ffdd6220bc6064f25a980401a8abbc26228f43bfc3a1e6d52e3f4487ff1db9963d9832b7a82e5a888f07b894adf160bbf56faaef1c3efaf708344a2b288c2f3bd331e2b6ebdd9f9bcc342c7521f8c7a663446f40c1e086ac396a3c094be466f218ecf962bc53190997edc0bfe8f81c76162ec14d61a6d8356b8289418732ec9877892c244c6cb781c6f3ac80dd290207560d63a51de7a8a07b1ade345da74c85c1404d7567da287c518a02aeb86639c9657711324931ed148609d6ea7c62647a2565a9c8449dc79b3cdd48660e95d12adf08f0c39ee1c440ee913eb169f159c4afa7112d4a8e02b3a32685072fe4a22791f297e2d004d812ca0c5f44b3353fbb20b297b694b3fb68e6656c3433e5f1d81bbd7ea83fb1c5fc648f08aa28f5b799fb2b77b1eb5382219e68d59815446fc6de214fabab2576cbc50fb49558b7a61f1e83150167781106aee4207b6bb9536a8426a2c70ed8799f51da579ce6102aa04a3be844959fdd4bd588ae4fd47efeaa90b6b4ff9a27dd4834012ec4b0b1afd072a13d4fc673e214967e9b86187c815be44d260b8b49d4f4e00e5f8b458800ef41bb4ad23f7bdd2fb03e162211d8d2db9ce533687550c546f6393b44758366d194326ef302838d8baca307ee5552871ac91505eeda9464112b910a721f95c7585e72b7927ec56bc1a0f192499f644fff8c20961eb458a314428c929dbcee72019eeba9c2bce970c8ad5e709abf5c988d023fd512a83f14a2093a73024fd011b8928c711c849076cc0d62f6ac5f6006d8fa1a9b671cead7043b91c5d0429101034fb356db6ddf8fdd97d67b907f5da2931e9a4fa1cf02f5d0c5dfa075f204d871d33deef812483a0a6d2be800f3f47e924596b7ab4b90dd6997fa72e03417897a622328dce366ad97d69b8a4003b0358fd25cbf9b05d88dce23f3b004258262035be010578f3e84e6ceb1cccb5169cf7839fd0a087939ccfe9a5218c8a134a730ad6539f63860d63bf6b86a34f6b3418532162b1c14f085393adb2070bb311d99a3d8722389191b6970dd96cb14e391ccfae92eefbaeeb89b6242c090ef8b87c5ec04cf12f82b0f7c007e46d5ba8df7d28ab9abcc99d34a4cb841a414cd715fd96ddfbf40ca01e20e98e32fe7d7ef08f91b9e4605548273d352626ee3132b427109b0bcf9a56de61563aa62b234ad1bbdeddb1d571dbdbd0a479f8e03ec862ae0591c0796d843387c5a22599e77da2f3eee7d8bb65b365cf6c1c7e14202b0fec4dcf8ddcbf37efb8a125a581e56fc80c6d8e71669085ce48f026b340a971c43ef1815c42baa6b523a37c57bed0fd997039710014192f5bfdc27adad2fd69631baa1cee9eb5d55dde95eb34f5840387ba0f5dc2ddaf79dde32d67023288b5301e3eac8d444afffb89d5faebccb62ea78becbf2797f711adb7d134ea27bf4a7bc287795e37d4936f5733ca80a71b671601c17317069d1d72322cd6774add050c7f31bf73c3a34b01762b01e0025fdce319a6532c59b057b78c08b9d7d94acfcd2a64d63876a1dcfc91f07a0003bb836ab3b4916cfd16eb457addcd0967421711cdea6e1ea6ad3d6e297b4577c1144466107ddfe3f80aae79eda9f2ea3143112ecb02fc93f722995c23d9180c921d5f8c3986a09e9828b86f5dc05403fe622a1fbda01b745cf84fc8d91f50afe867e7bb3785065092c2178997423bdc66636810bdb8bbdb56345400df48a86f8906e263cc74adaa659a02bd774f17b263cd9f5998423abcc8c5109b6b3e533b665a000a6141c304c0ced401713dc73c2b59f676cb054688994f9090e3aa7d4e181495a04a550574a15ffc547b90baf18f95b10351e93b73b0470f9ca45b906c21fc6d58c9d850e20a29535466cf46de73d932c1b140e521ca964c8aca56a652caacba6124cf2029c6a7b5767334a4e72fd1684a83006a67f9fef1f82541784d5d29abc3dbae77cd4e7ad7e1003e5e32197176ba3f75b9ad4568af87af234b54eafce50cd310cf47608ae9372dd73a667a39d4051330b765bf757d2aeb2ef046eab864b33b0f3197a219805d87529681efc61704680b7a5e9029d8bc254f4d7f6b9fbe341551abcc9103670f16534dad9acf9bbf458a60f18963784c15814feaa282621f2e13eeed22bfaed8fe582901476ea23bc9fa4ce7381b82d0b9e01dd593c167df3e50ab3892a33706fbc389852e04de0160ad40ef577a4a04db58b505e07a212abf537a221a1a1ca476030b1d1c039734cf89bee4bb72cfbb339ddb990b5d18daf022d541aa911abb31aa9bd699d26db738707a5e53e60324c10272f1c67d48527d39c8f1199a5b7b48e188fb3b067339fd9929112354e7a4447117ebb130d238de3e4189eb1e24d4246c0fe5485b7020f12a703d85bdcaa528d95d24893a462d0a7490528aebba83129d1f3ef1d07474d05cafaa21301127547b77f1d2897c1355ed07738bdcdebee589504b561505c34d685197f26d3c152bc187f871b166426f0d399c7bd7f442315e7aa4255d445cf2fe45a01d9e80569464a068eb5aa4c54eeddaa35fbf5f26547b76047686b7340c61b4a1a2e623531bf4956e4c57be95e114150e874af9a8d8cf89d9c3ac5a3a01b72ba7d517c5ba31dae46070ca8f374eca121e30da56ced11a877649b6a6fd0632a36a4b37840e6d7b89203c56b03aea5b2a1bb9c62182ca9f04a5a72783fe3a65350f6ada9c18c9187fbfafdaff7f9ec65ffd616352c80cc42604828f28dff78e9d49f25e6ba2a4d53548c333080c1eef7d7502133cf4c30b81cd61b2c762e01ddf5403d9a9ebc5d1f96e584b0a6626def1b9b9411d3b5d3c6db1c95935f7d988be8e31249fe140405fa125ecae16e1bde00b758798c42527a55eac600380dd49564a890b542ae06cb88d31dcf54628f6917d18ffefff24975dd52ca3f02bda276c9f16f191453cd926f9454438dad73dffd286e3f7b17ee137a39488982e8fb63ad94c7c2785238b3c4468022f74a11b50c79603f13259f78121e8a92e17a3ed51e5a70091c2bc2b605d23a52f5476b6d5926afb90e697d50e29262d27a1a79d02032481c588fb76a1c226dfe03f4c6a6cafa9bae78a1a12e725e3d0843c4d80d6212d1580ede67004296bcf6f1555ab8a684bfb8628358a8428981f07cec065b268bee0fd9e364534c9ee1eb186b32376587fa817a8a44f3518930eaa6661350fe38689b12c65ff061b970b288e3d3057b7cf75f11144e91d81aa1ae2d91270263e41904ebba2f43aa728d2d65496ffd7b83022a0440b8676a6c29e11882cdf5ad69a808c975c1909b8470d8dd5419bac18a2ff7ef852ea3dc669d8475c9fa81f6e96ad70b3f934fbcbe15019b358af5b457cb612eca36dfff79ecf71550dd56226115fc8ce25439b5cdaf95116ca0fdf6ccb6f68d1b7400ed0e68fb4a37b606c61c5bc54c3567bc104458a5077df6a0fc47c89e979dee6e9565c9e847e42feda4e374bc96e6fde2a42ffde42c8f797ae8b33b3f0d67484581ac3097592df78abf3ec2e2155893170d452bdb7d557b3dcddce25ede120ac17662d280814d5c98c68c652ae3b4bf30f5f7af466977809ce922a419278e70c10127827dedf0ba0407d2c9aa89c0091cf1f3220b7fb37e5e8370f6b1816bcea39742d26003910ecda6d4ffa82e8f79712c522b4b3601b55d8e43add0e0190ae01acee2909a8caf5744e7a2c2eef635d6abcaa59f171940144405f8801685e3d1cc3b2840629ea17bb7603d6e9fdfdf8713160958ba353067bea831df42c3293b07dd0e07b2e1af7ea9da1e35a4a7f0145df06411c10f859ebea178513ed09a83a3b9d3adffbdb71084dfeb8408bd20a89b85e0d30520b7336d5fa2f03a94552e1a0075c51f321a06efddd025ec7c6ca0eba1ced105478da7738e36ea80bd7235ffdc150ce445522804e2bd9a9c31d1b724aa17e02393762d462d486137168beb4a88f175ffc7af5fe6764e8cf23f9bf3f2c94c4c35be4e51827d6059047c091e1d92756583fcd347c390606302ba05a05c2d34d3b886273279144eedbe605f249f787b1bdeb2f384a738316b354bf38ca466f70a7311bc57eddb705af9a6e3b2cbcdc51042878bc20c9e38e90d94f14ae5639f5cb11284cd461dfc9ec768852d9272292946fe2e1efb4089c076dccfe9b0b66af14712d76b994c17935bf1604ad322ea64e2fcaaf85e923ab69e9fdb3a6a035a68d64a5933c514f59a555b27da53011ba78668afad5cd54b8a8f25008f513cbf85487782abea3c784d80ef5f6715274f78a11614e1ab80754123ae7e34e0f2a116fb90bc9eafd488faa970900b0d25dccbf835e321e1bdc56f9024a6b0a831338d92257cddffbf8ba8dbd3dce692f69573c713c607bb98dbc4bd8aa3ee93f4457558add1675e10eb24df21d245b2621c047fe455cb1b0634b0be59eb7031f2d3f4c64671f63ee0e25765489ef2df18e0d9490b51d9146d5215c899bee5de414e5a378cba68d0d29075b85e02d178fc24ac3a5f2064e18590cb1fcfbce89d67b440d060b77997b8763e3f22c435a986d63c1de1a4553f0aee08e9a22338e4b188f229e5aa7325b276ee8fb7d1f343f69049339b9d8021f414a94e17cc3d0b75512f31ef709415207a441813dbc7b893e225f901dccdd194be4887e5b60d992acee1c77a9a6ae4675ba1268b4a99bf543c1f6bfe5d4af0dc24cd978c29dc7ea9d63a82605cd9ac5616c0877bbeb81579f54179d477e43a578e92523969a6918369e8739ce4152b6410d883e1ee5382a8e926a68b449675d1b61e635914f804135277ac07d017ed0aa477bf6ac77cbdfd55dad78427bd624b4029ea7003ed779d86d4c1de7a3c0e269c6af2abbd4b95c3f97bf7cb66f58db6ee634551af8d5da47f1dbc0f540eeda19a13f6707681bacba9942af4960f36e6496458b579af82d9f8ad84db1db7bba7af80ad0df72af25adca67cda79b3c35064935da6200fc92ffc2d1c8fc0ed8a2e23751133e930ec39adbc2d5682a8c2ee3fd8a2c262d8be0169cceea43b5fbd6b8003b3615d6a5e2c4b0ee5b449b52c6d7baef305952eea5384000e31ee3d6126ce06b37b3cbab5dd809aa964d028d5a56124ca05d69ca216f747cf9b3bf73ab86d26cf2d8e0fd36eff759937c0c6773c63fb9d488fe9b67f69df3007362eb17d819fa0cfff7b3fbabef6528441a9b9614aa0f248103a233895525d6a75d2d9d5df0843435f165c483381d722dc695d616942fb9804e6de9b1538fbcc6588e4316255a140ded7d2f6aa15b7d15792fcc115e0b4e89d9a296dc2973544d3f37bc06dea4fcfaabad5a384e2cb941caab19dfc49d83f785c2567cc00a12fd262d031c65faea551b404176d8973cabca0c318514a5ceb4e5f5ef08a6bb7ed754d5743654a020fe1f01bfd69f968336b9762414da6da7dc6768abe62c7d7ca9bba3864cd36130e02ba07fec43670ab112e97e3643f7d5e3b50d3a9f068f9ef0914ec34780a2e3532a35c1558fc0c46c8668183aa3a91b386517e42d54fd819c0bd1bda46f61a6429c75c28de0628fe8ecd159a4cc4ba79d3dd1090bdda932e338a746147e07e6437947f270acf14101465dc14e736cda211e5549ee41c646cd2a963c3c28751db6726c2465b8e6df123f8bffac8e2d25fd385eb96360b296a3b8181647bf64adddeb75d234d436be4aa804934306c806c257b820dbc071670065bee5757e3eb796ee918e523e346afd6ec8a1d7ca52048da7d336f7052968bea8df14d98284ec446c139e34b27c1dddcc2bf29a0688e29aebe2534aa589e15b989b19825311bc3f397bc0e029ce28334f55fea965b6bce246719a6d0cf550b2bd19161bd35bec6968a956b7a4ad7a5de4676d52fdd7fce1936743170976c0a20f7caa60453eed70f60f70143402164dd1ffd52787bed939f8cdb3d7180b266db8620e9bf7920e3502b7255c5bf63c2cd4a97e77eedd51e3a4981240d1944e2659a26658ba210ba047844af4ace1746ee9153e38960f6e976c7bbf3e2b0ac58c8317a1d0ad64d7c3ec3b53fea503b04a21118cc49f12452bcdf4b972dcd74c58a6916a5a91a579f5b753f0a970857a32dfa02830ab12e35ea2545e0c322564066a4ad9e6799a0a4e03e25b24fae886606ced0b0e6da0e69675ef42b8e9d804c7cbe4f868ed159493f6bfd171d16ceaa3bf6905da88f4dcb343438701486bbf9ac26009996f18f4a4bd5b0ec5140de843e4ec20dc90bb7a3f53b6aeb5a6354cbf5a82b81130c4e20ebcc5f30b7b521ad8af80e98ec600dffe36017ba34f724756956eea8a48b3a2abe2d01121f792846c8a071cb88d9c30ac2f8451529dacd2a1ea596404da93c7d8f159044b05208ba437c66ca85669f989ddda985c5aca1b55e7dfc1aae2956be51777c9161b9c142e08910f1297de0e29124c95c3b6ed9c60ce1a0974fe065b3d7f0bd87fe5b62bcb5520ed38b02d9a86669c69ad892560195f79c48460be07e39a8994e27fa541dc6a7cb0698c2aaafb92ecdb503403b99f73aa36e2e9c6235459845a09267bfe82392d795066d985985a6c858c4f05f35cbc07776eb6292637fb629d9e9b930c9e17716cc4b8d36587c8af16db2ee941bb78470f5308299be000e19e80e7504a8e4e647910799232bf0f1f35cb8db34c0b04b33b8ca6b30aab597cd4b69bf0f4329e36862f1bdfc5f80b0eb5f250ff5cacd1fdaf8238a65536531cb29028cf7e097296972dd0b206a9dc8b19ba86788731d01f4c767d5fc9a35880f22427de24199e9933978ec6b46a78a73543f8d84dda68518b6d604b5d939897b27c10557cb3636f3de6113832a976dbf5bc46ded537358ff21d472d3991a0af8e4244f5c6c62d850947459e151cdd3d231ffafc3b8bcdd0ec1a3e4514d52331c77ba14f9e70c0953aef6a992f1f874e05d5090f69bcdd0beb468ff7c1b34a05b122e106d610d1ddfd1597008c1a9143943cc885c35f8617a8ff8d1af27b5bc9bac6560d9a2054985ea535dffa0783b0f091130a482cdf8649cf3c5e35922164a85284110d892798936d5659df9c369dd37ef89bf741fe6cebc2a733c3cbb8b6562625825ef9d3d7a588445346010a53579b687b512d310f46337f1bbcd095d3bcda4cadc462a4772d0c1842456d6042ebce43d105313bbaf5a7287db750d34b20d9cf6a9074844ec0400615df1e7d492974961ce462c1cea08ab108ef7bd229a0179f70c82d8714e3e743e400a87b3a235c98083db9864a9b3aea7d953d90e8c3b3eebc57774ab5402638e80b601994cbb05d6457befd51d25e4bb28009e8d8cc0a6054e1fa6a7ffa6414691d7d400b06be1f808a99e9be0a3fc271c94582f24345e1ae5b18402cdd8c830de169ce0aff2fd6f36af196e52b998c38cc1ff83c0d49757ad4ac4103668fb0601321780581e0304a3d942dee5e9852e92d5ac0239f3c71934feba6b0f42f86778ae788898a37ab70c3af5663509e168663aee354c7af1dc7c9e557c64fba484bf3c26270346e78b8a074c218936615bc1ec3ce1d4f4513d9b35d9aa50330e089c3b8ded8c65facd3223386b557966a95f5e42b4c5ca9f0ae5d725dd5061bd0729a038ea0d0d9b09b670ef7deeb8162295d27dc245a3d1fce84737c51af08e9b3c4df10c081c15f736eaca9948fcfc4101f6c44a11a943cc4b2af9f814f187103ea125fca758816ee45487c2f8b0612a424a04cc905edfdd024d2a521109fd50167961b04dae0dbd1260f2d58366f6376f1c0e585ed6eee7cd69f0563bf1b997512e6f60228e48a71495d7fc96d9750fe17b9989f3ba5817161252e3439a379489a41a38c8fb096402ddc2b8e0504cb955caa3256fae6fe55efcd5749a41de13ac091e30910a5604aa07de8326a771556a73f4d69fb6eb9abfe9042025edd11721eff2295335abc79cd61b465802db572150c83c04f958c0b7a52b41c638e18ddd03d0efe84dcbffad228aa021de7cfd2b10bb62dbde60687923935d5e264a7db46412926282dfd5c3cf16253e2f840fc48bebb60f56f2f70fd5ab9a1305e9343b701ae1455e0a30a19d7df6d89040c5efd87c4e9a2e715c3c475935c8928bed72fc48c5b948c152325b368cdef0858606a50281c7459ed613b525e865f3d61c0f8a8c8e38a37d2cd44b039256d9ee93119aef912f1b0175b87ed73234ffce134b2e4a228a52530d54de9522ff68d817e4e4f73894711cc38e034f0593c6b8c3df25788efec918e0d6d27f4d592e619e64e56b3056c54a2283a7afd2a04e66567699146719ba9114d40b6138f2b7aba71b177e477a686d6de1303dfafd26296434f958afd8adeac53edc2822fc426de4424d6f0751075f267fb58e7924ec0bff303fcb174c3b114a148aaf3f04bf7dd05fdfa2672898bd1373e990ed64493566218b33c7a8dc09f59f75cb59d7e967feb746ee7a0b500b9560eba41b629f84d4a1e33497e5a97e8ec011ed867f064f5fa5b36504791b755dcf2c82db54ed4727c4c5f183055352c2ec51e592d451b5162c9cc4627dc815eae95dc5eca787bfca0b48cf9646a28cd3022fc445c02557f1ef6c037bf6ab9a136e79fc4b3e7d5ffd42db11208452f655395835ebbbf40a4b1fee0444b21dd1cf8bda8c87f9da11cd5a67508a451adf27250cb0dd443622bead2c392decee0122bc862e3634e22fe02bba0b9ed4894cafea6137c4db0acd89be7ce8637123934b3d04dd7beead27e87aafb011b422947947f90be07625e24ecf4cc8445463d5bb4d26c4aa4da76ced11b893e196548e17e91e197fe27b57d7a99170e5c15e16ac98033ce236da21556e69af6b6e48a908ca6eeb1be6134ca9dd1833715ed71132e7070df7f4ac78c1d3c3c385abe2ab4cf12da8c1c51485811eefc695280c23898630d89fd7449294ad9c55ab943bd798bdf4cbd409aa81dddb61931215268d9d4c0c92bf125b558d3317f29e9219719f2a80d1c383407331f117aa3019084478914727c6cbe59c482b8ff2007d0637a11b36487e52e46dc7237ddcac54ec513081fe2df2ebed80710f2bbf5cf9d24ba7ae4b59c0432816c7f4b3ecee886b6fca8acd7d155ee54fa1193a9e506a8796b2f821b77027aa572beca7ba6756b0f5e3295be9773288bf90437a0edb898612c6b53e88eaf4b742d68b55748e233df36287fd4efa2a73c04c6dffe5321c171ee56675a0fccc5eb89094b2fffd2815bfc0c4be1dbc2b54e5da8324f0d8ce7887501ebfdb7d9971b339de859c85a54c9cea73977a4d63605acb10113a734454c463f3602f622f3f9699fb9eb86856c6491af72f00ebc85b99586669401aecd3b4af282f328a8b1bb8bff0b25e4c4ac9aa3e91acbe14f3f5788e638815e753615bb063b9cdca7b307f7d89baca7f25e8d9fa050ad29e5730eb133e7207e75a70c598a99f0a615498608595f8c33388994e3414eac1d1220b283df23372204da45640d440974d6e1de88826c26fc417b5cfbee74ee13a1f5ccbb63dc0585d2c3221679bcb235c7c621aec5286b41957a97837f902d5ff97171b017b2f62de55b2a99f4a1ff6226dde738647b7b28f979a7c7b1e31244c759d76ff226e7baddc85cd041f44a5b4c2e7992eb26ebb7db63b3927310393a4a7408b91ff59359f61456027dbdf120be903bc10c3fd567ab6394716664d0643824296b878b1848130f390d6d5afc8e133be1dc6d4a81c5fdcb442ab267a94260547ed85b9a19d0f7aa7a449004fab2e674f3873eab7c72de8d43610223f98fe83c3087f2cadc1ed523488c28b574ca354bde424dd8c693ae8f1b9c0f35f11df576ada0b6d50c02a8f0ec593595b05db67f0f5fd4eb96dc4f645e26704fe76187f28c62b26ce9385ef2d5de735d4e2c5f5a7a3cf298f58a7c39a27a6ff4ee071056f860f0b937cf2f4da0861beac73709406bc36ed3e1edb87119a988c1e3222968ef3a1b574f66f6c91b5b5d865e6006d45806c6a9a2859b53ea5e00db3d3aada986b8e198252882226f3fb8bce7ddde41e163ab46d020a4c88eb83b904d3080f849796e12ae28d4130d9e9c91e71c86f12fb7550de7e3dc48b453d417fb790bb2a29dd284d53ac979f6596989c04276f39799a55b6ce60b74479570a12166d448866bb4a6338afafe5cc21a186c25ae8f06fb0e6b44ffa1fe5481498584676c7b3f1acfeee4a28551ee31b527ef11fa9ffc9766b9b0ef9aaf49519d3d4e34683423a4d0fd3bf05ede88f98d0ee5e30113818640a7054209d9a06da9303773ecb3d38803482f39f7d59262afda8beb129dedb7be80d4125ca2155c5db10187cdba79f867974f6131673824d7f02bbbe8649d6b904ee89e0b2db3ef626b4fac35e6bf58bda3443ab374fdcabd0e4a5b707a153cfa669df99e92d68d61d99c099a18a37bf2b7bd4aaa91d4c26d07e16f3a37909f07f3256976f5c14ec6d192a652406a4cb205cb01cd5ac24f8d178f7d4bdbe5af351a51055de08e9fdd3f7cdb7f391bd3821a1a568abce107ddef503d5b0be750f279eddf209303cd6355ef49a36b243cf4abb68baf9a64d97460fd9d0bb7041ed379c609d5a7c05f77fea7737b19df0fe80bd7c5bb54d69bb188d21a0d36d5e808ebdcd9dc957737e16a4a0b2b5a07600a6ac58fb4860aa6ab5183102e648bea6878258bbea4e3961cf4c9a97bf1922d3127d410e8fee1211fabe71ae3bb58f4a1119f419831219afeca3df34020c361005879087cc5d97a0c7248883ba014a2b4c6275d5262a63a385a41953491751cdb8d6cff5aaca32427d2c768e9a53579934d024f6997c116703378c7b9339d2aa9eea564de0a9cf3318384567133514c3eaf5466637a36c3767715a3093f91d9b174f15c46264a300d070f6e28cb6775c1460aad0788354cee21239b9d2c63a64103c612f80e88f7ce5cbe1ff1066dc061fe2be6788e4d7146f1f8d88eae728707162432989955fb368ea9859ec29dfb270691f241f377e0b95a80d035064fef7c6481e16335458ce3c78e980ab5eeb76e96725ba23d813edca28742f3738f761ec406297fc05d30051dbaa3f66c7c704f1e97ba60010f8cd353bce73af31f71713440627926304880cd5bdf71af64bfd193828a9e6280675f0fe4eb57a53f1f594c501fff5f8268c671156cf66c5cf954da5c2237a8ac02e68145ecd5d9a3e3776fcbf28e5df086305be4c9a15d6e0d0019e5764398cd4153036ebb1a4f0de8ac12e4d262b49f7692e887e844e85a2b8cce95bdc44f89b8d01dc9115b3a25bf4354a2fc80930fffdd79258ca77cb7b8417acf595b96c2ad78dab628f18d747b548a191f62f7f795259dbc1a5fd7233080367b89858793b0df6b6b4c97b6d2be2a3b6df34421410e6e586d0586f2a78ed61e223494233459201b3892c21d43ac10e21de02600d7fb203d4fbe3951813b2e9c7bd6008df91ebcb987165400403f55a82c20f84629a0de19dcdfd0e5d6fa1958621d445415b035fcc9c35b3aa2dbcf66c1145b95ca93e547ae960774e0c510b496044d05e942ee6d6b94abcff0fa6b50d7d87279045e65ab30e0aa6f39a529880965f118fcbce0888b76f5be807f743dd9320f91a929c28708d61f745ecbd9cb0a5759884791aa732afe4a273b6115f218d92388fda46a544dba31c127a82214ebd85e4effa2e18f2289d645bb513bcbe6299a08180d1b66a49a87a2cc1cbf70fe61c11ef540b08f612e2dbd5352bd023fc85cac7e0e530cff2d2baa474d519b6999a18d1b27c4bb746d651cf8ff074b98c2024620b2e430d064f3069005c5b7efa0034253f3e2bf46b49b4c7a714ad6488c623ebc5d3d290c06b1fb05a1198f7732d082f9f3feec402a319f0ed84b0917618761c77ae2594bd02e62bdcecdf7215c8b2dc0638585c938dcfe3f7aaf15fb458477ad04acc7f3c270729e9f6dd423bdafa40fa15ced3040c8c6b5d620f35310f6c715b21150921a66ccf734b11653e7aa86e678bef6525fd35ffa86484defb2fc9410aa6d9bd86b9a49385ecb4c1b97ce0956f5e2488a24cf3f82d4daaab608a88c63428eae88aaa781f80685728db2d10f78d2b72502c2d0be16c19f7ee3931adba598dd62d4f85c2c4b576873e86292e81c1c0ffb3530d5539095c7855138970e89c45691c989b53c9d09235fea044422fa3761c798660d1eff8fbbbbadfdb379807a075b97ef0a2d450f2f9a3580a0b05ec5c471c6cf49ee066f6f20dec5d9cb6e3d91602ba8170eba695eedb4e824c6f774e75336163fb8c21d45d51e55ec57bc02b19e9b9b83bd70ea6f377ca8eb0c5c9547f6ab82f069cc312b5b9481cbb81b52a5f3afef9330050657b1ec0b9224933433ef5fd0dc380730186b6f45e3120794d73bb0af63b90cdac4d744cf4c3652c3d5ccb0d6bfd0f91160227905966da5b46c2f4b79d6079aea03cfa05305fabc5a0dac67c30fe74cfd71afea498572e564048767dcfad3f0fbfa0ef39f13d5f11ad62cfb00831f825d19faeb2cc70279995797889f568800a496f5f0b21003e5ad2a59ea0de3614d9a38c9588b446acb3083b109bb909e3837ebaa0d42ee0ad43a23c6617ac57f7baaa04f3d1b076330ee49a70809c21fb8953a6ee6bb5a0eeace223a04bfcd5d1c06970e8c19722dedc22db70e33982dd708aa6c1316cc7efc19570fca00c707c3e0980b3823e69ab354341842a22520e6e4df50e29ec6beb2fd0f0f131a43d44ae6d79963b6e064a656ff1e82dc3e9ef9087818315e4b88fc7ef4b065ce3d0d5decf2e0a63a9fdbba7148232fc3551fd72232e85f93c91c4a018a1515b9f735f8da4823ab9d75047856bab6f1f1cdde0e0787a59f0d1f36d8ce99be1f55ceefefca8f90cecccd6e1d771ed62b8ae6d41cabb1df1652151a10ec03b4e0af7c54b13cd4fc07130687a36f63dc3f7f0d0e3a240f530cb42542cdf59fa799bab67f4677220914d1dd1c91b152f78534ea2d211abad01d9f2a7c11fcf7d36634dc6678b150301d8374f17a4c57f67b512db4dd381b3a6fd41a5cfc4e331363ac71bad9dac7d362dfa17d95b69060b41281c035b06e666f9ecf6fabd1dfd7bca30cdcc5606a9066ee7433659088fa208e7590a3f12c9cee581e4a9a9fb2f94d3fdaf21d7256b386f7191c1f6e21068f4eab99077484abbd6ddcf6d7dc43e7b19b95fd7248abaa2c93ea738678d01555aa1db47877f27ca6d06cb1f7b0371d8d78f738b2b8deca00eabda4b4c078e747a68b079d585f20040b81ad0255987ec04e079d57542c331d40ec902d6bb1af95369fec1382a88ea59e55000fd289e9a96079f14f1ba7a8571dc20c6e9351fd4374e98933a14c0d7b14bb9cb03b2cf7defca37595761d2d992e193fed896daff4614cad3bc77c548e866be0d3e8b0fa7b604ab9ea358e23df420d24f5a7942ab040d1bae1cc0f4bb637a12afaa522066dec5b4c8b109c26852c80511e4021a9da9d8e4bd7e1baf3254c0c0e293e6a211ed8a8d58156f8f7d85336769a2403c0875cb45bdfa8d27c52c6ba353ca2ccd46752406842e61a991f80fb371f4b7792c9aa3be74c26ad3fef61f8372ac0760e4cb8e7220463d05ea3eb5da03815966471dedd309d9dff840e7afdc2aefff6c46093e5bb878cc77abbe7f70ef165adf3cba03c908e5168034eb40515bbf7871bd9ceb9bfcb510a1e0cd68d43d20474325c489bee222a506606ce8903197ebd60d518148da10eca7869c9fe34f130e802cb0926dcb210f17bfc602ab29b0a397e874577eae746897fb4fd6c0f6c6b7570e1c0d5071c445df3bc87c88856b5f0f318fa4ed32b89b90b88dd9614ff7f03ac1cd92a1e1ebec90e50ba21bbdbc8f5978b62eec367bd5dcb2cec108960bbe25b8098f741df458d5c1f7ab8859133b29b475c6a298b252a6cf9b252d53bf0c3ef48d332277de85fe44616e2c5005a4864b5755247fe7ab1184b46aeec01487b28b214961a4a65df8c056fa33c9ad24079686ae819c2f7232916f54a269ef94ddc0ecea7be430cb1747ab05a83d7b6bd361d9ef865a4893b54523534e1a532b87d9c480cda830d56ac2835d5a78426100c35cc8fd8808b3020483d2d507a85bb9ea0c52140f9439b48f03b62a1f8f87e20690637310017054790cc482967aa3c8faf67e4539bd2002f27fc5e0ede3a2f402f3d5f7329a90acc0f7f1db658bb6b1150683658d6f1b06381e4e7190c941129669c33b042f29688ab4bd907ead68eb94ad07b4fb75bfaa0db6a9b0c1a2639dd67d23820a0934cb15da0c049b15cd2fd846427ab6a0b0d16f690c55a9a60cb932a92a3be7f8babe9d27cd69c1d8c2893b05a3e8d9861718a1df707cf0bf6a5ff2afd0c685704673ca47170404ecaf7dfa93cf876cb8b50ef3c73eaa8ecca1e76ffbe6e82819d70aa7cbdee17bb052afcf50b931ff8a37b3118514d73cff721402249d19b9bcfbf116f2b54db70beab267ab61ca79c4141696b78c381e3cdbb5c676245e0d1500bd2026eba0d1917f40e3aafa381f48d12c47c1a2dfd825c528391bd2a67c21cbd5302042a837d13419f31bed0c26d86beee727c7a6ca081582c05abf2678761c474986299ca18e671b6a173eb3b90a1dc80ab9484eea45e083d72dd35801115d8b848c97429757856f03e09d4c524e652216de4f6d057fafe2a1dea66d91791ff7eeb1bcab842f91fcb62531eb95e8f82fd83ffdaa3a4f5665f7e36b71e4d7ec91407f0bea771ba83ce46e1ebd0f39649bcc2e006d6614de33031bf6aaa272df1380014501f4907a76c910c73f3c81d3ee505d336794828cfb4c0a80ba68d73e8583505f76ae491c5ad5909ebea19733ac81e318783b2a5110c62c15876b85848391729c4cbe73ac9ad01f9d6e515656753b998d16bdc9a7963f5a3b97ee11d97c9c0cbfc8291555c64c39fcf2fb4076680d52a02bfe76cda3147bf01ada82fdb4faf4de56f8219fa80a3aa52c86e3bc0375a495622148e8cc1078b6c887777a10789d0680f65d2a0f46cc1aca6b877d440d2cfbc276aab17edb6d56e40380283a55759ee5d783c6d40b4d1d3a83de5b11ace7c1d5a101a7032d96aad09953e5dc617d85afa16ca3773ce082efd42e7d3b6a8a305a0ebab50463404307647b6106db0de3f67b9d5100d78c2f7353ef154d667028d1abaa026e5cef677daaa0e770bcc813709d01102b53f51f783ebb636594c14f9a384ad39133b6156ff8265aabd822a5da0ee106b22d049ce8d1e5a0f0e8a3eb5ad007bb5f893b2561c54d370e0b44d74a6ddb0253fd70fca3a3caf6fccffac686a6236a552c21ec4a0933a82cb0e86cfac6b93ec3dcd6a5aae3e50032acb386eedcc0eb49d7b07b8be3d3af87976a157696fd55ea9496d424d3aa8a702556e38a6caa9ed2cbb579465bbb5c76ee80b2c86d4a9dc6a2039ce7e253c2db38f361f0802dc12aa1172a073fe8814b5d4dc625051faafa929227888f39c2f245a5b755c4d467367992b44719e73154be43830cedf9cddbf4ac4669f47f6bad187b323d2579300660644c4d9bf43d78f5672d4df301f6782060125c124e2e8d1591033aafb95882fc451d3ff58eacdbe88ab5c8d0dbd09a7255ba3d812e515167ace2e083bf8dbcf88e742822d65bbb7cb4dfd7bb24e55d8bf88e5badb0309a6d826a3489a73ede93b61284918e5b36d2485579c9461f2a207fa8d1115a0af725e39e0cb9350a1e478d0aab15e4ab662b64e9916f8441fb6496c5316e67fedf9e7287036671f2e1482886592590dfc24d445ce3bca018859b2400387f01301398eebe48a682a90cacd1b95dc6935cddd33ebe73157db7cf9a7cacb3e540054fdb8c1a5cdf90a6dbc52a394a1962950ec896dfceb4192f3fc6699f80a7e5c60e60e1769c0abf44975a25a1bb3c11d390cf4bf2b7da614cca5c7ddc2ad281246f0be962c226d95fa106c6dd568c0dac8057712e85f85f8c7dcf3c1cbd521d043eff094f9de3a12ca15c472235db5328c7bae87731435d369e2ad511f4cb6d857eec5bfdc4f71f5881433fcb977762381b08610f25d4ada8b16a9fe85ce9c668975e69db71c5777f39fea70e3f351dec49cddfbfbc078d86583a0b981d6b4e872c062b27f9bd3ee80c35fa7eee070a29d454d20f5ef48cb79bbac693ee9f318be1050a07d1e9dbcd46390965d55e26b45c2f0bdebb413efbd26fd38621bb13b7e196758d46641d67a72934f9a5abd85c2450cd7d7c166e52d8f541deef625fa69150abf760ad14d742afc9cdd20edef75779e9b5c1f07d7b3d60896b04ebe2ab97f2b71142497581870656605f5cc102cd01e1be320b3bdd99edaedc4625e464ece51ef5c18539ff4ec178f3ab2d099b84ce519a3b5d585200827400424edec507ce1e35dade8b752c16ad1acaa250bb301c32a843027599d6824193109b2114dbff40a98140f3b93e46122582f94459d9ec6a1cf409c286654db493397083aa661a5070917ba38ae0ad3bcfd73a5f4000852c55a33fd784b6ddee1fb103d91ae9fbb26e26133346a40d7e9c71980f88b85b27829c71f70a07a9325ea6275e3d28dc6cf7898c74aa916850b31b0499245876765ca0355daa520848b9a0a3e7b0473cd1e80b1b7a349315614d2ca421180373cdf05770acffc9513a41bcd2012cc12855c6f658c0fb90abbc6981526ef87456a05a8a5a27fdf8273e290a78d14db14f1f97a0fd35765f2a67a27f50efb001e2e867ee32e767ed5e8eed72902734905706b242ce5986a44e8d729ef6e0513c361710ddc5c4f927c4e14adda96e4f6477d90785775e3737d5dc336719ddbba9da536cc44b2f7834dea1dc442557fba5d6a47d60eea02167a0e43a823f5a185c70cebff16a44e2550f33f8a2deb9fdcfd1104bb32f0347651238178947ecd37c45f6ec6f2c655b5f06620f30f4c607ecb58fce3a878410f3410c0a8ac0a30222bb7feb8c74e5a92e13d0f0153a24049f355c88341d8e0b86ef76756c829b113403541a4196deb3c71a0808f940f089df8e93c6f6d2eb09ddeb2b84f6a8874695bc8bfba21ecc8c826ee03d1628ba2c7f86a9c6b9861b34097fba68481d7ca502f664f8ef88879a35db0243af74d2e28b716397ac441485a87aa141e6f9d49b874e4e4adbb275e87a316fd3841adea2b754d7b0d746ac88310f3c3e0b612ed997c591cf3384db377f4c3d57c4b5294ce0e032ad5154960c44c6df18bd6c5abbcf98c26db3ca7c2e0f7c08d01fccf2e133ecc677fbab4506e835de12d443657b24e466997a52404cbc30a0250229d64e20512dcf1b0fa1341dd3c5d9988fa80b19804d8a08ef76a9a82f1306e25406683398b49c7aa1d5727bf59da96a7632d3a2dabf29f0ed043e5be85e96c1a531f3448ce8bac9b8480a72ff3278e41e076774b86cca6e925d0fd0a999bc1b87b7f50c2f25aeef1897ab8b8e684cb747f963b2977e27e42d69b5c2eac6f7ba42cfdb8977422b7ee381ddc95dbcf1b29bcbd193938f851a2f0ba0a7197b4f1a9e7198fff2521f822cefc92eef903e86f0d09e9e70f2ff7a5f5d34a025c86e8fc31ba6e5b5f5468a2357e578c68b3761afcc28481b5416b54d297eb2d0320cb6e24ef163ba18db2cc4628eb0b6787a532ba60b23ff84b2b39ebc5241d4dab79bf541dba3daa64c9b7e62371cc4b4a21d70f6cc4830d035e6280e09b62db640108d20abcfee57d384225d8bc3dd4fb404db7dd221a265077f5fb2c483fa77d23ec32af852febe30a8dec9812f12b55fb7b3f9de89ead5377801e60950d2b4a30083efe0c85d0816d7976d565f901f632fc0091d463e2c1688945ff2658735bc597e191bf3b6bc865d771c94c9f662c014ff7a7177af602919bd180045e6a4a785f770d6c981a47dcedde0a2c83570f560b2a4854c8b18047a527022a4110d2b3558a38b8252673c2269e6100f7936e57f01dc263c3b1701db803c049546cc06ae9ef140df74c29a4f5c3d996276267e3bbc4ebec7a1d07c24265dba122a4a44a9e87570a284fbad786f9582955eca2dc38c45c8395d8733b374442d07e0a6a6553a6ab999f7006a99905ff58dd2e44fc6ba9b46af74b2e817357000549efc840691ca50944e7ae1947ad338eb54c691f4c5c6339955c7424bac3b2cae3ecd28eceec190a4cafd49633b85212e5dc826977df256b8ea60d912681fa32eeb2f2264737131a93161fbcf944d87cc5c90d5ac7d1a2700ad2a6bd511fb152a3ea6a953685e271a2b16477a7b23240f7822b2a1e2506ee0dc20292f81e5dfb60087be8be8a93caf4493915e16d34071b8019da27a92ecaaa2b87b607c5c3ed2b3e4d460a8991f48d8984a05186b47bfd8816dffe1eda43fd399837ec74d75b3ddb4a082876ca6fb0852d068ecb5f5cfae99827545e70ef7da3b0387f6aa58714cc8a77d43782f9b68a900d760154d4cf28cdeb02d711e3dcc78b6057e912624fed6f7c55b52064ec46abb60f30c7b4a3e3c068a58f036615aad87ae4973148ed49f972adbb70400a5dc87da89fec5219235be2dfeeb4b27e1280819cc48fb982d2022c24c35582169b8fcd66e3ead91407a6c1343bff662e75a322da36631fb7a7732bfa672139f42e4d920b2a11a8f3a8b123e99864127453a986eabc0a26208a1cbe36f01490c77594f7294864d3760721a334047fb474ee4ab3f1679a6de31d48588e329479dcd677614e254f9b9760b583b05d99bf31ffe492272a3b3fe404e86abad4cdc6531fe9a355193e55f4363667b2fc10f97a89876c1b0c563fde0951cb9f911ebf65f80d6e1be77eb2b02603b73d8c5bb67c6998367c87f202fa46ee2a4e58f464b382b0943ba58bbe6c97f065faddc50feab01c3271863cee08dc289b544edf72934ef8c59f22862b01af70a044afb470e3e17e04f6fd01e50655f5c915ddcd4238726ad47cfcceb8122bc093d19f8443f02a52c28ccbc7200a333cc090a8253cc7ba29792c46d9ed6e3ee45161b4b1af37ce27d02aaf9c695471a4dcb64ae9090cfe617402c65ef197fb869f33489c3f10b28c4813c6b0c44051e57fec2769d0f4d2a425c5f59da155ec0becbb977331b431720f8f96b943e78917b698b7b2d8cd0873248b18392162eb8019773cd03cc07aaa623f11a21f27ea8f5408ec1d126b97e6e18fcb08b400b183c2a381a81e90872020342450661fd203fc56be68c621e87fdd233e3fcadc2c80f335c0d25e70e8ab840ff150b9666e20db277a9f821aa880cb37ec422a0d4061ffe41c746b45cb2c4b354802fbc250dfb5876e934f7987deada4155f91d40521eb2cbd773e1b7c5b5ab3605c934b625e7b20e3ddc17a1decff4d273155af42d77467b8d11c6fe3840e9b47d6b48bc0a25312981a330491fea6ee0dc04382437c906bb190ebfa99be670e01001017ca0a4912b62c53358ad63d3a869c498dadf2836a403cd6784fc5f000c4a0023e27b66f3183e2d7404ea8a50b2f02c01eff8167e26caaa9aa21f4c9f912bca8f983de722c48a253c72e63b0011f45c65af81acbe8cb337498305b6e9f4b4e216e609836098cb11a0b1544e0a277bbfcc8d562bfd011da22d6937445f9df0961e46c665955fcee146742c23dd1484f80f92b903b77a825d2aef77aedbcfb4d10edef1c4202480ac941304ea2ea92704b83f6e3c9501694e91015d08afbc05303f5298f2664d228cc61113f65db1e6be721107ca5628c29f964a110cd6a35963faae656659d277321c20b0802e1e0cdd8cadb642e8e1d017e240e12c162b9dbb75a09aeed6c0aa1a5994a165d5b16cf4a12450171d3fe5dbc1f401ca2d6a62725eaffc07d60c75ce82ead11f0f7fd558d4cbc3e7fa879ae6d5a3de6e4c9a648e783531a715bbf4973e170074cd658b3b69f2a36964b2a4610a54196978e6b0dc2fbe2311de6b22d6550bb818d1df01c7e7ce94c3263db3cac4b3b6e302f961dde7e9f160b3cff748efbf1202079a8028534f4c773e6da8389980031aaa63e80c527d5d467b5ff4397eca5791fbe3eccf8768e47c22f10c1890102685c60060f8e59e3c5e1ff1e38a0df4d57d5f92c8409554dd68261928efcaf01892daa5faae836026c391cde8b042125a29bc98c8f5455da980b9c59bc70e8278b467687086f022fea3a760b99e70670b9b26fc5c14ede0f2513a2fdabf9862c71c40eef8f2d76c98c20ede7b64a6c90899f51b7c3e81fa605c45404a8dddf92cdaad53e9f0f04d21e4194cd7252b5feb4804b0d6533153b960fcebc1379e0cc93f0c42bfaf154003a0fcd4af948b16ef25f082920090c92858a3751fe4e72730968715149f74a98608c1090cc561d656e1b7c89ec43a1b61a16baea9292764c1a7f1823866501be121f98c576f0d03b10d1fa7aeac440d4f12fb71b72417992b90ad0ef434aa24565ec7af0f125b88125b523a3643cdb7b6cdef980ad2acef0b45e370ee9e7c3cd03933cd26c77d84d9a31c0f6006a49ba28f07f4f1f394a1c15692a5103b3b03d5d0b70e77cac439f8764255fd875361832db7225ee57a77975d283a2b5d56f5e71aa855b84aa369881e0269ad657fb06ba89f4ab488822b478b4cd36f48874a7bf914ef1703569e3218f030af332332113b24273a9a6e4b64f7d5891464cae616549e060df3ff89d9b1a03037b247f984178d9c22e4f7168d2b8507460417f1e491f02c903ba1bbe260aefa768bcb048375ad970f50f41f85a56f5b6b39aa97c177d4d1a5d02da81c500075e515effce970aadab82743682442ec23203b2bb197516c987ab12a6eec25c8c52f125a9be9b59a522a93f10d61ca263b0f1ef87fb92573ed9fd837ba966657ce433b7454c854dbed21776ba1e1b31c8ee331456aeed3bd3a8bf88133d39a30a554ff38457cc68e302e59b6e6afc883ffcb834dcc80fac8d5c6a99fc8277cb336f608921648ca970c82fe2e1bf0e625eab2a1f044f759094bd7a450ff3e82756f7bc21385a0c6a74b73872408ddd51f59a2cce388259e774a449eed36fdd75e3b64c0ee5db73f1d993e6751754cf9bfe66110ab3cfaa22838859cc8cf3546691c6f8d18e6572f1c6a58e6947851016939de0a39fbe1ad999a8b988c4c302146b377c705e8d5c43a9b80c8dffce1923cbe288b0cb0cb7ec233d183258701df59e3a991a6d02b49c5cf692e6da43ff99e1863a838efb82c076a9240fc82c223b262d6e7625e097d87abac91f8dce50dea91468f2e46305b82c6ff6e01c15e940066ae2b038d1ad851222944970ccc633180a3af531ba995cdaf83416b19a61f13a1561a94f4ed051c40b2ef1ec074d6ef5ef9c5a7a6f8584fd126f5f701f4872c314fe96e92305cd04e665854dcee2260c9b5d34d69ff6609098f857ef1d2aa8c75caaaa3b25d370f6be883ffc0f4ab8f63fdbd278d5e8f78e1e815544de8d9a7bd1a48bcbcf7634cc745afe256acbe6cc0dd5a2c167fff27023bcef691734fb80ba19f2650957642cc1ba172029d4d6112def0d8fdb386ce11b48be8b22c9d60edca3c313c7655de3a91b54d80892117a132f0618c3b92d6051d64d4f6ef8f38148506b347a3c70a023ccb9cf45c12da6a6f9ed1c13af919aa4da89ca6272fb3612c76c7a650b2a14b7c30a7ab1a4d356a658bff577326d3bbba2745b163b4ed330cd0e7ea9a1bb57cbb2e53d42f5922e5dc6219c00488a8525af351c00a7f2a2c7baffef4c25568e266954a9500fbae70293b8280614ee1a53e46311bebcf71e9c489aa52736f4f5e4af9f4180fa1901e24cd2f2a8d45a43b6eac00661903cb3292644e7949dc7dd170363cacfa95aa2a814c2f0262e829d87fc4f72b24b13b81850e60c964849437ff0e788a0c56b6f19be60bec10e889435a743ff98c3b4fcea4790bee3b01a3474ee00d6da00bc82bc09a1addb6aa605c3aba94af257d6d98a9d42e7c23392fd8a8538ed01e11bcced7fcb6771e4a21e87f10ca3ae5c0acb07768e642764f61a0de00234ef68fb784adffa2abb49c72cdb2d2beb79915fc327e80c31a9e1815304ee657dc2b7fcf004000f2b1af07f404b7eb3ec510beb491ea0ea8a0c16bea84461a7242b68951b85bb61af3eba8e435dfd95780f0d6bbc00a0d472ce7519f4774642ba8e8f4b9d2be94b54746a3a354d258ee2e8694adc5a479eedb44e97a4ac4b307ebc2422f0500453921cc4156e58dbfc6f7409e8824c7f4f095963f9e2dba55915a383b632787fb13eae457840ab78d5fe039014de51481e9cd2648e3c7d15c29cb72e98751a60332e755682762e73a1afd59405d693d12c39328b70f6d2ebab14a4c8010df916e8493e8d982467a4cb659d85c44eca4d7294f17c4f342f285029e2eb42d1a633d5c54e9703bbaaea71711e2e8a0ebc1255df7c46ce000db4f6bc13cfe25c0bb7d23f7b9071897fd482f558878bb00e7f5e058341be20d0f8d39fe09b7b5888b8e69c0e9ddce368455d587d8ce7028dd908492df918cdb77d9070c4f91eb4af4ede7b09df242dae44deb34083ede41292cb0702204f16cdb87f36b6da7b3a2f427ddb3abe59b9ca2ec6db27ddade8ef5fb474634dbcabba384a1fc52c7bd78ebae91b00ab3d6efc96c91cb45cf1dc31ed689d43bf51b9de9073be4f60234f7b50592bef98e2c9b963a3250de1560e92c55d15584c281844b917bfb8b93f07a8d0f5918374259ef3115591c8f0148355dcc783c8389ef46cbc2e669ab1c65e157dabe324659c0985a53fa9aa71bd21596dbb685bd1a3280d9a68e53fa1f1a0f64e96429dfa285b448aa101fd1a0ff8fa4ae7a7f937fb001ec75c940c0bf613311deeea2802f5c516d3ba76aefeb76b96a6b53435921b340d168881820a7cf1fc0d0349f393e27928b7900a750d344c05f9e53d23fdfbdfde657e6ee2409ce2d92b67f48a9cf2d69d72bca9e054502487de3074f472a1c04eb595dd5ecb6ee3e29a22ee34afc3868b2b64edbd80ae7c2f4f37a9328620cabc312d968b8e5ff6734732385960baf6ccc8ce3754186858fc7d468db33df2747ec25dad351ff6e2c2a7e82bf4d5fee9f3b48e9117a42cb3628de61208e29c709184f7dd5a7253577c74d1cd66e5fc82fe0c23222b34dad7a0ba34c9d60d20fba596c3ac15b2d5f320cc7a9d88bafbf9bec82a37d39a97d4fa6952b0e4ad1231684308afff09e5f360a7d2d0cf8ddedbaa1f7ca182bc44cad89ea59e2ce62bfe4bb4c3d6a61643560ffac9776a7766ee9c0f0406487f2e823e0170f688880c1bfd88be7566a91adf3a15a0ebcd242948253bef75b2c4d52ab6453eeb07a2aa5576016707954835bc55095b138cf2c13c101a0d7035ede471ca190dc1b749eaf73e3166732ac09a78a27a4458cf056678275a0989cd8ea4e1f8b4bcf1914b8d6ff9c998d1ab5a85990de8378757c6436095d44852d295ea6d2d250662a0668c452c6530a926bfd9a63277e5f2330ead5d559fcf747b08498f1e85faece2d817c2f597e050a1a3997dd9251c04f15a892f9b109e871da8a56dd9d4a3fa551f17a3603d02361d6a75d649feb23225851cd62f9b66a2eeb74babe3434441bf3c3527a811710ce53785a827658745f4220037aecfeddeef009d2fc39d3ce567d90d224de1bc700064e1a0946768199f981c2e7a5711d725e119ff58af6af429d486d4c2f89fd18b5ac18bed92e99d9235713666fe25e64dc7e968a77965e31b5d33ffda628a7637995c93afc0378cece6c4bff81e6d7898047ca0316ba3ff8330b617b1987792d8f5522e9814ba62f8d0ed862f3aff1a106789d30fd673ef2c234a377f1f8c6606afa648d54b5d479c6c744bc48421d5e090f8a41fa72dca97d5ae4d344d4ae66351bac36fd3f1790c432951c0fdee53333b1c8f8798629f4ad9dc7f3844d1e04f3f92b52b1469655ca132cb06bbf246d5379b6fb70604004fea984c46f601a76a028f4d0632c25eb80f025d50a177f72f47ce2733231109179edc448a4dc310354adab07fe5fe4160ec15fd187b575d7f4569bf7e2186d6590bdb462c7329ea65beddf3a7f87e94ac0a4fa58bd5377a92cb14c9f96c21ab414b42c538a84ceeab4bb411df1480ef17caaade471245b954712de1f95cc13aadf3f33f7a44f4c3f81a6197a54d30691489f724dc47969d7c290b45868635179b435bf48dfcb15b3bf4baeb0c382c72dc3a873b939f09c8118fe752c4daa29b7a004c2c8e08f8f9c6553311cbb956e0d6ad2c627de8dae5e013d09afe46c0b5a38033ed4fee4e81e1f9054d93bb37e7229483053cf2cdfbf0afdf41dc22d37f8686bfc4a2beeeae33dab2932282a48213c4d7929b7202dafcd31fa4ba7e95512d4817f8b1d594f16e9625819a1121976c3b0fe0b2b1857df1651d07a9a74a90cb618c8c4c1f947e6849ee26d8260adfab1eba0e05a78123d31bf5944e1c2a1d67b22d451fbba21793aa5ec9da456d7a25e95419b983a1b7a62690fee349b0e668b4d00ebc50ab55b22f0fa1b788e61e54f831c703e9c970b3dc982b18f6f10fe124c429f64f488125aa6bf064c25e98cf45607db8a17eb567086f93a8df4ec089c972c62f03adb6d2332533a7fa085744746dcc97fc0d2efa299deedf3b5f2125c4a0f6e17888e10e16eb4ac032bd5e80532b7ce19a093c48f7e818adafd4ccdcdf4584e2be3849689fb2a03daa01ba7f0c217a7af289dda89239dfdf6c5d3eff2cab760e6a2d77b0a3502d159c948f39ef289a02b2b887f72ab0fd44642a65dbf80d4f08180f0f592079b8ad1201289be3ee2b142cdbba4b2579b1cf1eb8cbfdc417362532e47b3bf1dfa89cc91ff9b87bf4df43f5950cb090119a1c3a0ec5aa464256dec3ef2463365edc09bcc29e36c017f43ad1d26eeec11974a54acdd21b21bf42fe4196b86def8458eb152ccfd65954f0537ffeb2a76f8d48cf0b797e5dd7f651c902ba891c74db2e51f9bacc9f3640bed11df4da61b63166df92eedca645e652e4203191c1dfe488048d83e2f61a5ff9a50e5bb81e302a96ee9aa818f3b7e5aa96aec3caffc06cc1cf980793e3a6932bcc35d1591523ac94b07fdee6b80a57065d471eb00417850cd1ef437be9d78a5f38e23dcbeabc544e0cdd1f8fefeac156036df263151971ee00217ecb4260d0baf7f35ce2c256627b31775d88500fd52eda7bebc9be403608c266589ebe976936a7709502ad52b960339e373c77dff48ff367ac70f62f142d6460aa96514f8602025e9202c62eab4e2b400cd7e3e989008c35ce0851dcc68f17363f48ae4071b7b82ee3638c3c7f6a40b0d76889b70575da144399a4bb117558a0cddc9610833b101fa317cc435eb4758631aa28a967f49670977189e066871d6d583c09d527c63ea2a18e219dd3b7e0000b74a70a830f486f3f60356fa5ff82445744041a055b0bd0debb866ee0a2f5420d240b42d1df722786253b39667c25a3bc9de54443042c81b2e1e11380d65365147ccb4be806a5ee7d2f4d7717cdf9fe3138eae2f7f218272153732b615694b213393918f5889ddbd444dd9724f9aceb2436ff9b9f7c22a6a63d2c4952df86a1574370596cbc7aa09f0beec3ebc46aa2d4c2a340a58346069859925d5488b23051e9f87ef30cc93920494497b2f6b4b7c1d2419d107f96e6017a5277210b2f30f1dc44c292590a42e1bcf86977a1326f0e1e55cfc239fa243be498ce6ec4ac088b2020e431072fae4a1b7c4b987c44dcd788c0b6d834ee416e7cf92985c8b1d122257341bee3ca8c634946bc7efe923239bb97e2fb8720d0d8950f3b463691ef5ecb8b907871b76075f5554ea436fa1697516a7a02c06fa7c038cb24a07482a724ad76b084216e009c2b9b49d911012c0b8c7e5c35b1cc6a1b7751a8a3cf59190510d2d86deb4fade5eb6f2861abbeb3d3a0bf3d412d29398450d047c1f0c41c80fab12371793c9c9c38c0094168e0c5f4e9edeab91081783c448d0e0359a9a216f8e06ad363b4e078f1aff0d85d8b0d031d997aa95a38e3fe5ac99fb63d2ee1832fbf7576d1550c7e368c73b39386a8df39294d3a855bc3181c0fadc6277c020f568e24bb768b567a502f29240e6ea36c445a3d9b3a8938c837facdb103aa25b2bb1c8c3ad4ca4167ca3360977284f158519e85c8ce65a74c916c74be1fbdec33fdcb092abaaf3132d468496d102811a764e60c11273d0130a9f5e2f86588e3e4fd5c228c60bcc85f1529cf5d3c0433157e44bcb8a16eb016845d3909dd3c39d13942254a620f54ec0d8c2167b46fe67af8a58535f2be08b97b847e0fa7d9b1de4aa37a27d89464bae724f757636b297f53efc613ede0b12c1edb269145785bb5bba79df9242748db62d405415e9782f364254b59b55bc57b41d7a387e98f3d42d7dac6f30fad6da31cdfc545abc8e665b5d08516fa56bc2d3625870be9672d362f8db9822adbbc2f7883ee9580a80036eb6e2c4810a23a66b7eeb5888d9c1d0b267c5c1078d45afa18dc9a427916ebabb340e9afe97e021b041e33bdae5969710a148571ad9690c0f57da4e5fe51fcd7686b635a55c8f4bf8eaa3970b04a2a8df535d383625f771b2ab41081c72b3280680a6b58c9dc2a6db99863bd01b94215c7ab0b6c7fe67debeb91982aa4e83ea41298cd7f892753889c38460c27192532949b52f83bb8ac4fae2ef87173242c7555d8746e9995c69eb9d26e00423fe8aaffb7a42d11110dd3e5e5484fb37d78c847f799a5e0f03172dabdba6497cdd932f410373d2c5acb5197a4dc4479e62dcf7b30e6a66670a0550a98f0a668e057c430fe3d5c971adc919ca5ccaf46d1c89c57b59dbbd21d31312c80f844517ab8123ffb3b5f21b10fc06cd25b1dbc68d8abeb63c4e9d8f8a04673e04b44a5dabad5645ac72986b92b508d37ac5e721b365f8cc32a7149559a8dfaa1e88a4103f5975548745e769a9cb1a9cb1ba025f6e49115e32bd52b6b01bcd5f8b6990558cde815fb96955f9029af8c97ed3c39ac900727c2ae023d2a1fb95a5fcf92cc0f364a26ba677a92efbba3262219241cf5eaf96a6d04a50da1549e56918e5ec818109c5891df2cf2a5bb897a9456a3729b7dc6872dafd2e0c53ceef7a26e2ffa524014c978779e20442487e1d5ae5203c77225508be1a2048af497eab115c3e4bea57b7f3416bd2380d9b0ba764976863e83f04cfd1497078f028f48f6e59c40d7ab53b3352f0cd8df0fc75f68176c9f427ef52ed0034d131bd77cd1feffcb982e8bae9b98ccdf06152c9f416ea4249ae1707029d434600672c6f2dbab95eed35eb1a07f0b81f0dfaace7b202ab1730466fd83572087baea85deb001124ecc9ea5c953fb57b00e6497419c5f74d4e01db3e398b3d1ae067f6abd07f0977e5e60ca473d286bc28b26667960893d9a278f28dd36e72c8e74d2699ddb77109829ec29c5a4e04094c1449c0df52b6a6a9f620559938a27c050d1840d6d8e971b7a6d10e8aa59acb083a59e9ea7a42f660f68276f090a563d7699b0f512d6da93b3befe5e5ca76f113eddfc023b78d26dbdf31a13751e9e49acf42aa6f52f82e17fc8329daea17506f83bc795ea34a3b70f1dabec40deb4f54136c4b30d85206e331dd59b168b9b3d6170829b4b9c506dbc777224ada3af79042c28917ee114d443bb0b379090ad4242cc4eec916cb38676526d297b131d0376e7eae53573e93e487ff53ccd61c1a1472ec19ce265dfb3a36a4dc2c09436996fe31bd3ed30d96ac3eac71cf1b927d22dbc19ac78339a8a791015966c3e96d53feda8fcf8da864ab0f5bb2401d2ef910a0f9aa6b1d8aaab219ddadf2d746df7490a6bbed2d0b8147fc522d6eccdd7049eee8e98ee6634d8ad7245365a8724323e82a118b466bd34134f70afc53287ab9de31c631a6e2cb080705d1f3a1699f86d1404e77965beed116034e11ab69018a568775c30c3fa501abce1dc487f6cb97d010693b09e8f43adf157011c13ef67aebd4792133baf653fe739601bcfdfef5600914ed7b61177c95772315f7cc58d8fb162d765edc9c2d04a810444e02b49e50ce4752aeebc90fdc2d9f0ef215784911acb2c4859222b1b4eaabf2dd7ad0bfa8d8aaa90daee09c1568e46f8df4f7d3d59e248dbd266b509379027b99f52fc420a0fe7fab06bd483cc7f4a69e6491fdba3ee26e48278cfa83c2f8bd7602697e0c10cf0a1b4c2ec62bf90a937b3d20ed7ab3ef5efc8071f32c1463d2774860e04a6dd26f374f1989066f7b649da3df892e9f55c1e5144f0c00cce8a039699456bbfe8dc62c1bf20d2ad669b74baadb371246a9437c8070a6c03c0e1dd9917127af9bdaed125d7c4c9f1b7132cc8200675e257d98f25cfdf25349f451fa71a2593a3ac85170380af5b6e9a75ac2035a264f0fd6719853cbf7d098262475f5a98235adfd2257eb79924086ba49bc803e52a75b077f74c723c5f8ca040aa3359c4cf007073648fe34b30b498ddd684206d2fbf7d3ceff0911f2a57f43e5bee6c91a61e7a22fe848e7edb76a0111a1eefc417d4283116a8d78bdfc7d15e3cb2b94d27850997f9bb07f6438e5f3d810272c18f138b85caf4a9d9c47e89445460a2d53f35277118d2138b3765a6954b36fa910b248474223569791ea782e85f0bf9a455d2a8987d8f6b4482803295a593e14985f2b297325ee96ee17440e2ae6a76b39471f1731d1217d511035eaeaa3981bff9f0e7e59b9bc38e691fc8094a312b23b61eee655bd7c44001d243fe61c4a1bf6e173184138577cf771b61c7da157c6b4934801b34db941529ee71743bd09257e66ef08d523cef85fddf5d4e0c30753f299e42da5b781d3a88ba9e1b5aea1a3aa06c49f3b94f3e81e397d78f1f8a9afa3beb7448eb6832272d215d8f87f838d9b1497c1dfecb565aadfbd3c9d186ac070e213c0699832388441e704a8c3864905f0d26d1348f4c0daa45b10b5893798ee05fa3fe90ac25380b6f857894fa52d8d689b64ab554c3190381dc7b7690195805f5ae531720d2020055e5e64e75026f2cbfd118cdd28fc18915d21e50782b769af44a0404b55db11cadc57bb437f2a7409aa486c063b26e10a97e43a1f0b212f64c060b5fdc5fef39ea9f647b5859b69984bd7e850b3dfddfe8a2802369e87f69b650554bc00ca4819b76a9549239bcc8e1fdc4993891e62e97ccfe8e973bf3139732904a14e7352b38a8465ece984a7080d64328bcbe4ad5e5a23bfb6c891d45f3cbca0335c8633625793d3b4d113e58942b2c0f10e31089d7b0a9d23e2f9622a654e2b80f6e1ffbed36a07829177043f65286dcf1225357735e7edcdfa74eaa53d37d57566bac6b711b04c070c9768b0de3451ef1d63dd4fd5f5af34e6177055bc94d1af519cd92ea4a0f35f4651df053d068dabf182efb26dd8dcc82e0e082958d65d8256ccb129b00d5cd4a7aded656874415bf8af144e3e04cfe1849b43f7bbf67e65117159d2a7de6479c88afa5c45a5fd080496a76d0c1ae3eddf1007f7f031fdc1eafb62f7798d73242de749ecb5bdbeb632c45514d582b2526c53ad288119e987ab2d0578e320dcf06659c51d40ae2570eb6c5bc30fc2c8f1ae5ad59bf643860e1c3ce37e7cdd30ddd21bcee8e667b9ce2b4d7aaf8b2814731401519b9c22e9da02a5b52265833a3efb4041ac38e78ba205a8b326a9901f045ff352ff6519be7fe9455ec80165761485470c5752e441fbccfcb8e167b1ccf104f41212f67808d8596a62e85a7891c0de2a1ca048481fef52f6c1fd58ca51482c5756477ad4e3698cc71f0583ebef23d95474df63eab7425f73c614a622fc1df4583963e0e812f4ad5e17dc8e7227b2e830ddd9eb27bb506aeeebf54cc9efd831c4ce521bdcd36ddea2a29bc755ad253ce980a28c6383f9d9ede82e702e14010de0baaeca28f8a94c76e4894d009e988742288c95d3262f6d592944ab700a1e7b0b73a1dd7ae88ea87f1f701770f0a215742ee9fabb68f1faf5b3b44d82e1f94875a245dc8d9c62f84ca5fc5563ced7b6280979c11e15a6be6ebbf612b4c5744de706dfa6ec2ed57f88593b1a8152050df92971c49ef8a5438dddd2de4e08902d1bfb11aeb873300ed77e5613909514205c6c301d2fe47370c855c3fdfe9a5e88df043523ac56486a1474e5cefb36192e9b659c9d022001f0a5e4b643d00a6fcfc986bbdf1c643e9ad7055c6438acef5edb487879386a3c8a51d9b98185bcb0c970694c760011a96be480e45f6df651ba2d0835a30f66cd429dcb2c4e182fd7a2fb8674c7170fcd2a5836405d95832fdb568beaf17b3b981acd9f7659ab5020ad54949358ca31afad71dc8b1d91fccd97ed063053bac6d8d05976f88d51a4c8c2bb9a7479f2d4f66d633a674fef2be3fb01c01f9e1e0abf606ee0b54a610ffa081b354e4eef956fefbbdeb73010e449b7351350937b6f16ea1a44393ec775658c0c70a5d787a7f13825b7bf917755baf50b9ec1a3f457ea519b78d88cb3fa635e1d48267b2fcafa49703cadd31a19d69fa8caccf736786fbafde621fe752d9415cb020c093c8bf6d72cde45f723f7a1622092a4aac4f794e546f4131bed1e481318f2fe8157c09d0cdbf82592ee37f0eef866180b4f368ce0973dd62ec036d6578c7590b9b4d77b3344e0b156140ff83778c342a525dd628b43edebc6508d613d1a1f1211def49624c5928b05465e339e89b0e33abde4456f3faad86ebc35bce52883f3c61e0a5c78b065f37bd9825a04b78703409db53f5abab5efaa75736fd586e59b5ff549b6cf048071e1a3b71a594ba927455c1a486530bb71e161c629a80a9b82359b3d773814612fde7ef58184147be4eaa257b42e3dd95dac0d6ad544bcb156675b6ffe3f8a8410ba2f49062abd11ff18f9002f1ad383f9be8403e473683a3835beb075d2ceba727a6cdf575ef52adc91cfc68951b1aa182c3c1d68e45fbf2e23c003046a74c68e5f15f7ab376ebd3136c8f7d560ee6586de794b74b78cb5099e11c77c014b1351d8a14eee987fb8c12ad4e21ad0632f457892b26b87a21e994b312b025bd12990d460884b976cc19c455b05832c1b53f79b1119b336aaf04fb1acd982067251587f482846b0d575d52f896bd612f1eae2e3a71516a3af73e9d6ed2fa283a53a262fb520dc6b03aa87abc6da7b5415d0109f70b265869c14fa1a9e7bd8d23869193ec36876ff6e6862644c0b7b6ec283f75e6741a81a3dd4a9f45cdece90c2f2a6b49f0931d8d2d9bb1bdedfbb07d9fe582f012010eab9a61569ec795b65d024f1192691ca0b90993c631d7c119d69faf00592a348bcebbb1a2b4862145bc60d54424f59c5bdf7f146f03a445343f4e6bc3fc62e17e2306c2801e4bca628f62c9bc1bcb1c83423a425c4f42f69fcaba4ef6dcbab129a0c2606fedc798e8d60a00a7f610e424ecadca5d3efd117078d32e3330191c7a5b775cdbc3382236ebb8ae4e149eeccf3a140d3e6320baf71aebe1475a792961ce40af0e88e4cd9869cb7854c1d16257c12ae9ca0f403125287aa4a7347f021e601c5eace384c4242edc110b3c227f28d1b39d0a7a6671f696a44f06d965a85f6b94e9d594c65b5ae1bd69621a32315a7e0caa2a410b3eca89d435fdf56f5035d9c49775d24743090b659a0eeb9628ef36ac9022066e4e61d56827de8c6ffde29d74b74fefc91f1b9e13310d8e38ae9f237e64d8409e05e4813fe5e62cfe58cb01bfc7c76608f620fd12145056fd4dafff1ac55556c52027ed5e9a899e0b302dac02a715a7098cfe97a3b2cf99197a0267828dcaea445efe67c74b239ed42453a7cda61fd6b4e714648316fcea497acc616f63ac8817b009fedb8d9d99d3177c277c349ff52eae65eba564ad09a0c7d7da97b455a385fb952bbd43aa9b84a8dbd33e27b24107d4d76867f87c9c45dfba05baf15cb3789641d78471359a6a676c5012e18bd6ff88ac0e20649d18ef1a94b7bfee2ce503dd6d49154cfd76c6108768f4669346428aad0e304f8e7325e131f3126fc96befccd9b88bbc6fc202db9cce86ef981d9d8249606ac592da27a706025d30466beb58081d501038eebae54f3be3e1eb4e69c538e8fe7c268c2b8aef1056fa5994473e86db8fd5149e3f2fa81ff3aa4285acdfdbb31a43c1bc7168def1b50f6411c7ea450049bbdbf3331a26005f6a769e05ccddacb3f15ede6d13e6468120dfde36e25ca4d78577c5f905bc30f3033cbb66ad281acf23a04f9d154cffc6f4c803e3a4532e7b5412a4e78b41c0da15e651427db0c5e88de27c0595b6106c83beee7a4e6f661f71ac9c4ae044513d93c6962a6088ee692939c08da14a60cd1c7bda22c9959618f034d3efe02bf2b6bd0f5549a03deaa0cf3f08d6e67280ce7b41394e9386d7a6b9d28922c4c65037da53aed2ec80eb465839ceee9ff8f0126cb2c7b6b14cb0c02713c799135a5b54e492ed3caf19c4948c4a3098599d2f7e79092dab88be32a1f9e41bc052413b077e8924076d9cc43f8904399cf639bd403bba80c16b06f67bdda75626841576140f8d0e934ee8699855cbdbb94131f106af1f6b45c0214c6ca6650f00639a03c99f68aa7f9eb800c97a2b8f71f7f7380a3de87c37cc53f5115dd98d4821c285b03cf8eda3dfb2cd70ffda5640f939c245938f0b08c720026aa2315c62f73ee2eba6b28b84931ee7eb8cfb5f52e4218f908b63254230e72873b004d3a47c8741370c33166ff2141006c317fedd81b38cdf1541fd7efeb51c3ef469de86d44dd57afd5346e0cecc055a7e1f4e25095d29f0afcdf94f96dcee924fe9aa3d53342cbd78cfd16712eb16a93460160694a1e65f9a5264d410e1ee6c7309123589fe9bc550c21592a34fca93e42c5ad905475c10ab5706229bd770b2c60129f75b13e06a5f64e3deb74ad80685a561e4d9a4edd4cade38fa2abb7fdc5074a93bf2d3551e5d341a07ff229c6990ce2dd4ea2df64426cab90196975ebaf6074672465c3a34eef4f9f85289d4d9258399411f306ffa17948d6710eef749aef00ff08a0d941fca35d13fe3c1fe4458e91604c6ff1e3c66a24dde3c7285c7638e5be7562dbdc107b9c80b7a7090a83458617d693bda88b6c557ac0e266ffd47b8b6011d0d2bdb0a3274d499a0ec2d675832cb282cd0d039f01ee7a76bc4d7914a92d3a01b3dc9e4ac9fa9f93053d8d226f09d71942328a21031c37590e29630c883452acef305f82d41e1984742cbd84508fc7e41bebe450956d817447b611237c9faebc510ecc496d88b2569745fa4d75e2648b12e16eca2e3e77ff4779c67f8ca114b14dbc861a4a306a4c784c7cb0af4a8bd122e115e345a19b80ee08cea0c47504fe25348844da03a3969adcfe348fed6a1d510f6a7a6872c54edd2716257bf98297f38c230c316713aae4df37dc8ca41cd89d65d66d8368b65a93807808bd45bb1a8c16573ce7f3b834b5d5ced964f130a6f998dbec34e5233bf8e624af4b3ceb2f0974c9cad4f99604f1ed93a93fdeb140cbea095ec9ad2190ff088a5735575c6c30c1b25dfff3f886a768a67ad642b12a7ce59060b2770917d6ef9df1c6e8a2bd92998de14fd5ada88e6ef3c4abb309fcfa69e41cef6af3f94d084dadb56b16ac2e9542fe2bded708dc1c1497008ed5882ab58b8f300b63ab2a44b77420ff4461413c61782b75a0fa6079cae9dc0910bf579d1953975a5132c872457018097e729135308dce908705652e8158511850764eb727a213f57db3d4d05115a2410a04da3e0e74bec6162eeaa2e0960e6ef3d16a68cf4554f018ed8cf71d02405ae18547c517b5518b4742d18b531c61e99b51e4d7078fc07bd61514669a7186250c199d71dd63a07ed56aebedf15bab9b031d23cfdc27085c25cca4a74aae62b41850385ed5216521d8554122630c6d13992a98448e3d11b6ed3c957047af7c73791962c735de8c422766b300b17cf780edb0564fe4ab77cae9675b3468ac3e4a501851ade7204ae9efb22c412719e7613fd3a13f03ff42bfef3a8c275f6b2b80801476dca2fc264294fc2a82038b4cca86d8475d5bf8eb94d59d9bda0c0f6a29b0ca5a43531ff71ddec823779b7729aad8eac9ef70be7294cc9aef1d6a2e359e9f0fc6647d6a08ec4af26bbfb33b5d43f750033f0d2a88bb9aa9f8fe3bb1e9f1a120407ae5cb7e428373fb12f6bd3909a83ea76e8cb7427ea2cea37ca7ade2aebaa0914b6c8986194b3cfd7740c8af6fe8f22e17757a0e45bd39a5f96f1e064a21f38c6276a18282ecd75482b74566d4afda647cf4e510ef4fd6ba18c8aa3f031e3c36915ca13432eb2bdfd8d5b217cb1bd7e4c2a54449bc1ca3a28725a576ebe91f094e5e3adaab142ff460ac544cdb9c4e539bb1fea1b4d72cb7900f25898495e3d886335e9b06f4bf9f4ea482fd28d631883ef0f6d88e960a09bdb961170859a5727de38549e01c9b57b7bbed220229a2133e22a8173d0d083d2542662d5ba2d5e45954c8903a3379ace46a03965f4496e5190cfd87af9a41fd5149225588c27cacdc1c0dd5f3beda5c2f004c8f985028a94617209f946d12c494eeb04bfdebc550fabb251edcefa2de9ff065dacb6e908467b441e8851ea9c105c51fcc6234df8be57501d711c898e5276d0d5492fb565fdc474e9d6d5ff44a2f612008d7edb32d195193e6adcebe85bbee9c403c455aac692a8a5d2ed9586e19b22084a41fbaa5b04073e87d511ada333e8b54b6ef947d11fa916e883db129ddfcc88846dfcf5213a4ec12fd46ef730bcef3cdac9217f851f61469181a5f007eaaed1a19d0a176d3b040fdeb8e099286b368b116a3bdf153bea2dee5e8263a36a11ff9aabfba1b5bd564e9d917a28f663072d4b202838a7b0ba736d4d41bef5f1b4a13a886cff4e1ee0d26b55084024a22b9d0ef3c113a87a779003c9b4337b24db2e6f5ed7e539d0ed0b9d3928122da7163feb007c5f3c393c379c5d94726fbd43020b3db90e7906cd4d6b8ea92ba3d96d8ccd6dee238b8a5a1c8ad102868eb57b902906098417b25d8f48e2b26ffa700ae2d844f10dd67a9ef7a5669420cb95792bd52bf178a08c0c68473299f6dbbd4c6bfe0f8eb96e9101a0c660ecfd29ea0b95b18c0478eca803f299f460290a058b4fe35733c24ae8b6f35e380d1d41676eb61edb3afa1ba404d6f960e12bd4b25c57ce72c59126fa119d44f10ac700bac0e5fb86945bb14aba5f3eb894036e1976ef159cc3ddc15dc5273367de200089a98059ec37d69a587b1987c19f0bfdd49ce8258570150556d5c9c209ab2ee507aa0eb2391cd325712a445d0d13864003c03b0cd8d4a3d1d75acdcc7bed250e5b648bea6611311b9d016d2a3a107eb66766ec906f1c434e8adc8984e8e0da0164ad45f5fc0a858d30fcc0debe133411c6efa240cb11ff33808bf932f7e0d390c1e975245d2e589b5c4eecfe6fa1bc058e586d9f5bc25b8669a371f464058b5f6357aac0976e4bf4afcc210cabfb1092909b1d5fa4918dd25bba3b9dc1c03fc7dba39f64713a9941746cfb9ff5c16c58128c9cb80cf354004144c559d202c5d1df4598ad656e3edbb4543cf688c1fbb685b9aff5676bddb2ce5efd6da39d3abe499306958060d0803c071cc211b2e0b6ced96d98b89a8728b0660cae224b1c2b8e09236169d58c74b36c70a1e43d60c3055e6003df8cc7fa397a28d94f9149eaecb95e59bad1e97428acc05663f9bf9fd95cab0f1dae31a5f9ea0981d47137353303260590bd434397fadd5de2c4ac527e2813f88ab5e7feb3c5445d567e6f769e860be98b08bc86c5f730bf5c24552dcb6a893612d11fbe7c1a30b2a4b0261f901a596a3db974d17a998532fd7f8fc64b7f0a7d8c06234f2ffd5ec9e4a7be6f08dcb26e98e0506a59b2568fef916d4054e777278ed2068871eb0ed8515c2b26813b1f2ea1e83cd78c93cdec256d008d9294a0a4cc3ad99ffa38474108ce98188ef22b0adf780059244dfda2792a2e0a9a2a8fd58b8c6910bc4f9a34ec56b6b651aae051ae80abdb4cadea30ff94d3d54cd400a6c10e0490d30bf77e2f9a475bf57529587fb97d9df4ab3d1477c91ff068638cdd434ddb0470464b4efaa8c27cb77724b2fd8059e411e247920fbf66005241ada6abb9536f69e7525dff306f3bef196ea7dc866bcab2995bac38fc58755deaef52aa6b8d95f13071ee3281d06bc306defc08794164ef8fcadfdebb8783f96629cf82b5e226e0d6b8483c91da92ef5edbee9f82ed57515177106b90ff6e7a394cce7860bbe937f33406732f1662d18f013d18a3767d391972e7539cae932995c7444dcd556da8590908f047a4d5153056abeda613c46fc27aedad8ec4c44763920ad8d3a291f84308ee000bd23a4e0fcc49d75b5af6c14226b436d0a17408a1a35a9277ae0beca7f56460e8101f75c53a25edf30b5523e8b72d5ba0d284eaa80fdbc8595c4475302a1a3f0f5f6e4e54aa2f1d3c0bee08b5eca6fe2fb1a796902dba93070812819062182cc181ca96f27783bcbcfce6ff922426cf6b98c7720aeefd1fc99a5fae08526f379b2493eb576b4d5c8ea54e7104eff3826d347d6ad407fad3a7effe363dafd4f0ddd31e8e3ac17ff23f2b7fe6d5c7d1275c3612f4d1423213cbd85cdaff1ab83ebfae3641ed215be2d3db315c6fa4640bfcd07978efb8c1730c33c5c8c7e9735bf036470ccae1fd83d248140048b066fa333683d3debde7fc5cd7bdc5eaa380cfed64470bdf30858da32dc0d90f805e30adc1343c995ddf6c45f22e6077fec0b370383b69956b5733fce3825c30c4754b1963eb3497e85a433eca4a217c1e4404225ac0e8e71662c7df86c57c5c8db9abc1b334a5cbbebb6154bef94ffbc969ee12ed130bb72fc20c428383ecb36b1578784f815ade087ea194a2df464f49d8e4c3f1d9698111624f9ca3926625585ab875a0267b0f5e73c1218b206d0e5e7ebaada3afb4a2dd3c5aef05eac6e4ea9174f3e25b74bf99b669d9fac0eb969cf112eaed9eb96aab3a959343c06a37c7dadb7010b817ecea58c492f1dfd45003e3eb8818d8045260ae1791e0feb028ab7723a599dd44ffa021018f849b94a0d1cb0f08866d00a28c95c554ea7195b25fe2a8c3336d05c7d5efb93bd5bf22e3af304bf803de24d4ff523a2729cd3c86f630fcd518ab326e3c6a50583bdf6a2999ed9eaf9d716d01497b62538cbf210d3ffc1e3b5fd4cce474ac1a2c537f70e763d3460dbfd992ae3ca6469283fd3501497c127b320dd5c7a1071c3ce4216e330c89aea29a683523587331712f76d0e6d1b8566d292234df71114dcec2013d094dfa6d6a327a67ebaa73ad4746323ff53a8838ec54cf0a459c07e0c0e997eb2f222ac3f24edcbbc06564d93aecfe60b25e0a9bbbd9e01361219d24aa70e554b0be7a108118ccbc70afa279c33ca68f40a63727113ae6f0aaee53b9455e705da1a446fa0926653bf06200d56a4e25a42762317827496ccb7b0d734acafe09bc33d0d53057440cd92fffcb89af015ad78ffb4c5eb8b893277430b4efd5e9d6d0102cd79a437286864b5175a45bf4a52eb2ac68702865f98ff80ecda3bdf8535bcb409e315d75c3f7320f336979449242d8430312d50d72729fc9ea07d3811ec3f8a18017701e92c4ddac7ea07413ceddf2373fc997b0478ca53c6e0c1f0c43bb0294710166f9cbc63e4e582861b1487319beac20adfd5255331952c618525fcb53030138478bbc3e047888b68e1607caf42d3cf1778a80e3182d4de78d7d5d3d4c364dbcdf39a2ead1ba7ec3e45c177acb97ed7765b25e734725ce67728cafc07ca2fb6368f45ee9dc2f2b00410133b1570eef33ca448d075f355642e9c95f85b4c7028dec0aed12042db20a9e32e05a2ca63a75d10605e8feb308b2cd2e4311f0864d534ff563bd68f5ac8fec1b336eca91a1bb8c4413e5e5f590f80ca55a45c15d57edb179d892117ed6bb6970f368828a3ee1386a59df9f0c83375cb604cde3ed30837372275740787fd1477473c8a0336f4a7ea1f2a21da3dd38113da9dcbc7deff7e2779ed2bd8910f0c215954f3045a8b56c94ea0ed73eb9fb00ad0ed018f604e418fb7fd0bfcb020c8dcb7851b7e3fbcc48f1f2e2da6ea40d82110b53b172074725b515c8384a44d428b981502fd774b9d3bf3c21d0a05df3a10cd0cfca6374d9f16e42fef5cc03350e88eea6db82ba1e71fe6398188ec27a4686e32f3783435f5d7ae117fef503b25a3b9b04f93cda8543ca9216cf599bb5d0711f550938a8e6e06ad2a1c1de9586b7050f257b1bb485fc30ea76ced1c34412e382abb6d24347161d0e8a57dbb3fcc4c2347493debda1a7ba2def37ad6ca9c970dbd6e7603c9cd56993054e3e18a45a0d8260a58fddee06e52bfe160ede7dd00d13a035a5398e08d90a69d462c2b53f829a0abe14846d3283710c08cc7b6258a25f8f689e0be8d0595342f9af34d83e0a66fe5df07da5bc39858e9e25ab5a81307570b17a9dd05a0bbe27f4086045684eb6a5aec0b941322ca21aaa3ece9635644eeddc9dd5a9736daf5c3add97f8bdfa8eb24a1d116e34f74f24b39c0ae52f3e570513ce9ee6f18b2051daf7f41dee52f8245bad1fec022e8dfa03b91a271f094245d0aaaeef59d54fbfcce60cb4975cc12ff4986bac8d1978666914e397278f0d9855b4944148fe51b1ef1f76ffbaf5c361b5dabafc3d6a6f86dea1e1323d8ec911e24c76a300f2d47b8a3eaa63de3cefe596edf5d9b0f7d900e40c1940fcd31f4543d4661858748f297af5a2b4dd43bc4f178dba0bfc6c6a25caee8d91945e8a1f33d789ddc20fec1a787e8245c36976379b65005df31ebe90e961a5d66eed065870da89da3ee8c9d79e9e8bf37377d540356210a7107a1ba0d0b5d9419ee2e44f05a44394f4afefcd91bed1f2ed9ec2fc485828b8c97d4d15fcf2445adcbb714154d18945494260107795d16ed208a7dcc5fce9e5412180abdc0e06826b4bf7bc07a4efc9e4061537dccd84533ae307ce5b9908a63b80ebf8ed250293eaf5eced0942d444994a6724435a999b936024d2f18baebb19cabc6959474d8ccc620fe95bc80770ca6957ab10f2a00c8ac4f277fe83c4876b59f2ce0cad1d54af7a1f1d4f1e2f03c7aad55de07f36317f0cd0d07f5347321471b0e86c5e31296482a84f55cfd265bb58ecf5d14745f94ff68b856f80b7cbeeddf10745fa011644eeb0630546ff7962c6a3b0f6ebe652ec832112fb3e246b6bc3c17b3748d90ae274e49b2672c87cbcc9629a2a96990f34122d211eb7cc7e61deae3684ba3378020fe9ac1db3f18ba97f79ccc96460cd1712a77e3a60cdefe05c8fef1fa9c240390e2ccec6e3725dd3568c4a311fd0f16861683125b4803aecf56cf0f2513e954d01f27b7f1f864a6635f83baf5ff690e1cfac78f9d29d40cad2596737f8ad206b096ae10fca68af126464dea442a9fcc86f50c2289b41a53741428413430bcbd04fa0ee52707a37b690758d770a87b415ea88bff9432419bffe164462e87ec916c6b2554e62fef22582460df58c0782ae512e244505e68bcbe8fc477bff9c2497ef18d1b3317604a66b9d95cc673d7c18aa2f409055a05e1311a9f1c2775217223249c45283fc7fa1dad9847995759153b1555b9abc05eb2baa360b3a8ed8f8cb5a0ce928d7d3f5c1ba74e212b5f93ff52bdf153cd4721af308c0f86d3d0bcf7bdf313d1dcd74af0848d38b924824dcff05dc924220e29c5ece760c7d18f34d715a711f3e9f5bc99735a508bb7fae613ef47264919250f22adf464b82e3b5bb26654df588b900ab26a6895cb7788c0de77eaac65fc3c01cf0ded4040cc82b2a44b0d840799246a4f9c564c0461266bcb8efabc7da1e4608916b36b7579cabc7c75878b27870acc6d0980eb6298110b824acad013db8c5529132fd53d4d3b4c02d29736b9e3e20c9ec3af8bfde33a0cd49d3ecf89ae2acd94262d7bff252bc54ebe68465c5acef34e8eb318059087bbb1378abdff3008f43c32c90c8219c8af8677edac954fb67b83fd45b3e7154553eba774a14937f1b04b7102f05d7fcf210dbfdaffebc21c7987df76c2af9a338d7ebdd653f65043abe757f529298da6745d193476b02ac23265dcbbab01a3eddb7552be389bca65ae1cab637508661981db5935fb5d38a17c004909a964434c17670fadf4fce1913e2b18a01dd7393a32ca142391fa318d5ba697e0c4c669fcb5bf1588a57f5f6bb78275ed3ccc1747443f0b7aa4703455165f4c8b17441657e22cd7d31c987bd5af67f2c8833f014c880cbbcfc050789680a3112865eb5e62470125c0ea5cde9a495f469eec0b115b9a51979be72911cd9093cab377015527ce343e76d1d25b57197943d85e11410126bb63c8289939d9eb443fa582a75ba73cc160e8845040d98c3fff13bde01c8c9154095a4071ebf89e739d652a50be08d741b8f5ce445dee3940646e1f168b3fbaf77ff47bf38e8060dc553e562d497cdaefce90ff7a9438317c6f458aa41201535a098a9f33b93eec6647d724afa3e7bde0b514c8b6b7773c903efeb3ab21005263a5ce8088df2227c64f2dbff0c7817fe6a398ce4bb9f24fb2781bb43acbbfb6eeeb9b41d190971013b4d93ee954030d58e786c13e1d72a8f98575c217b22367dc5b3fdea8516ff325a02b467c8f4272508bece01c019a31f103e2bf266d2e44eb02fb58e8a408b17c2b5ff35e84ce4c95aa7e6a8994600e1ab4e4ba5fa014e1d4080419d441d350a43a6894f014ff245c68a05b2ccbfa5cc569cdf37cf713d04ad26341d5066328becd45ce620a23b959e19fcfdd676d218f19c0dd12f843e4288e0e7d8d4a7d1782b6c11ff70cc25a2d12ad35073aa5168d99ec30a6fe3c0d2f0f0ba61d9c6df8e1e3f81b668b8f9992662cbb2a10052be076d9689af9b928962cc64e2932b886553ea11341016f5d6a3c66662450d99134eb3fd6a5578f3a9cc0c187dd7b4ca91c9a9258d2440463355329ef8b6add88cfaf42f515e36d6ffe981883f79e390a815f1f203abf79432e60c67292a65b2fffd88f63b43ccb869414a1406ba1826822dd0f87e826db32f49aef6512cd204bd9999a4423654c2feb346382bf66e834e15c1ac047bd525d8026f4689b066e34e0a4a39f307d16e2637a5d47eddfb4b660aa81fd4462da92b8054d3b994a4b4d7d10b0cf43360079210ecb9427c5d767da1e6a6f992ee2f733e3bbbc1321ce80542a8780a3056cc83981bd250c1e504773bfb7251f4e87b8021ec123dffd804ae5d2cc848b06408270ce0a1e36a84f4d9162f8e8229dfc2be79a3c8f6b7aecdba52fc8a9e3cd52f8281399d761b9ba4208062e96f41773f9be4eba2f40479653ddfb0012c3edb508f10c76d3b6ba3ed68a2017839ac51f0e18b8c08a1b458ddfab2899349c561e6d87c7fbb6f0a0647fb29c50dac8b114cdd354bea1efb664b8b1d7c7c13b69d9e657cfc4917d517dd27e6b50e44e6394bb7dc6dc4daa842a8f17e2f9260a645dbf4a6e10f0734a2361ad362e4ef35e73d15d85a0a3b0827c2feea68bcbe166e85620efebcf0cdf653911901a5508e3641703ef268f74c6d27799a44148d296741cd05589b1b38eed5c2e0844c717ae14e60a15715db5f486aaa13752b3fc5d655dd0ed1efc0daeac7ab19a273d2a8a0ca4bec2ce6c6e8a02f9108da9c78ce85205a5ee413dd3146bb571093b4fccd080174c92650e32383b441b70209488354133d17f10c756cdd23f546eebd406b0b9fae002f5fdf6618c9660c61670e18cb05fda23445390f8bc53c1668a22d0d91f5e14937f531a84799a2ba606b72d1384df26d2d81cb39aff3d9109b2eeea77f69d0aabc416e6b399a0da4d67575bfd00b0a4d6326b73186b8d1dd253ffa5622e40adb26eede214818f36ff0cbebeac44c9a0ca225ccf83a71f44082c8bd306a872cd7c5492a80403eb25d38450cbbc1e22fd082e97e80ff82376b8990057a5cb3f43d34b6c4263753d9e11a6ab57c7f9c7162160b5158c0e8a8b828fae2446bb720da190934f635342d9dac9486d847fb5b41fc35ca96a2d8a8ac175a5f9a69e2b75a5136da0144940e0712fda1fa525d3c21a51d1e373965a97b799c3b33263b17655b55f6d4692be8fdc88eb5919213506750d7cc3259d880f2d66a94fd6c1cd6dc5401729da2e98b9e3d314294803fefd06bf7f5384854400351739026d34acd9cb738d9b0350894e6c562d1db9f2c4b36a8aefd56bd965490bee337687ed688a1bcdce3a6cf8d5ff726153fdd893f1b6ef1dfd906f9476c3e7b1ac5e3a62aa4825ed3a6c7132a30422aeb9771857517ef947fe1d29710c3956b0c756c89ea96905de38818dca1b503fecbc5ec46e5ec85ef548a771d08dd4ad2e6a64b898059da85f1c64087bf637c286a9642426d3371fd178efb9ef7f5e88d57628bb5c8143fb2c8674b5a310f4648c1357133e85cb3008a893f992f19b4a1726ac9ad64cae8228d2a7e4b4edd5895b1aea68498f18d55e9aa4d92fd9da8253d9bb413134571a16582988ed2f8e2328adff3238427dba1e810b298328ddb8e9893a4ede001853af1fbee4d01a3bd095b967bb56a7063c7da5ac5b7b7e5afd6a2d5ec770e32f293149079eb9ff2fe4d389107e2f866b0f7e136c5a7df6b723bd05cd14d2b183c714721b63770c3725b04262a15e6557b6cf20cc8b6a262883a0058f8c0f6715f2c19905bf706bf9564d1b16426a6c1fc29a01fb0e4535ac4dc123636a911b6107c0e02e68dfa719659d2f7a29eae5b3b4ef963d654cec082f14e819c6ec6a8b6fc9a7f43ec49c83889956da724645070435a621302af709c7795116a8bce02fa8a388161df775f9109c0a30c42353bf4f5a37dfa6c598802bf19fd699de30930453bc80b2637e88a64eb323d5aa2329dae72e84e5f76f765150f5583f414286b458bf782a3e673daf0f241074fb3a2eb2812a41bf0998c6c357c5e4f41ace5b121c398091d00f4b945e15a3c67f9399a5dcbe96c85078f03411f1d86f7161e28172b73721ff50a6faa8d6b3bf7e27594c090188d7530677a989aa4ae2094bdc7e9dab48c61b1185d6f0baec91bc1d58a9acf554de6d6b18d6228fa65f021ac0071c07d5451849fadcfd0c4c089f802442531f7ce1542f1534ee936262b0c068e4c3eb50cb12859dd15321b48a4ac013bece50e21fe0ddad75b2e5f139a08acef1deb94d9236a2ce6e1a71f3013899c5c4de15b5b05f34569b95bafeb07df2fe2cb9203be7a8230d6047fad2bf460cd2ca36608a313f17f0069cf94d1b0bb23f822899d13b8914178f6710a45e5346e1e563906d4fcc2313c72fd096ed3f6070547a56b2cbe58ebabf8242bc5b6ed93ac869f3b08172d7c85d37ee21d4a6aa3bdc80ef63dfba27c3ab165a1b5d331d52b9eb9853796c45f6f9d852f307c7444fd96a8559a04fc13318137ae7b15de57b6d063f873af5fe594c58d9831d78b966729170f82b503997fa7615357ff4be085d6e3348f148dbf1d8769c65e14e269b3cd5bf0f1b096d927c1153d49b0af1b723d4221b89d475123c4667fd7163bea2a620e3344078ec8a26985256306ad46192c8cd2853d8e2b82e03efc0346aba309aeef021fc4838a3c5a243833a5c73108ff0414c3c94b2ec14f65103e2ee7dfbfc11cc6de5c17d83eddda40f29e520529181df2cd13049b6e52be0da2bd3e3a00f7b1ca9197a7641130a923ba94d21c4e452d3a4abad3b8d1d0b961830c5362348cc70aa0a42fcfee28e5702ee1146d75ae3160cd755ea07ad3176e5deea734827029ac7d3328f88a37b18a6dd74bb8dd44616961e786256c45da9fcf1ac6b19fc83d713e881d145d035dfba7ffd0e73e9dbea0a7d0e23bf311c3eb2753376a5ad27e33eb7b3f1a7f723be9c3889ab0e178839aa4ac24fa44e9afd5b325a5fa0e290abde3e7d3e6a3430354e34e034502bba6fc6887af40a44adb02029bedabc29bc65227b3014c5f695b4eecef303f6be9756d27f344bc60c9b7a77f2782eb4c6af0db5817feec049724457ba7ae82381dbdcad8abe4181580e1e0cd8759d80e58748fe5ca018de49943e0a404ca05d859a5e1e8b3afba0e7f90222f96a7486b8bbe51c851c9d2e04d4881c46b3eb16e943506d596665b94da83e7bea6ab080c76e8c001a5ef64ac53a8ed328aafcd8bdf3278de89931b7ddf7b8ae8c798ab2c3919fb0761f3dcff32f3c81d766aefe16e7fcc988334d277ddebab5b3071ce2f9cfbc7a6c071b73c025b223ea4edee28304abe6785e5833b7ebafc41162a7c7aea6df0dba9488094efb25e8af4e7237c7004926b8d0da3ed703e79aa8b4b614112c1fd0227ae4c15a9137b3041b23178c946798c92b6b4e1dce36ec96cdbf625390084041265d5344458f8dad4a7c9dfbfe55276dcadac0c87c666c449c3e8399691cdebe02885ad32fe86bdabbacbdd998f473f851bfb97f4c21c8bcacea813f34e4d21f1c6c68ed9046d7723cd6b43ca1182fb5e9d881850f976d47192b050a27e8519e4ecb6ffedea9f65fa6a2de8f5168edc093056117e826c40f1d01695407030607a414cb666cca436c5ed1bcfdc29dee73d06db07436f1f9c0080b589dca02c4c575ae0d88b4f858392f8791ecaae6c3b3f6d7bf2afe348d34b26428c0e22d864ac2a92b0bed270ffbc0db8f11f06647e29d8541ea3cd124618bfe9ff59e877cfede1ef11281f35659e74e6f6a56563b5ba2513abffde0814757839a3f901d3a8a570ed76e30fddd8312a0b81421434da433fc2fee78531df2b8adfa93197841fa451f6aacae4799e68d7c1022e2c4b7a3ce9e73022d7edd9c70499e0c143a69385b076382d6e6f2dd85431ad5c495d757b8f54d6fdd17bee53cd5d26be65373f9579a296844e0063ae1ddd3cf39a9b376fb3c5042a9cb78e1b31070bcd870e4b5dd51120188b711f6cde9c9d3e5faf8d678f4f4582e5ff272090d6cd0f6d78aae7f6c7f650d4095f2779454923c45e867b25e4393f1ffe16b1f6da2e026ec615f86838467a8e628b7d97b54f46750ea19379b98f51e8754ff2b238a0a4d31524bf8190a0a26a34515e7d042fdd782dff72fbfdb34b883bfec971cc690eef78a01cca21159c1890295f8404752dcf4898f2b0b023c8ea63e14a904d1a7b251add48cc0b91cbc9ad365162805c82468e7315faa0a4ac49bf7097db6c87d01515cf50ddbf47db465ebeed2dbe96587a30433c52a7518ba04b04314c396c10c96ea84f65596c94f784deed2f2499d072739b57fe38f66c1b1f79662a9b5aa651dc2a3bc332e4b2b78090ce3ac18ddf260181a95c17325c4dd9c58c5e1015ddc821155d8a13b50c5f2c769be1c2cb1de575771b134fee71f3edb9a14c906030d37d4066f8d6f2fbb88b8e19d4b58eefbb31f97d3597026f3ab4e13be7b083ae8729e8b3406d7c94c20f2a7535c910969804f7abe41bef0f016a20a1108dbeccb87df44c3d38a10503c7796693e65fa1131eeef9d40545e7017ad9dfc4f46f048dd53862493ebb7cbe9d5bcb5a302590d3c6283a46a2da2326bb0ded885098c6325d49955236cb569a95e1e8969e1ac13d4594c062361a49f08441afd5c819e6c6a84213c3480cca9aafdbde32e34d7cbca21f948e5614327ba62044e8f49e414e5a55d07a768e87c01cf4592e195c103806febf84dd84ae50f70aeb5c4cc0428b40d0b24ce57fc325f9f33822e2891cd0e3890797477b47d281aeaea8802159c27d2798ccfbf814e6fe5ace81c98ca73dd1183b415a1df91fce836b832f09b22bd2e188afa740e2c44cff74b08d489651cde28f76a911c692d527a25526ef62c4ac569ae84e84addfdbe629b9a57c8d225553287e432175543d4d237b053d00ed28ecc501e52dc5fdbe219e36b4d9a69b74907e389097f5d56fcd759a07e65aad879dc7471bf1a4217c597cb8d8944774ae75c7a3d2dff381852be8d7b9b4842545ee0c33f9aa5581083f3b0b8fa5bcd7b85423bedf40f958763e94e93cb4ff95ac34aee3c2f80bd61f52bf628d23cb8d274e802178b92e5da3b0774f7f3e7fc4ab9b6f09183645185731c006d321127c91e35763d2f2c4c7fc45d9a0e04f2953bd5e0b05a48ccfe7227eb5095cf61850fa2db37803291283e8a228336d7260981057d2e06f87e380f6b90b2b2772beb129a44c39c80ee7245fae5aea4332978ee670f356dc5c204153939f6281c2c818e8c0626cf7b758803cabb0cacb9719cfdf1554ac8535871c3d967b4196250177b1607cde13e0c0746080bed84ecc59b01336c4ccfdb0f12fdc4a23fa4efa552a89cadf059e8ac02164b00bd7cb82fd432f497eb30058a62a279137c4ae4e05dabc3908668f3279bc5261c79f0e260366f6ff8de2d5d0d37759a4300c85c9ecd73d6a9be4a1e0c8f20841a131c84534ec1eebf12db60d553e7be8323afe2f755f93c55d64fcb111ae59c69621198767cb00338fbfa672db808c9a5d5c171d4d9de034f9c1b4c3031ebab15563bcb80d801832128a3d3deaa3c18e317c755bef5981188f95a85d4e218f99abcd74ef127f6177ad60504674dd4f93c271eb72e5894fdcd1b997b00d14621477362c4ef2aef0817e0ef38cf9fb055f97219bb03fec9044671837a008a976ec2d2d71fa2fe99e9664c26941a3c6cc876d1201c50d9362b60ba5a76e97043b54a17885d22dd00ff9b74b622a2b9483d8bbf072f319a1073c3f33a79ea6137e3454b05a7a131fc9ad09b02c40893ea4b1eacfd1c504433bd45311f2cf9fc72dda49374579bb90e21bf78c4531925ef021b677a8ecaab9d6834d36be028c84f56c4866f9b2c3a8e27817bbfd078fc52fe95d35c7e94b95bbf78f45aeb06abc773f2464dd6cfd17c30d1f96c84b066d432b7a097e01d933fe5e46c3217d3ef07ef036271b095be54a4e21937b830d30c64f61d2ae13c9e753057a781691229bc725ad87902aa5bdeafd0b89d0af79d8fcf3a53b4ea178611dfbbf28c01a04d3305410844e213f6e0c98f48fc3c4a3a36b792610e8b51f714bab4bc85c88fedd93abad3235d007b462a81f6c9ea3897c50c3e97e512bde9757a86ec7c07c6ff43ab7b49f481473b4c0e0a2167ac5863ff7b77fe6ea5731cac21c2eec3a4c583be58005a68e9b1272cb3db693fbd5899ca70a6ebcd07c3904bac167dd3885cea992f0019a36c17def32b336b68110c3bee7b86feaa49cb8f63bb64a5fc90eea9e4915f454a12c356d0c9f3e0240b2637dcbc51944a0a7f06033f5615da6f725c61f522988c552067e942ecefdb1fe6a222a5e5926ba712b9bfa9f6ea301e70d1071d61a4a8d9857835c744e6a145242378de8f8e86f9abe88aa22be06a9ebc384c548fc233fc4e0421e006eed8e3ae4e8f574ccfbf1e37fd3844ecbad19d693fc0d85f5729f5c4d3b554984674b18c9e88b20432c63f65d3c3d664b3dc2439a65df1abbe827caf5e6854974772261c358e80a9084eae9c9d69d5a3f22f2f5233b6574001555898919d4a398cfda81c23cec2e56180d5fa92e8bd3f602273ab1c0fb7df6fe843a644d4b304d20c9c562e9483eaea8ba108629cedb13b330802026d91e5d7481c0075e1785783ccecc79bb428faa5c465b421cd358d2c15f47742f34903103a5478799c658ce0f0ac468c2fb34cb4acdc7c5daf1053fe11b6470f7f239ce74b6edebcc6361e2e082600c3a9ea81110c76346b27ba9eea63c7c10e2e6e5ede047f6f416102a67c3863049ab1ca65c1a484314dc620ceb183d55db3e0a37cfd42b11ccffde71a45527183b1f58cce3a653bb19c43205d7589ffa45143c0ac4a399c56c090b9881be47f1954f9544663e1e9dc1a609017707a918741da47b21e0a5244f6880fc4e5b50cf9429992b4b20da199fc61dff6bc184abf47b9d558d2b2f62e0ff4df63a25b86bb66ea84415268b54bf4fe23a2bfa1dbc457e44ef38fd1495a5b61b8647b00d788dd2438ea6a5445f2abc5e3253062bbf786be02efe05f577ae1739f0136fee0b2d41d4a8956d42fccfbca9ad045999aba88eeb269098280e3dbb71cca4c9b463462aa7a4154ca1d23beebe2c3f62d61cd7c503b6cf73d8eb4936a1936d9933a150a738dcc2e761a2dde2dcd2a12a15de16eccaf1e9a134079bfb50eb10a1d01609f74eed0cd4b2d8c38ac7ef165c0b4304badee7371ac6906a97d8849431e7c050eca739f2813b53ca2f2aed73c0adda4a38f9097a583178e199a2b0cc7693e5df35021fc767a872eb8b4db4ca26598b4b16b36c02c67629bcf7045bd161bc7a0720713a63b772e5987b422a16027324fbdbc16a1866af3a0df065375e6655a757a50d8d25928381662c0cfb8008d0efb28e72960cab86f571e1a94f549de4330ccc2450b391cf06aa6da061f89924da941669219defc6b2f57e118d1ef13b125cf6f4c7e23eaba3d69bc5e75de65d1d3d7970c22a606fdb6c9f304b31c72426c31b7b32bc36edf2edbc44d6226acc8933ea6b41adf4ea2c0842c0187f8e39e44f77f7f9635501f687934ad9723f7cf477a5e92995b22e0d806513679168034f842152104efa24317b89c145a081ffe54935db23dd23015393fd3fd6103ec8a056a9eab1677e9d370127bae3bf6be52688a1417f646a3699fc575ac5793a14f617201d283299f5a664de770cec5fc7af28db92b4d387328c724689b5b38e73d18aca485809a0f72f51a87a900566d90857cd7e7f0829962841c6a0ec176e43f084aaaabf4ee055d28a50d5560fbc5af3113c98dee66d2a3da870386184447576c1ca4b6598dbf1fd3c792303557afa0ea2cc2d97d429303c0c842c9efeb4a6cc826f8b1f85d1110b38a61b74cf21fdf35d8111e701f4a5fe6ddca56567338a6cf3a54f6f2c0d7d2935aa5b72e92289b14c8c5fd3b7db73f13e6b9db1d573b9d882a73246848e22289683c20d830c529f3e4b1b1bbbd3259302e748172c5dd9bf00409e767e8a93905db0634795206de4fe60f878b24858c28911074f6a5de48eea903886320d20091f81e986d4881aa3f09056a3b58c066a7da0af3dde866783cd47a0416e9dfcbb7171e37f4a9b37c930322d4918a89e47839d656997a7a638a3e39b71fc7eb64fc69290328f7a0395c18faaf89a0a6fea5d411c14c4d3900fbdd0b0188f2ed28cac1de131efe5208e8189bfc38d8eefd56d0a1aa105f5b6f661bf53288ab8a914ab59b67a3a7b7d14add3f50fccc0e991d4e2dafb4bba02e4e4f4d3c928b819e8cffe8a63dea97ec3e0f6b9190554cc711dbc1f41c257544b4715c784ccf154f2897b3304882542028603a649ecfb55c3527fb0121e8f3732faf6ab2ba585eff04ffca903c747f28ee498f96048125c1c20120443f8bfde813a32776c1844b4f5bcc15ee55fea388cf2db2c3231ae8ffb002759b74dc86d64c8acfb6bfa69d9f87318342de8d02a9a4c8867ca454650732c46a0aec63193f32800062dfd87b49d4565941def95e94c53c8fea279d776af2ec75e544aeae209e3cb946850cfde82f1655854c7142a0c20530ef0eabadc49c47fdc7c51d33cc9c506b7725bb8f1968d3a58fd066270a2d59949e55ffec5d53eefcc81af914fca9f562cba2d634322aee5d9c3238572c5cf5cb9eb7233e659a041c10c49fdddeec637c419cd81c5f57e47cae822b9d9af33436e9a9e4ed51f395d970cd0eb35e5e8de254547a5e0cb98373b7442e31bcd2b130e01df89837a68ac354878b0c3803c2ffc9c1ef673cb0fe730ae9a9b83bb2d45cf5e9eda2569e9cab966cc4d289265f8103879d8d9f8620b73f548ae03d8a3364bead85d724b04633a9384ae326565c7dc3a37cb4d6e8021c9c94a62386c85d47de8d6397c9568fcac2f9d44e28d35138fb54fc3f0980e0def518fc8f9ef0c71ebdc3c0d03d88997c93b2bdfc04447df2d5832ec3183b3bb365c414810658d766627f56c273ce4aad32055f0d301228c15148ef124d249891976d7ef797b181983092b319405375cd86fd315ee3fc529edea5f053b9b1d218ea4197c2b1c592174b9605f9f2215bd7de5f7420858331673f67de3bfd23e434e64457252f809679fe5a7da07de8f43fd146862c137390cbccfeed491e434e16c457cc68e907e1cc786f60978275cc14f04b982c4d7d8d71592fa6a8e9603ef09566ebdceb8746f41afa895e18fb902f1195c3403744b06294d0264850074eff0d8bfeab49843716b3587e97e6b8bc4482a7c1db47c010c8fc9fff1eb0e2f9dd6ae275b27e7fcf9f8c5531a5d833a0c4a602a3314d71f74f3865e2ba79c37a7603958867b0100a86fe422fb723c5374024f79134b48079d3a97d6f3034e698dfce23f887b97c333b1c1b7f0405ea4830826578a1871196eaeabc78021171b1cca0c168599deb2b12ce7603dba60833dff941e312a509a8e263c39509c114324243d889171f0a84042730ee127bc10cc56267a2fd7f6928e9f19563078cf7c987ba8aefbafd85a95c3a5e95edb0ff62af2a698373d8ae23fe1821a3ef103c4667a74424b9e4eb3b4d446766ae97737199b1d1791bca2e164d8b6721b15f46d4e9a5df7e0b67ed435517cffb07861b7427e827efa726e3f3719e9a5978774d571d804c0aed28ecff65f36dc2c63b748ec84426711403be85aa8bae7a146041d6f58344a6508ac47b863108cf4856529c03e0a2bc8d1cbb60e8b77d4e95d3f39b77523d69052997f02fd6b47f4b61eda898e9519d8d6f028b04f5aefb782ff1bf72dc7603a04126f4b1067ae063a4f83daee1a1a1910ba33949076df276f7f21c64649efebfda08373ddc1dc51e589fc96e38910aef94f169d7dcad4716ae0bca95cd3d42690683fbe5367532064f912ec3c8637d77b595f8c87d4dde4beae8d3ce8dc2099202fbfb00cd5053e8a109ce3a8b87c8d3658d04be807b090c160ff9977a0655752cdb93680339dffd5a39ff33014dad9df9c640b7ebb925c5632114ad5dc26108147ae00d970f2654bc5d0efd9c8d303230d2a1838374cf1dfaa7017fd7c62dcca78bc796ac731b2415ceaffd2d107182aa2ffa8d22f16531917c21391fe1474aa6a2f2f35de12e19016ce0050766fa1092d6a5db0976cabd3ef051cbe24691e7b0ba16cd6f4ae2cac3ce79be288e51a0d7f4a66daf704c00634016efe247765cb3efdde9f34fd5762d0dc4c49b1e5b2cdc6916c9080b0e495c2c8cbc3d26729bffb073ea1be2e454a4018907b43396545d9fb47afd06c2f4a10aaa77c75b0ba25e89c44a49d9470eb3f06b32d7548be87c47c90a3c1baa7f79b464acaad263b38a7dbca8a4873fa2cb5eda310c1d75ae367fb1afb52f1e4eab36210738dc0cfe094c11163a5da29789ffca1178dfcdf39477dfb63015ed428c519fa2a08f3fd8ad1332462920a46bb3f0b2e6474c16585ca174fbf8091abe5e55d0f64cb083a396afb7ee1ce52b5ca0b8c7d7535c6134abcdb8d727d4bbcbe0b43105d6970c067a4f623dcbb67fa70cdd63bc04ec00b46240ff98cc0ade6a9aea5c39c2592e3c670412e5ec38a3a5b2f4a7dc5548dd14b3ee02b52d0d254bdce61fdbf02f1c2022c07de0e190f2c606f983f67db24b4ca725b7c8659eccf374210790a37d1aa0b12f6f1d6f434142a12fcdcbaea49c624cbf0d4902e43ae5edb5c1514332ed7e63d702450e12d61980fbbbe77b62cfb69b6ed91b1b62b1a4590af326263d5aee5924bcfad7167e7b097db284c6a3ce53240619ac666e5d528fb938132e890d3034b4f7c976f3c0a7b80a3aa1647b9f6ff7c0e3635c4208f4bfb1d00f852f315e2fe200d188334261affd03b4ebf78cd328c738a430fbc9e77cf39b27030120f39e1a4d6a26102d29e476ec8ce97825efbf6660f3ed78e37c2ae5e25b3fab4c8274950fc09adbc62a27e5611ca5619d957e32337dd732b6b7602ea7da81bb45993ed28a0a7eeaa03829d11a4abcf9a33ad15aaab479d8c0351896d083a88c018e076550f29d0f813c08a67550fa2c85c10801bb3b0b12bc00397565acaba9165ea5cfcc3d54c3c9819b6911453a8c4e8a2503368437c7975495cc37b56ec5dec012d362827d89d96b3d0070a4e53540563bb1f34455772fa9130a176527ab1996e9f59afcfc25dcc337a81d9e7adf83a75e4df913b1f3bc53821ad4cb1fb7028bb25a05b12ba67d530e22dbcd06b84d1ad41e6211c94973d4d24e6e6899745225beef569fa76aaa0a6a8293740a5849e767e5af2abf161b48e27041ec59e84b8debde6c4e183e9b93e51504ff1f59d9d5ecd4cab87c71d696186dcc264144e9f187809308ae7a773668dbfd8cf4dec334275e1d203e1559499a85984a09e60cb4d7017ddacdf7d9094641ff20a2ceaf39961d8298436907fbce9b87f4cf2dc072e388d54427d9cee5d73e46632538f16ecc1979771145d9c5e4c68d5080091ee0f44ffd4ab83b65cdca725e7671d404e26f820d414b3a971b0dcb6fb132aa26c235c73b9bed7e1e192bf978dc8e7ce40aab66fd0495296fd829fdd26b8e76fb1037b67dab518b0a106e411350eee98e781cec47dbf0a76ed2a604f3154b00252a407061c916a4f70899db5bac4071c768050f169ecc4ffe8c4cb861e8c59db808a9f7acb22e21774d1227263f922437ed1791f9c7342989235f0f0a7f686409b9b94ee75d43195db1ed83c114895cb3a85b3d5260c93f599aeb7a9dd78dd52fedfb0d5f685a1513d7f1f02412c348daaf8ba259d217bce263d54fdf657e6d8139fa435034ff4f49cdf4d618981703542867df4bd96322554240b8f56326a5d0fb3a295757e62ca252f9ec79e7f87dc0d52fbd5572113a5e80c15b2f68e36713d78c08980d54b1a0b0c1ad6d66fbd9942fb46ad84cfb38aa35c5508610e98df3cc752a7b0d93d31fe57c813216938472016a183c35350c31d9f89c8f42494dc6d330af265c55d8acc4a7fb37a4e72b1bb6226aea07cf11f8295c172efce0de1c8b90ecb76947de22551dbab1afeaebd094369b3e9cf9a23f3ed598cb076d465158653f387661d054ed87b1716caf979fc272b5b420487d06ab3aa6ce5e3959f7281724ba3f91a9d89ec1c4ee78d6d02aecb3ed92890f9c81ac908bd992be0bef74900a8f2789b5ddde70933c0bc1256de61577fe27bfb80672ee8e4a312984c5a6ef02832fc3ab3af9d7fbe9c7ff066bd5ac907ad5694f85a909aba5aed23aaf15fa94c9742febd9895b29d705b34804e8c559631881ebcf017338bb9992e14ba7781c5e3793003d53f82e59c8080cc30d5d3ae8fd330201f24517add1025f29295696aec94f60e1ff5917b8f724b4352cb54d2b84b2d0d180a35d34027ad9d06f160fc385e7f61a8a0381dacbd522d831afefc9bf0a6f04acb48e5795c5e97b76b4301abaecbecb423cc2e4a48a832c9e6477c0248463e32201df27d1f3fa69e8dec4c0cada9650de099a90e6ef4d795547d0df19c39da295590aff8a50752316e8026a6d639171553846884d49e3f1cc4b58606931adeb37b95ac5cbf757a8673b65223f2104b3f1edeb2160143b7083e306a827e7752a867180db8f351d29e3db3b1527cdd8de7bb2eb7e79c6bbbcf99f21dbefbec3d1cdb3c0a380887f3ba8d6b44ed777e23374954ea15c63c1e26c5e83f876348a5ed6b33c79b594ca658d1d5135b6130bc85f6ac9d1b2595d211c01c76cd542bab942c97ce992ae0449c9f2de963b471300322974241b5d5b5f721a9b91e50e65c69990b79006ad99d3fbdd61f3ce670c38e132bd24c55e6959a222a09c137527cadd3f240513192087d77a9384e4017f24ad6b201006ffd4ac78e9896da77be9b8028052b839718d29898b6d109f4a585152ff09a44e039a75ee03033178075d2b9959c243dfc7e1efe1cb06b9cc18e29c7df01ba399473b65eaa1d1d4848ef19f5b6dbbd6d7384e9af500fd85f06c07f3e5e238b207818275e290de60b1a812a6cde7310f875504bf004a70dfd2bad23ab480b236e96b992c73dc235f167fbfe1c1e81f03f021c6f608f6db56a7aefcd4dea7198681f3f8f6b5ee3c89c650c5222b555e08898f08d5367ab2532669bbe9f2687683245f8979e397495e9d09e31aa5281a8a6997614e8321cc7aeb4783e59f780297f6006202a58bd8472273365333d4095747cb420e38d6d16a2443c82908982447444f954fc8af17f576fb54fb6c8506c4ed9ab4863180bd4f7ff07b62d504bf59223294737989ba22d7f2ad0ebf02d4b55b97ac48d11ac693c40d1e999ec1edba913d7e0f71224a97b20f609a51a43860aeed2b4bde50bb023bc4903dd4961c0dc7a69e790463c4c7bba6be1b8b9fa485b77b228da655927563dbe335c53f1f4d8a70363d571b1d5804dfee235cd6fc3ebb5d829b811c8bf993cf05ce4d7894925ce1a39db9f12c1bc6e925aeec4be004cf6f5eeae032bec50f459d7b18652d873604713a6e49ed23dc0a2a297ed71de4b8e6293ecd97605a66747e314c9ca39136f5b47105128d77c5d14c036f9e96bf9704de90cf241a3f110eb64d9e6384314ac97a16f9bc0fcde7780da3fdfb07dd79fd20cefbb9e791dd7c0bb049c0740ecd295a2e5d355edc98bbbb7bb165de0a55c46b03aaf16ae9cb18fab6d933237c2b82a51b816608fa03a0329fb62a13652820ce6c9ab1dbd17e34da967eff50a9bf250ac8be371a4043f087a5dc2c505954504d4d70b86697b6799d681eb777a1925afc5e9fa9f015e4dc6986d8bf1a8f56e0285ae6d977ffc85f5b8f82c3428f1797bcec4e29832c501f884f6688cc499a44926fe87dcde1c6d5a541cbcdab50b9fd9b81ffdb5f494340f15b5241e70722a30c2b93396a7ccaadb08640bbab5dab95112f88cef7f4e04fcecbc5b2d3f17d1f3ed6e5a1b8d60da6f812640a5d8d9a095324293b082e706a4d2881680aa2104510c832326da39ff484b1294d3bc3cc2ee98683807ab2a13e4c5b3dda938e8455ac2494618f294b5cbab7a17eae74b935df76479bbcec4d337a8e3c1ec682b3c7bd46768891176947a3cc14fd0b12251d7b8cd635db06b396a3d7bb5ef2aada9ad7b182d8dae5c689f11ff10c6969c44983b3d4f6fba12dbdd50d5a1093e4a270c9b21e21442a7ed12fdf06e0c5847d497ab7514f78222b5ad7a3bc5bce38da4f35954d02882e32322341a180cfdc2f2ae6cfe45aa18df2e1a281d0390efa571b01ac807759b0f6d0c8291331ce97dcdc64bada88230681aaf42b8e68b8bbef3ae43ff50a8a048a63fc59a3665ffd62a9f08aed7d06adfbb4c49a2499e51bd26b07b49c98265c35fca9aa678f7386eb4e4cb5081d8f054f2598eba13fcad8ac6b16f3c77156899b39d3e25013fedd1cc1b6d5631571c346903176ed1555269599b113ff4b99bdc477cfa7a930e9bd6240ee6a458840cf07bf7d9a3e4e9a1d99878c68fb3f67d9f567947b74f08943800c01a580323b06a671aaef24ff355b52a6240183268f0c49684d06c17907ca232858c929209ad0e6e5864acbf40720de9ce76426e465300968d3eea2933645a09834462a93e5c1fc2a4376586571d879ece7672cc3e0536296db64d383043e5cd612b2f988fd15c2d0baead1eb811b5fc0f6a2def4c91986b73e03aa820b73e239527427281722ce2af8c074c9c77106914749137fab51fa06d9be9a39870f7fb66303df0c897b7b44509c5da57450584275c79a8f8f6b160c3b5af93cf3b368100343041742b7b402a79b8ef7e5659ea8e4ab4a50bb643f511b5107033a7705fc0d09163adec351e622e9a074160d6cf5fe7e7a3db5e43718ea8904dbd0fbd1eba5d42704e8b78cf751fdcb5af3a9c11ff0dae888c42ab0da9b273c4509cb7c6dff705d22487215f3e2c155ff0ade0be0ddb38795a1260d0eb0d4f58562137d82a58a942d9000941ac50c18ed9cb10776c2e800e7fb5ebd9dbb417903c59f4365ea682105ef1158150a4a1945527c65c7cabf58a23778aa50c43d9ec410b2ac9bca8a786ecee965b3c66532f703666ce0d2338665889cf5d531022571759379776c9509b3a94653022665e1da22bdb76117a1bb511d80026ae4e1d047cc5ffa2d0c00e0b8342337c72d53975f03c92b617d2dcfff197f993a73f84adbd59eb393f0d8689ed6c4f03093213aee911b98413de3f15de91a86a8791fc90421109f743946a2f1385e00e84f9b5da964a64143a78dbdb110d35fa20a2f88ebcbff452c2b7e1eaf6bcc65cc832c96622fd98108711e621d27c78983fb5d90d0d1009069994b5b0f0bfb587e1df4a1ec4fad3e02e898badd072efbad72c75497631b28934d31680c46bfaf214db829c5f8eccfbfa6f0cccefaaf61cd700df792efc76d3b50b011239cf9ae428a032241f74af4e350675c377a0808f06b74b2ea0cbb935311f59225e9628646272d0edba4c5ccc5ecea1d2363de2da2bdf7eaf149855956f3e86ab533a34e9065cce8e30386655e57e197e50b53d3717d7b32cf7745753e791fbf367d76ddd13d038882fb6c627cc59261e52f29138619cec5c0abcf1d6e3a2412a6033f58defcd9169f896a327df45ca76d51f78849644ee29b6a1410a9bf876cafda1a8d17e43a4eee9109fc633ea24f3e9c7e90c324123cbb6ce4a9dc2cb8558a63ffa8463eecb174582d544cbd89286f30d6c7f97e2159d19ec9b5ba3c0133678089dffc92ff051a797e982f1545f1a88c84fa8e53c53c6777808fa2ace2d6afbd3aabc2d1966b0f4ba3777704c7a90c51700195cb8660528a22358d8a835cda1e7666e025dc7bedcc58466ab566ed3527274c3d590bc9e46f74c57acb7874f10e7d4ae366bb784cb6a0cf3c0dadf51e340a9d3707cef9175671c2d3ab7587394be62b62c7f99cb9efdad7a37be13d813509be2f03247395e6ecd3294ac1549761ecd060616c432ad693a2e2006729f4ee00c9c6d30001d45bba879ce5e96cad472e97cb0448cefc5811afc3c0ca3ef1257b2213b10f2e1edcce2eac421e7ae9a05fbc1a64351d35e9ae60822982968cf1cadc9cda1be20a6bffded6fe56d34403f420e46a30ca0b5c52e1c699c9acdd81c8344b689468b8b4b31bd01244735825bdfb22985333228d6e74d5fbda2940995995d8c9a1ba5c81573e8e6f9654354a3270d30527cf90394ed197cc18b7bef862cababb3ba336efd8a4198cbefc2b3a660625c69e0bb07bba4d21f798fdfe5755a3f2628d9d928509f4edd3c4cf52ae915a4a76c71e71d2f91933070a8c60c7694d122ea267d080633a2e1cb03209e5de9610a5075ef7c96576c26d309dbcd8fdca41d06679ce13c5d4f340e091a1ee9651f3dee095295daef962ee2b6d82d8609643c628f2ed8dd502c5568898729b1839f5c71ba435c9d0a6bd0b74744fbe52c919759944b734a7b5e091f931d8672cf01e490900fcdfe7dcd4dedc61dd70ac9e0416d75752222e10e45380e132a7d714ec9ddd6114d562e0cf94866e260b43b5eafd1123ab8be79cb21f6007b0be7879ad691624dc320de7b0a27026bfd11e09e62ea7085192bfde5bdf4870bf4a0226d89cf62cac81fce91ffef611d9ee077fc88aa0c289733aa3d3d205b03ff23e654b05f7c92f753226a4c6bc751c23683420edabf37c8269a01f74ef82253b75c173b20d4eef11a18cb071e468d48d139019476e1bb3482e5bc8d0c96f87ba18011240cfc1a6a6600ac4eabafda3d3927a4bba692965fb70a68340fb0bf2b3d3e6f9f27159ad384aadc13bd1e63846ac81b064e1fce36f7d2b48ec74c96c4e3be7a99657db1e3790f1a99bbee90248b52e220684f9f24479e7fb89c231fd84e19a84a5a393d7cefa64ec7c4c661a7bd242874044c58cdced9170f38ccd105d7a1e6166a08605c9b775577aa8c7d7776e86b35fa0005a49b6f9d6f9359379919b2233049cccb8da817e22e61475415a9f436770e6939cf4fd9c6d69451beb7612e99f4c1bb08810dbfead721a4130ba03f251506aaef65495683397b644feb849ea65b4076aa5e9d697c5f3a0fa034d8a8da52f14fa01b864f0b9633360a9a7dc26a896e3ffb2d35afac632479e80e8c9ecb939697e4ff50f18f430ab08fc494546586b32e4c2c648de113fc0ed42ec5d3e79a0e79ab2e0e96ed9770b8c687a3554e92df9986baaa81226ff667c6155f7f0341e4fdaf014c7b3eb4b7feb22e7729d6ac57927775642beb4f6e3c0d63928e9a41af7da3e8e56fa8fe5a8bf5f6dd6f881041a10c581601c63004697fbebad43116b924417e889b24832d536071518b697504a41bfcb10b9664ef1c7224b4a7b1235237367a2ea479fa3f242b218b9e430684bc6de2d94e123a4bcc47e33286c8c5ae04c2fb3db8da6f50fbf1e06d422e981e7067dea29defbe6d5462da9cd5dda317a17e572e8e201f24f8c605ebe9518b5d04f2f8eaf70c38e9672362f080749577d910d253ea02fdb0430fc9c1cba60bcc10a3dd97a7123023df08aceb25cc28210b305b918ecb27316b63d8c26cdf8d7d45ebc0e9a8e4baef8ef73c2c4404c499b4bdf857bf47bed479ce1d587b9f30216cfc8f245d960a14da380d826e11d539fe7feb8b25c6145914023198e6fbeff14cdece602494ff648f49fc2acb4fedc9a0516a32a065e6e7fc6682afd32757c2a7a98e2cbf8c07509b1d76cff93ea9767d368cc5ae87f3cd76d3c7fb5af910ffe4d167ec3a95fdef078a9f1fa2e7c58995c44d3da151ac37a04efd1d0f8b82143383c93ee028fedf95201f76fa5b839cb7383d0e8e9d90d769dedb889003abe51e2dbe7c043af408c4867ef8096254f2129546625f42c4fe4de658c144f01aa2c3982fa572997608b61b8572ca01f4a24e8d39e560aa7af1833ae1c6786e9e40dcce389e40a015659b80ef1037a65e2ed3b930ecfaa9c0998403be7022fdf5c339c591e7a8855808e71bfa98ee4fd7da763eee3060c6e859066e1d149db77b76f2895dacc57cb966ba8e9abd3b4363bc52986cac08d3115bd7959fd0bf9f1a832b5152444b99f565c1fd1e9961fd43ccc53a82799d44c536ad5b1500deb934109193f685ea4867b2a745b76234951dc4aa4346e2798f1cb9b23d8f39f59544505e05020404566eb75e6b77aca0181400f59ccbca8c18b320377f17b79f5a73fe4d1c3a421a50c70b84792e02c9a67e81bb9464c5b48acc4767df193aaa32e3f42c5d712eca99fcad80187b1f736e27cc9f460aefdce4bf1f74281bbb6b59718286f88b8233623170e681bdfd85f6668af5057e3074498d9e253df418cb0659eb508d13802bb8a684200119425071ffec17421ae22e29e52ef80a5de49df3ee166f3c5dc78b989509391d833a51d88fc626bc435f495b434f2d14e1a22b18445b3aa09a65aafe0a16baeec20d1a7d2952dba11b4e71ced47b4d5a99e3050a1bbab64ddbbe816dc299d7e440f1627a4845443e804465fa5b0bd50a1eb9d4dd51e8852ced88e8076a92241292df2eb16d9e0304d32ebcb96a76d90ff21eb477ddfbfe829ddf48c2c6b85e2040b1d5462ba54dd3aff0f637d366951e2f0fe3f2dcc123a97f198a81486674938d452be75869418f4cbabe8419fcdfd0c890bc8ecae8e29ddf0720c5fb69db26a3efbf558ec3fd9c35da97af7bcf2ac173616da7df5024d3cdb79d66710bf21d18dd4d3addd65fb2ba39c8aac745a4725fa770841904c3f92b2bce456b1b4278ad25645083d95d1330c9110e89b6d4bf9c6d58992c40a1c7c1a24fe2486dae63500775b084b52c47f59703cea50e33d87fed3a090b805fea8525db19d3ac45e10a18eab5beb659462d3f9465b1f6a26842967518e3984e639d18c7c8c75cf5ee5b241be23c917131f5eb4abea5bc24a3d9973ba43ae191b70ec8108cd97274ec55f95e30ae8e173d1dbbb3bf113e6475825d6148a43835e09d0f6bd988def15444cc83595196eefca7b204fdd86c6c2d769bec18d63b801b71ac9d9b248a8055511ec9495720726087499c74802db9706811196d110df0da532273137e9a6552f4e55b76a8c729e086f53401defa7e9643538639695f58605c4485952a845629274b38ddddb1ed0202bab355274652cea8f9f7e09d6a572eedf95a8a4b720a89e62fc2592b8ec5780f106f813848b5b2114578bce77de674ed379f9498f8dfb18502d59a0be96421f6ca9e618737dc7f699a0caaff41fec0385ee331197417d5c7e2a647e4e8c7664e5690cd3d61925cf8f492e42268d0dc049ed97b6f6cb4323eb0137ed2a34087db16a47b7718d682e32ba1ade0b7ecc3cee3de032b0c3adb35841550759a4037a2b3431085e72800947c0b7afeb6fa86e810c433d5b6994f663484912243c96db92f98ba0fb1a27b76fa0860b0fca2e48364af1981b26af0073f5527005477abeeab9bad6e472e37910702a9f10c9bb12a8f6b7c6b8986b80d2b5cf6b582fd5561c95e83e20671b43826c7d350df3ddfe4d79b9c6a4c14de41ad491cc529aae312098163ce2175c3bd55d9edbe5a84b2a18690653ece5a5a8d79ffce11f3d2442bfcb0b2a99aa67d86b3cd96b5c9864ea5cdfbc6641f42aab92bbfee6dada5bcae76e4653d8e20db230354fa0b2f39890a5906f79cc65c51ef7995a9cb9ecdb8e900e7afff2bc39dd350600b581ba218b613f4f70e33deb8be2a5552a5451fa10a74418586ed9308376e61d84bf71b1284977e1a1df92663c1679c759d37cb00380ec0b1314b5566e2b76c92dd3eedf9e6b1d2f01730866246335665ed73bf8703b98d5d31f6e4fdd9693e83a923d07f102a1c5f9c5b54613ac1b302e8825f2ebe375f27acb92ad95ce7e4a9a9dd406b07ced1f74e1f0ca50f9c6458d250f846e1d6c5481d4d72684cf54a808588afed297418f61659007131989484dab003e1eacb870b95750db01b477500bb646598ffa7b72ebf5751a9f07e48f4cd9b34f91231272413f2de856bf6785e518a51072c90834c92b2dd9f5363ce2d85d5c2b0e19a87797a407b0ff7b92451f7815831471a36d0fc512ba95b3cfa06b60c2cf499ecdb413af76992537a8dc98ac08bdb367e9e70f65343e1cdf74a8b390cb16068bbd4b8e5d1d78d9e0d440f7c54a0f561bb81dbb9c5f97425418d51d1db60d587360ae064a2527dd14e1b1a451d6a8c59a086c46b53c5d85eb3f987aa9210a97ac60bdca8397bf6cb61aaa9a704a78f63c692835bd1a9c0cee46cdb32c69a4f5278aa393514ace9bacf15d6e7c2cb99236fdc8d87f9d3b6688fd19a8a950461738599f8c5b4e0f36acc8d9100e0c249a5918bbb4cb0f030472fc2cdf486eedfe5e8d3ffa3eea4c2b26d25ab379b8641cd807f8572f81c6617fe3133c887bfe6871b27d67f97407cce0c7c4f3c7b4b8089429dc032c0314d26379e15c11defa55fb51392ff9b90c65f3677a9ef7c52abb822b404be6930ad6eb3630242a84911dafe3ff24a0b22239461a8111c9a850529ff4c3048aca57727c8b4a77212376bce8c8c4f126e66bf12f424ada56086b7609cb74c7635ebc103f40fa334662442e56e596ed9ad5ab2560021ec01f5849255155e3ebbb6c6abd73aa077bae24b242cca6275d47bf6f10df4bb9969d811d6c655a2ec7e5b705ce29fc2a9a8e52f1b162b545e7a9e8667474230c178c6e4a469115a76916040349335e7cb82e615bd11d11b05ea376a9a5f5feba4725817aef4c5f0720c840662e445b20b041fc701a932b600c63add84f038caea93d3848fba2f3c76a8fe9c0ba6e76183a709abac9d825c4dc3316ec54f34664ccb60d04cd787254dce3340127371c5da1ff7590893092cace26f7689d4fc95b7fd350a9d1e9c1250bf2b09b8ce91eb3191ce07232d55fd73a36854e069eed134e67d6d1c3b227c4e93b337bca8e0fe2f73cb1da35e70572400113c4a5c8b7b5d8f1b1c4bdfbadda24cd0513e50bbde0100efc6c1f3be5a0eded31559015d7a4e55fd83271ba8d7ae628763af8c58c938d5fe36af9ea361590c0cde1ea1aa244208008321a44ee9692e5140f686d921a8721e5818f40f9b6a22d2af7c6126de9cf24b6cf79a01600026114c4fc2f0904d7343c8e4626e9211fcdd01a1de2d233094f7e898ac028115b5f459e7938162d1c7c4b68999d4daf5be2815484e43ea3c56533e2b070779ae290e1321473299022bde32a2fe7271f89419df58b9ec49b6d3dc6d6a403681985b1f01507b7624feec5c96637fb1ad91f5d7a09d5189c9f53d102b3a4600add53f8cdbee92088846cc5cf25c821d2fa87743bac9f8fc8f5aa1b29d3da1254371a5194d7a54703f142885344f51e27ab25f624dcf9e3155f526b124e542b307d1547b47e8a56e59f15e412ba7dcb883ace1dc3b2ce06bd3bb577f15d61240bc110a07ee118485d3c393be997e2b54fa6f879d6a5120a54a64da375f73d3be91102f7f7251b13b12e0f509b063c8260aebe94dbb58a1efc940c453617f4898f1621e5eeec9b867771d3a606570a9a717be5ed196dd1de3e8d104ba7b2d968b6ef4e8487349f1e1e49d7c39f807cdd8ca4f3b57de5815314d7f8d4a934f309bba11aa63f2c0d156facac95708f8d0152c34304fc6327dfad04e5bde52fb5ecaa5993091899234e9fe28364e85944b3708902c04499107b97b0e5989e0b6dc5fa9bcbeb3e5c4e8cc876c7e31c6a7829a957217e92ee03b899c0c598aac44efd638a6c6c9615a88563b4898daf215216da9badbb62699b4b51106ec2147c9a4d6d552d93036d8b634abeff51d1174e7347560dbc5efc7e81684eea8f3d9b619a714384f8478910c525390efafcd68d70f1f43fdedca7b4bec865cb170eb1fe22516798788848be936d20e4e74d992e6343ffe689a5228df1eaf8ee669a42d7a2e7427bf54413d3d254b471270c52e4cba8f9d615103c5a7bd8ba1e0f01f77e1944e9dc075dd93c2bc0053875821392da3a0bea02f5619b1a6e345d22aa47c0afd5fd335005c7bc5b2a2bf8283030080b5e685f857746f762fedb7708486a61d425954dfe529802745d48bf6bddcba4b69e7d61ad6d0646968692cb4c4061d98f4785565abdb66b27929a78dc06455300a08bf52a7af2f21b05bf97051ca4af1ba13347c327b32806ded3b57b0c702109f39b4ed9752bebcb5fb60c46cc351060cfd3612fc78c3b3aac7088cbee257b1f2fbcab8192fe85d9ce6e682be0b3b28977798be3b234e2a9fa7904934e2e32d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推导 Y Combinator</title>
      <link href="/2020/04/13/deriving-y-combinator/"/>
      <url>/2020/04/13/deriving-y-combinator/</url>
      
        <content type="html"><![CDATA[<p>等了好多年，终于能听 Ian 讲课了。一会儿北京时间 20:00 马上开始。这里尝试重新推导一下 Y 算子，纪念这个我一生中历史性的时刻，也顺便找找编程感觉。现在，我已经打开各种可能需要的软件准备就绪了。</p><hr><h3 id="先实现不使用-Define-的情况下能正常递归"><a href="#先实现不使用-Define-的情况下能正常递归" class="headerlink" title="先实现不使用 Define 的情况下能正常递归"></a>先实现不使用 Define 的情况下能正常递归</h3><p><strong>第一步</strong>，正常写出 <code>mylength</code> 函数作为最简单的模型。这是一个接受链表（list）作为参数，返回其长度（一个整数值，显示链表中有效负载的数量）的函数。</p><pre><code class="lang-scheme">(define mylength  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])))</code></pre><p>测试 <code>mylength</code> 函数，输出正确的话就可以继续推导。</p><pre><code class="lang-scheme">(mylength &#39;(9 19 29))  ;; 输出 3 (链表有 3 个有效负载：9, 19, 29)</code></pre><p><strong>第二步</strong>，思考如果没有 <code>define</code> 来绑定函数名，我们要如何递归？于是，我们只能将上面 <code>mylength</code> 函数绑定在<strong>参数</strong>上。于是 <code>mylength</code> 函数作为参数传进去，以便能被调用。因此我们多加了一层嵌套，用这个嵌套带来的参数 <code>mylength</code> 绑定函数体内容。这样我们就可以使用它了。</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (mylength)                           ;;    (lambda (l)                                ;;      (cond [(null? l) 0]                      ;;            [else (+ 1 (mylength (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (l)                                ;;    (cond [(null? l) 0]                      ;;          [else (+ 1 (mylength (cdr l)))]))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>但是，如果直接调用这个函数就会报错。因为第二小块代码的 <code>mylength</code> 这个变量是没有定义的。于是我们把第二步中的代码（第二小块）修改成下面这样：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (mylength)                           ;;    (lambda (l)                                ;;      (cond [(null? l) 0]                      ;;            [else (+ 1 (mylength (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (mylength)                           ;;    (lambda (l)                                ;;      (cond [(null? l) 0]                      ;;            [else (+ 1 (mylength (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>但这样还不够，因为两块代码要求其输入参数 <code>mylength</code> 是个函数，不能是 <code>(cdr l)</code> 这种链表。运行到 <code>(mylength (cdr l))</code> 这段的代码就会报错。于是我们再改代码，把 <code>(mylength (cdr l))</code> 改为 <code>(mylength mylength)</code> 变成下面这样：</p><p><strong>注释：<br>之所以要这么改动，除了让输入参数符合要求（输入需是个函数）之外，更重要的是让这个作为输入的函数携带足够的信息以便之后的递归。即每次运行到 <code>else</code> 这一分支，函数都会通过 <code>(mylength mylength)</code> 保存一次自己后再进行对 <code>(cdr l)</code> 的运算。而正是因为函数每次都保存了自己（的信息），所以每次都能调用自己，进而实现没有 <code>define</code> 的递归。</strong></p><p><code>PS：使用函数打包（保存）信息后，能实现各种精妙的传递、嵌套和展开，要着重关注和练习这样的数据技巧</code></p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (mylength)                                      ;;    (lambda (l)                                           ;;      (cond [(null? l) 0]                                 ;;            [else (+ 1 ((mylength mylength) (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (mylength)                                      ;;    (lambda (l)                                           ;;      (cond [(null? l) 0]                                 ;;            [else (+ 1 ((mylength mylength) (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>到这步，我们发现这一大块代码可以直接调用来计算链表（list）的长度了。和之前有 <code>define</code> 时的代码效果一样：</p><pre><code class="lang-scheme">(((lambda (mylength)  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 ((mylength mylength) (cdr l)))]))) (lambda (mylength)  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 ((mylength mylength) (cdr l)))]))))&#39;(9 19 29))   ;; 输出 3</code></pre><p>既然没有 <code>define</code> 代码也已能正确运行，就说明 <strong>Y</strong> 算子已经隐藏在其中了。于是我们可以开始各种调整，想办法提取整理出 <strong>Y</strong> 算子了。</p><hr><h3 id="推导-Y-算子"><a href="#推导-Y-算子" class="headerlink" title="推导 Y 算子"></a>推导 Y 算子</h3><p>我们先观察一下最早有 <code>define</code> 的时候函数的样子：</p><pre><code class="lang-scheme">(define mylength  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])))</code></pre><p>我们的目标是把上一节最后看起来很多的代码转化成「一个函数的调用」，将「一块和最开始 define 的代码模式很像的代码」作为参数输入该函数。如果成功，那么该函数就是 <strong>Y</strong> 算子啦。可以用它来作用在其他更多的函数上实现递归。（如果看不明白目标，可以往下看完推导在回来看这段描述）</p><p><strong>第 1 次转换：</strong>我们看到有两小块重复的代码，于是先提取它们</p><pre><code class="lang-scheme">((lambda (f) (f f)) (lambda (mylength)  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 ((mylength mylength) (cdr l)))]))))</code></pre><p>观察发现，第 1 次转换之后，代码已经很像原来有 <code>define</code> 时候的代码了。那么是不是 <code>(lambda (f) (f f))</code> 就是 <strong>Y</strong> 算子呢？不是的，因为目前还不够像。<code>(mylength mylength) (cdr l)</code> 这一块的代码和原来的 <code>(mylength (cdr l))</code> 相比，多了一次函数调用。我们要继续提取，把它变成调用次数一样的模式。也就是一个函数将 <code>(mylength mylength)</code> 想办法变成 <code>mylength</code> 。</p><p><strong>第 2 次转换：</strong>把 <code>(mylength mylength)</code> 提取出来，通过函数调用来将它传入函数体</p><pre><code class="lang-scheme">(  (lambda (f) (f f))  (lambda (mylength)    (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     (lambda (g)                          ;;      (lambda (l)                         ;;        (cond [(null? l) 0]               ;;              [else (+ 1 (g (cdr l)))]))) ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (mylength mylength)    )  ))</code></pre><p>我们很高兴地发现，经过第 2 次转换之后，出现了长得很像原来 <code>define</code> 阶段的代码块了（被注释符号“框”起来的那块）。赶紧将这次转换得到的代码输入计算机，看看对不对吧：</p><pre><code class="lang-scheme">(  (    (lambda (f) (f f))    (lambda (mylength)      (      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       (lambda (g)                          ;;        (lambda (l)                         ;;          (cond [(null? l) 0]               ;;                [else (+ 1 (g (cdr l)))]))) ;;      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        (mylength mylength)      )    )  )&#39;(9 19 29))   ;; 死循环</code></pre><p>我们很遗憾发现，输入上面的这段代码，对函数进行调用，计算 <code>(9 19 29)</code> 的长度时，内存溢出，函数进入了死循环。到底是怎么回事呢？</p><hr><h3 id="中场分析"><a href="#中场分析" class="headerlink" title="中场分析"></a>中场分析</h3><p>通过一步一步地拆解函数计算的过程，我们很快就找到了原因：是 <code>(mylength mylength)</code> 这个表达式将我们带入了死循环。但为什么 <code>(mylength mylength)</code> 在前面的代码中没有进入死循环，而当我们将它提取出来之后就进入死循环了呢？我们来好好看一看这个表达式的计算过程吧。</p><p>第 2 次转换之后，<code>mylength</code> 这个参数获取的代码内容变成了下面这样：</p><pre><code class="lang-scheme">;;; mylength ;;;(lambda (mylength)  (  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   (lambda (g)                          ;;    (lambda (l)                         ;;      (cond [(null? l) 0]               ;;            [else (+ 1 (g (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    (mylength mylength)  ))</code></pre><p>所以 <code>(mylength mylength)</code> 就变成：</p><pre><code class="lang-scheme">(;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(lambda (mylength)                      ;;  ((lambda (g)                          ;;    (lambda (l)                         ;;      (cond [(null? l) 0]               ;;            [else (+ 1 (g (cdr l)))]))) ;;    (mylength mylength)))               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(lambda (mylength)                      ;;  ((lambda (g)                          ;;    (lambda (l)                         ;;      (cond [(null? l) 0]               ;;            [else (+ 1 (g (cdr l)))]))) ;;    (mylength mylength)))               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>然后变成：</p><pre><code class="lang-scheme">((lambda (g)                           (lambda (l)                            (cond ((null? l) 0)                        (else (+ 1 (g (cdr l)))))))    (      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (lambda (mylength)                      ;;        ((lambda (g)                          ;;          (lambda (l)                         ;;            (cond [(null? l) 0]               ;;                  [else (+ 1 (g (cdr l)))]))) ;;          (mylength mylength)))               ;;      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (lambda (mylength)                      ;;        ((lambda (g)                          ;;          (lambda (l)                         ;;            (cond [(null? l) 0]               ;;                  [else (+ 1 (g (cdr l)))]))) ;;          (mylength mylength)))               ;;      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    ))</code></pre><p>展开到这一步我们发现了，由于计算机会<strong>优先对表达式求值</strong>，而 <code>(mylength mylength)</code> 这个表达式被提取到外部之后，每一次计算机对它求值，都会生成一个<strong>仍然处于函数体外部</strong>的表达式 <code>(mylength mylength)</code> 需要计算机求值。于是于是计算机又会对 <code>(mylength mylength)</code> 再次进行求值，结果就是出现了不断扩展的，越来越长的表达式。</p><p>而对于把 <code>(mylength mylength)</code> 提取出来之前的代码，<code>(mylength mylength)</code> 这个表达式被求值之后<strong>生成的是一个函数</strong>，没有出现<strong>暴露在函数体外部等待求值的表达式</strong>。它同样会产生表达式 <code>(mylength mylength)</code> ，只不过此时的 <code>(mylength mylength)</code> 被包裹在了所生成的函数里。更准确地说，是被包裹在了函数体中的<strong>一个条件分支</strong>里。只有计算时进入了该条分支，才会触发下一次对表达式 <code>(mylength mylength)</code> 的求值。</p><p>于是，「第 2 次转换」的前后所发生的关键性变化是 <code>(mylength mylength)</code> 表达式的求值步骤由「原来的 <code>cond</code> 条件分支内部」被提取到了「函数外部」。因此导致：</p><ul><li><strong>求值的时间点被提前了；</strong></li><li><strong>求值之后会生成新的，需要继续提前求值的，同样的表达式 <code>(mylength mylength)</code>。</strong></li><li><strong>递归的过程 <code>(mylength mylength)</code> 本来位于条件分支中，于是边界条件（Base Case）所提供的终止功能就会发挥作用：每次先要判断是否到达边界条件终止程序，然后才会进入含有递归的过程 <code>(mylength mylength)</code> 的分支中。这样避免进入死循环。</strong></li><li><strong><code>(mylength mylength)</code> 这一递归过程被提出分支之后，程序运行流就再也触碰不到边界终止条件。没有了终止条件，就会导致死循环。</strong></li></ul><hr><h3 id="继续推导-Y-算子"><a href="#继续推导-Y-算子" class="headerlink" title="继续推导 Y 算子"></a>继续推导 Y 算子</h3><p>上一节我们发现了问题所在，就是表达式 <code>(mylength mylength)</code> 被提取出来之后会导致计算机要先对它求值之后才能进行之后的步骤。而它又会在被求值后中生成新的「自己」，并且这个「自己」也需要同样被求值之后计算机才能进行之后的计算步骤。我们希望它像被提取出来前一样，「对其求值」的这一步骤能再次被放进函数的分支内。</p><p><strong>第 3 次转换：</strong>将表达式 <code>(mylength mylength)</code> 打包进一个函数来延缓对它求值的时间。这种转换被称为 <em>Eta-Expansion</em> ( <em>Eta-Conversion</em> 的反向操作)。</p><pre><code class="lang-scheme">(  (lambda (f) (f f))  (lambda (mylength)    (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     (lambda (g)                          ;;      (lambda (l)                         ;;        (cond [(null? l) 0]               ;;              [else (+ 1 (g (cdr l)))]))) ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (lambda (x) ((mylength mylength) x))    )  ))</code></pre><p>我们将上面转换完成的代码再次输入计算机进行测试：</p><pre><code class="lang-scheme">(  ((lambda (f) (f f))   (lambda (mylength)    (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     (lambda (g)                          ;;      (lambda (l)                         ;;        (cond [(null? l) 0]               ;;              [else (+ 1 (g (cdr l)))]))) ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (lambda (x) ((mylength mylength) x))    )   )  )&#39;(9 19 29) )   ;; 输出 3</code></pre><p>成功了。我们可以接着转换了（每一步转换都要保证代码能正确运行才能进行下一步）。</p><p><strong>第 4 次转换：</strong>更改变量名，让内部被注释框选的函数更像 <code>define</code> 阶段的函数（<em>Alpha-Equivalence</em>）</p><pre><code class="lang-scheme">(  (lambda (f) (f f))  (lambda (g)    (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     (lambda (mylength)                          ;;      (lambda (l)                                ;;        (cond [(null? l) 0]                      ;;              [else (+ 1 (mylength (cdr l)))]))) ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      (lambda (x) ((g g) x))    )  ))</code></pre><p>经过第 4 次转换（已经输入计算机测试了代码），我们得到了和 <code>define</code> 阶段几乎一样的函数。除了 <code>define</code> 的位置使用了 <code>lambda</code> 之外，其他部分几乎一样了。对比如下：</p><pre><code class="lang-scheme">;;; 使用 define 的时候 ;;;(define mylength  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])));;; 没有 define 的时候 ;;;(lambda (mylength)  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])))</code></pre><p><strong>第 5 次转换：</strong>把和使用 <code>define</code> 阶段的代码很像的部分提取出来</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (y)                                  ;;    (                                          ;;      (lambda (f) (f f))                       ;;                                               ;;      (lambda (g)                              ;;        ( y                                    ;;  这个函数（块）就是 Y 算子          (lambda (x) ((g g) x))               ;;        )                                      ;;      )                                        ;;    )                                          ;;  )                                            ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   (lambda (mylength)                          ;;    (lambda (l)                                ;;      (cond [(null? l) 0]                      ;;            [else (+ 1 (mylength (cdr l)))]))) ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>第 5 次转换后（已经输入计算机测试了代码），我们最终获得 <strong>Y</strong> 算子，整理后（<em>Alpha-Equivalence</em>）如下：</p><pre><code class="lang-scheme">;;; Y 算子 ;;;(lambda (g)  ((lambda (f) (f f))   (lambda (f)     (g (lambda (x) ((f f) x))))))</code></pre><hr><h3 id="使用-Y-算子"><a href="#使用-Y-算子" class="headerlink" title="使用 Y 算子"></a>使用 Y 算子</h3><p><strong>Y</strong> 算子的使用非常简单，只需要在目标函数外再嵌套一层函数，把这层额外的函数所带来的参数名作为递归函数名就行。</p><p>比如有 <code>define</code> 的时候函数的样子：</p><pre><code class="lang-scheme">(define mylength  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])))</code></pre><p>这时候我们把 <code>define</code> 改成 <code>lambda</code>（这样就去掉了 <code>define</code>）变成：</p><pre><code class="lang-scheme">(lambda (mylength)  (lambda (l)    (cond [(null? l) 0]          [else (+ 1 (mylength (cdr l)))])))</code></pre><p>然后再用 <strong>Y</strong> 算子作用于这个 <code>lambda</code> 匿名函数就可以得到相应的递归函数 <code>F</code> 了：</p><pre><code class="lang-scheme">(define Y  (lambda (g)    ((lambda (f) (f f))     (lambda (f)       (g (lambda (x) ((f f) x)))))))(define F  (Y (lambda (mylength)       (lambda (l)         (cond [(null? l) 0]               [else (+ 1 (mylength (cdr l)))])))))(F &#39;(9 19 29))  ;; 输出 3 (链表有 3 个有效负载：9, 19, 29)</code></pre><p><strong>注释:</strong><br><em>Alpha-Equivalence</em>：不同的变量名可以等价地替换。即 <code>(lambda (x) (+ x x))</code> 和 <code>(lambda (y) (+ y y))</code> 效果一样。<br><em>Eta-Expansion</em>：函数 <code>(lambda (x) (+ x 1))</code> 可以扩展为 <code>(lambda (y) ((lambda (x) (+ x 1)) y))</code>，效果一样。</p><hr><h3 id="用-Javascript-的语法来写出-Y-算子"><a href="#用-Javascript-的语法来写出-Y-算子" class="headerlink" title="用 Javascript 的语法来写出 Y 算子"></a>用 Javascript 的语法来写出 Y 算子</h3><p>在 <a href="https://www.javascript.com" target="_blank" rel="noopener">Javascript</a> 的语法下， <strong>Y</strong> 算子的定义如下，可以利用上面的经验尝试推导</p><pre><code class="lang-javascript">// Y combinator 的定义var Y = f =&gt;   (x =&gt; f(v =&gt; x(x)(v)))  (x =&gt; f(v =&gt; x(x)(v)));</code></pre><p>提示：</p><pre><code class="lang-scheme">;;; 上面推导出的 Y 算子 ;;;(lambda (g)  ((lambda (f) (f f))   (lambda (f)     (g (lambda (x) ((f f) x))))));;; 改一下变量名（Alpha-Equivalence）可以得到 ;;;(lambda (f)  ((lambda (f) (f f))   (lambda (x)     (f (lambda (v) ((x x) v))))))</code></pre><hr><h3 id="进一步推导针对-Mutual-Recursive-的-Y-算子"><a href="#进一步推导针对-Mutual-Recursive-的-Y-算子" class="headerlink" title="进一步推导针对 Mutual Recursive 的 Y 算子"></a>进一步推导针对 Mutual Recursive 的 Y 算子</h3><p>上面所推导的 <strong>Y</strong> 算子只对 <code>mylength</code> 这样的 <em>Directly Recursive</em> 函数有用，对下面这种 <a href="https://en.wikipedia.org/wiki/Mutual_recursion" target="_blank" rel="noopener"><em>Mutually Recursive</em></a> 函数就没用了：</p><pre><code class="lang-scheme">;; 这里容易下意识认为要判断 0 和 1 这两个边界，其实只需要判断 0 这一个边界即可。;; 简洁带来严密。(define odd?  (lambda (n)    (cond [(= n 0) #f]          [else (even? (- n 1))])))(define even?  (lambda (n)    (cond [(= n 0) #t]          [else (odd? (- n 1))])))</code></pre><p>根据上面的结果，我们来继续推导适用于 <a href="https://en.wikipedia.org/wiki/Mutual_recursion" target="_blank" rel="noopener"><em>Mutually Recursive</em></a> 函数的 <strong>Y</strong> 算子。</p><p><strong>分析</strong></p><p>先明确我们的目的是什么：我们的目的是在没有 <code>define</code> 的情况下实现函数 <code>odd?</code> 和 <code>even?</code> ，然后从这个实现中提取出 <strong>Y</strong> 算子。</p><p>和上面同样的思路，没有了 <code>define</code> ，我们只能将上面 <code>odd?</code> 和 <code>even?</code> 函数绑定在<strong>参数</strong>上。下面我们先来尝试实现 <code>odd?</code> 函数。</p><pre><code class="lang-scheme">(define odd?  (lambda (n)    (cond [(= n 0) #f]          [else (even? (- n 1))])))</code></pre><p><strong>推导</strong></p><p>首先我们很容易知道需要在新的 <code>odd?</code> 的函数体内储存 <code>even?</code> 函数的信息，可以得到：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                       ;;    (lambda (n)                         ;; (这是没有 define 的 odd? 函数)      (cond [(= n 0) #f]                ;;            [else (even? (- n 1))])))   ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (odd?)                        ;;    (lambda (n)                         ;; (这是没有 define 的 even? 函数)      (cond [(= n 0) #t]                ;;            [else (odd? (- n 1))])))    ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>然后我们要像前面的 <code>(mylength mylength)</code> 一样，设法让 <code>odd?</code> 和 <code>even?</code> 两个函数在进入递归（ <code>else</code> 分支）的时候都打包保存一次自己，以供之后的递归（ <code>else</code> 分支）可以继续保存和调用“自己”。于是代码先做如下修改：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                              ;;    (lambda (n)                                ;; (这是没有 define 的 odd? 函数)      (cond [(= n 0) #f]                       ;;            [else ((even? even?) (- n 1))])))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (odd?)                               ;;    (lambda (n)                                ;; (这是没有 define 的 even? 函数)      (cond [(= n 0) #t]                       ;;            [else ((odd? odd?) (- n 1))])))    ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>观察上面的 <code>odd?</code> 函数体内的 <code>else</code> 分支，可以看到当进入此分支，就要使用 <code>even?</code> 对 <code>(- n 1)</code> 进行计算了。而 <code>even?</code> 函数是要接收 <code>odd?</code>函数作为输入的，这样它的函数体内才有 <code>odd?</code> 函数的信息来实现它的 <code>else</code> 递归分支。所以这里的 <code>(even? even?)</code> 要改成 <code>(even? odd?)</code> ，这样 <code>odd?</code> 函数才能作为参数被输入进 <code>even?</code> ，进而实现传递（保存）。代码修改如下：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                              ;;    (lambda (n)                                ;; (这是没有 define 的 odd? 函数)      (cond [(= n 0) #f]                       ;;            [else ((even? odd?) (- n 1))])))   ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (odd?)                               ;;    (lambda (n)                                ;; (这是没有 define 的 even? 函数)      (cond [(= n 0) #t]                       ;;            [else ((odd? odd?) (- n 1))])))    ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>到这步后，目前的代码仍然有问题。因为现在面对的是 <a href="https://en.wikipedia.org/wiki/Mutual_recursion#Conversion_to_direct_recursion" target="_blank" rel="noopener"><em>Mutual Recursion</em></a> ，两个函数相互定义彼此。要想办法在 <code>else</code> 递归分支处保存双方信息。继续观察 <code>odd?</code>（当前正在尝试实现的是没有 <code>define</code> 的 <code>odd?</code> 函数），发现 <code>odd?</code> 函数在获得输入后，已经包含了 <code>even?</code> 函数的信息，还差它自己。所以我们修改代码，让 <code>odd?</code> 函数把包含 <code>even?</code> 的自己一起存入下一次递归，这样下一次递归就同时有了 <code>odd?</code> 和 <code>even?</code>，进而一直传递和递归调用下去，直到触碰边界条件停止。代码如下：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                                 ;;   ((lambda (f) (f f))                            ;; (这是没有 define 的 odd? 函数)    (lambda (odd?)                                ;;      (lambda (n)                                 ;;        (cond [(= n 0) #f]                        ;;              [else ((even? odd?) (- n 1))])))))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (odd?)                               ;;    (lambda (n)                                ;; (这是没有 define 的 even? 函数)      (cond [(= n 0) #t]                       ;;            [else ((odd? odd?) (- n 1))])))    ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>现在，我们得到了没有 <code>define</code> 的 <code>odd?</code> 函数。可以使用上面这个代码测试一下各种奇偶数了。于是再一次，<strong>Y</strong> 算子已经隐藏在其中，可以开始各种转化提取整理出 Y 算子了。</p><hr><h3 id="整理和提取-Y-算子-Mutual-Recursion"><a href="#整理和提取-Y-算子-Mutual-Recursion" class="headerlink" title="整理和提取 Y 算子 - Mutual Recursion"></a>整理和提取 Y 算子 - Mutual Recursion</h3><p>有了之前的经验，接下来的整理和提取轻车熟路，同样是 <em>Alpha-Equivalence</em> 和 <em>Eta-Expansion</em> 。<br>记得每一步变换都要确认代码能正确运行才继续哈。</p><p><strong>第一步</strong>，分别把 <code>(even? odd?)</code> 和 <code>(odd? odd?)</code> 提取出来：</p><pre><code class="lang-scheme">(  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                        ;;   ((lambda (f) (f f))                   ;;    (lambda (odd?)                       ;;      ((lambda (g)                       ;; (这是没有 define 的 odd? 函数)         (lambda (n)                     ;;           (cond [(= n 0) #f]            ;;                 [else (g (- n 1))])))   ;;       (even? odd?)))))                  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (odd?)                         ;;       ((lambda (j)                      ;;          (lambda (n)                    ;;            (cond [(= n 0) #t]           ;; (这是没有 define 的 even? 函数)                  [else (j (- n 1))])))  ;;        (lambda (n) ((odd? odd?) n))))   ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p><strong>第二步</strong>，分别两块很像 <code>odd?</code> 和 <code>even?</code> 函数的代码提取出来。</p><pre><code class="lang-scheme">( (lambda (even?)   ((lambda (f) (f f))    (lambda (odd?)      (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       (lambda (j)                       ;; (很像 odd? 的代码块)         (lambda (n)                     ;;           (cond [(= n 0) #f]            ;;                 [else (j (- n 1))])))   ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;       (even? odd?)))))                    (lambda (odd?)       (    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        (lambda (k)                      ;; (很像 even? 的代码块)          (lambda (n)                    ;;            (cond [(= n 0) #t]           ;;                   [else (k (- n 1))])))  ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        (lambda (n) ((odd? odd?) n)))))</code></pre><p>提取后：</p><pre><code class="lang-scheme">(  (   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   (lambda (j)                             ;;     (lambda (k)                           ;;       (                                   ;;        (lambda (even?)                    ;;          ((lambda (f) (f f))              ;; (Y 算子)           (lambda (odd?)                  ;;             (j                            ;;              (even? odd?)))))             ;;                                                             ;;        (lambda (odd?)                     ;;          (k                               ;;           (lambda (n) ((odd? odd?) n))))  ;;        )))                                ;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   (lambda (j)                       ;; (很像 odd? 的代码块)     (lambda (n)                     ;;       (cond [(= n 0) #f]            ;;             [else (j (- n 1))])))   ;;   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  )  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (k)                      ;; (很像 even? 的代码块)    (lambda (n)                    ;;      (cond [(= n 0) #t]           ;;             [else (k (- n 1))])))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p><strong>第三步</strong>，修改变量名（<em>Alpha-Equivalence</em>），让 Y 算子还有 <code>odd?</code> 和 <code>even?</code> 函数都更加明显：</p><pre><code class="lang-scheme">((  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (j)                            ;;    (lambda (k)                          ;;      ((lambda (g)                       ;;         ((lambda (f) (f f))             ;; (Y 算子)          (lambda (h)                    ;;            (j (g h)))))                 ;;       (lambda (h)                       ;;         (k (lambda (x) ((h h) x)))))))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  (lambda (even?)                      ;; (很像 odd? 的代码块)    (lambda (n)                        ;;      (cond [(= n 0) #f]               ;;            [else (even? (- n 1))])))  ;;  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  ) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (lambda (odd?)                       ;; (很像 even? 的代码块)   (lambda (n)                        ;;     (cond [(= n 0) #t]               ;;            [else (odd? (- n 1))])))   ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;)</code></pre><p>最终，针对 <strong>Mutual Recursions</strong> 的 <strong>Y</strong> 算子为：</p><pre><code class="lang-scheme">;;; Mutual Recursions 的 Y 算子 ;;;(lambda (j)  (lambda (k)    ((lambda (g)       ((lambda (f) (f f))         (lambda (h)          (j (g h)))))     (lambda (h)       (k (lambda (x) ((h h) x)))))))</code></pre><p>可以对比一下 <strong>Direct Recursions</strong> 的 <strong>Y</strong> 算子：</p><pre><code class="lang-scheme">;;; Direct Recursions 的 Y 算子 ;;;(lambda (g)  ((lambda (f) (f f))    (lambda (f)      (g (lambda (x) ((f f) x))))))</code></pre><p>观察这两个 <strong>Y</strong> 算子，是不是感觉 <strong>Mutual Recursion</strong> 似乎实际上就相当于两个相互定义的函数跑完（递归完？）一个「来回（周期）」之后，再进行针对这个「来回（周期）」的 <strong>Direct Recursion</strong>？</p><hr><h3 id="使用-Y-算子-For-Mutually-Recursive-Functions"><a href="#使用-Y-算子-For-Mutually-Recursive-Functions" class="headerlink" title="使用 Y 算子 - For Mutually Recursive Functions"></a>使用 Y 算子 - For Mutually Recursive Functions</h3><p>为了方便，用 <code>define</code> 来帮助定义，以减少代码符号，让演示更直观：</p><pre><code class="lang-scheme">;;; Mutual Recursions 的 Y 算子 ;;;(define Ym  (lambda (j)    (lambda (k)      ((lambda (g)         ((lambda (f) (f f))           (lambda (h)            (j (g h)))))       (lambda (h)         (k (lambda (x) ((h h) x))))))));;; 把函数的 define 换成 lambda 然后把参数名变为对方 ;;;;;; 注释：此操作可以理解为自己需要对方来定义所以对方要作为输入 ;;;(define o  (lambda (even?)    (lambda (n)                              (cond [(= n 0) #f]                           [else (even? (- n 1))]))))(define e  (lambda (odd?)    (lambda (n)                              (cond [(= n 0) #t]                           [else (odd? (- n 1))]))));;; 通过 Y 算子可以很容易得到 odd? 和 even? 函数 ;;;;;; 输入 Y 算子的先后顺序决定了函数的效果是 odd? 还是 even? ;;;(map ((Ym o) e) &#39;(0 1 2 3))          ;; odd? 函数判断是否为奇，输出 (#f #t #f #t)(map ((Ym e) o) &#39;(0 1 2 3))          ;; even? 函数判断是否为偶，输出 (#t #f #t #f)</code></pre><p>PS：<br>更多关于 <strong>Mutual Recursion</strong> 的信息可查阅维基百科 <a href="https://en.wikipedia.org/wiki/Mutual_recursion" target="_blank" rel="noopener"><em>Mutual Recursion</em></a></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客常用的 Markdown 排版语法和技巧</title>
      <link href="/2019/09/18/markdown-cheat-sheet/"/>
      <url>/2019/09/18/markdown-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 官方有很多帮助排版的语法，详细内容可以参见官网的 <a href="https://hexo.io/docs/tag-plugins.html" target="_blank" rel="noopener">Tag Plugins</a> 。这里列出的是常用的。</p><p>需要说明的是，由于本博客 <a href="http://cps.ninja">cps.ninja</a> 加载了 <a href="https://highlightjs.org" target="_blank" rel="noopener">Highlight.js</a> ，所以有些语法会用不了，比如给代码块添加 <code>caption</code> 和 <code>URL</code> 等等。</p><hr><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p><strong>Hexo</strong> 采用 <a href="https://hexo.io/docs/asset-folders.html" target="_blank" rel="noopener">Asset Folders</a> 的方式来管理和博客相关的各种文件，比如 <strong>CSS</strong> 文件，JavaScript 文件，图片文件等。</p><p>首先开打开这个功能，需要在 Hexo 博客文件夹的<strong>根目录</strong>下的配置文件 <code>_config.yml</code> 中加入这一段代码：</p><pre><code class="lang-bash">## ~/blog/_config.ymlpost_asset_folder: true</code></pre><p>之后，每当使用 <code>hexo new</code> 创建新的博文时，都会生成一个对应的 <strong>asset</strong> 文件夹来存放这篇博文的图片等文件<br>比如：<code>hexo new java basics</code> 在生成 <code>java-basics.md</code> 文件的同时，还会生成一个文件夹 <code>java-basics</code><br>把图片 <code>IntelliJ.png</code> 移动到 <code>java-basics</code> 里，就能在 <code>java-basics.md</code> 里使用以下代码插入这张图片：</p><pre><code class="lang-html">&lt;!-- 方法一：使用 &lt;img&gt; 标签插入图片，可设置宽度为 800 像素，高度自适应等 --&gt;&lt;img src=&quot;IntelliJ.png&quot; alt=&quot;Welcome to IntelliJ IDEA&quot; style=&quot;width: 800px; height: auto;&quot;&gt;&lt;!-- 方法二：使用辅助函数 asset_img 插入图片，此方法无法设置图片的排版，比如对齐或大小 --&gt;{% asset_img IntelliJ.png Welcome to IntelliJ IDEA %}</code></pre><p>如果多个不同的 <code>.md</code> 博客文章要共用同样的图片，就可以使用 <strong>Global Asset Folder</strong> 。该文件夹路径为 <strong>Hexo</strong> 博客根目录下的 <code>source/images</code><br>例如 <strong>Global Asset Folder</strong> 里面一张图片 <code>source/images/donate.jpg</code> ，就可以通过以下代码插入到文章中：</p><pre><code class="lang-html">&lt;img src=&quot;/images/donate.jpg&quot; alt=&quot;QR Code for donation&quot;&gt;</code></pre><hr><h3 id="列表技巧"><a href="#列表技巧" class="headerlink" title="列表技巧"></a>列表技巧</h3><p>如果希望以列表展现一大块内容，所有段落采用相同缩进即可，不需要、也不能挨着，要空一行，否则遇到代码块（code block）会显示不出代码排版。<br>代码块中的内容不能出现 <strong>2 个连续的空行</strong>，否则排版也会错误显示。</p><ul><li><p>展示列表中的大段内容排版</p><pre><code class="lang-scheme"> (define atom?  (lambda (x)    (and (not (pair? x))         (not (null? x))))</code></pre><p>这是第三段</p></li></ul><pre><code>- 展示列表中的大段内容排版  ``` scheme   (define atom?    (lambda (x)      (and (not (pair? x))           (not (null? x))))  ``` ## 说明：这是第二段代码块，段落间有且只能有一个空行  这是第三段</code></pre><hr><h3 id="带超链接的代码"><a href="#带超链接的代码" class="headerlink" title="带超链接的代码"></a>带超链接的代码</h3><p><a href="/2019/09/18/markdown-cheat-sheet/"><code>blog/source/_posts/markdown-cheat-sheet.md</code></a></p><pre><code>[`blog/source/_posts/markdown-cheat-sheet.md`](/2019/09/18/markdown-cheat-sheet/)</code></pre><hr><h3 id="带作者的引用"><a href="#带作者的引用" class="headerlink" title="带作者的引用"></a>带作者的引用</h3><blockquote><p>China is a civilization, masquerading as a nation state.</p><footer><strong>Lucian Pye</strong></footer></blockquote><pre><code>{% blockquote Lucian Pye %}China is a civilization, masquerading as a nation state.{% endblockquote %}</code></pre><hr><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>（排版要抽空修复一下，<a href="https://github.com/gaoryrt/hexo-theme-pln" target="_blank" rel="noopener">pln</a> 这个三流主题下的表格很难看）</p><div class="table-container"><table><thead><tr><th style="text-align:left">Left-Aligned</th><th style="text-align:center">Center Aligned</th><th style="text-align:right">Right Aligned</th></tr></thead><tbody><tr><td style="text-align:left">col 3 is</td><td style="text-align:center">some wordy text</td><td style="text-align:right">$1600</td></tr><tr><td style="text-align:left">col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td style="text-align:left">zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><hr><h3 id="若无论如何调整-Markdown-语法都无法实现想要的排版"><a href="#若无论如何调整-Markdown-语法都无法实现想要的排版" class="headerlink" title="若无论如何调整 Markdown 语法都无法实现想要的排版"></a>若无论如何调整 Markdown 语法都无法实现想要的排版</h3><p>直接写 HTML（在 Chrome 里调整 HTML 代码直到出现满意的排版效果，然后直接复制粘贴到文章里）</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Highlight.js 优化代码块高亮效果</title>
      <link href="/2019/03/25/add-highlightjs-to-hexo-blog/"/>
      <url>/2019/03/25/add-highlightjs-to-hexo-blog/</url>
      
        <content type="html"><![CDATA[<p>对博客的代码块（code block）部分的显示一直不是很满意，拖延到今天算起来一共是两年多了。这次总算下定决心搞一把。虽然当前是满意了，不过过程遇到各种坑让我觉得有必要写一篇博客来帮助未来的自己和其他有缘的过客。</p><hr><h3 id="为什么是-Highlight-js"><a href="#为什么是-Highlight-js" class="headerlink" title="为什么是 Highlight.js"></a>为什么是 Highlight.js</h3><p>Hexo 本身就自带高亮功能，只不过不完美，比如 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language" target="_blank" rel="noopener">Scheme</a> 这个我常用的语言它就没有高亮效果。话虽如此，这个自带的高亮功能在我所用的<a href="https://github.com/chpwang/hexo-theme-pln" target="_blank" rel="noopener">主题</a>里也比市场上的其他插件（例如 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">Hexo-Prism-Plugin</a> ，<a href="https://github.com/Jamling/hexo-filter-highlight" target="_blank" rel="noopener">hexo-filter-highlight</a> 和 <a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">Prettify</a> 这三个坑货）要好用得多。这里说的好用，主要体现在最终渲染出来的排版效果上的美观、设置上的便捷，且不会引入过多 Markdown 和 Latex 之间语法的冲突。</p><p>经过一番调研，最终我放弃安装 Plugin（插件）版本的 Highlight.js（ <a href="https://github.com/Jamling/hexo-filter-highlight" target="_blank" rel="noopener">hexo-filter-highlight</a> 就是一个基于 Highlight.js 开发的 Plugin 。这些 Plugin 虽然安装设置方便，其模块化属性也方便管理，但如果效果不好，不如不用），直接选择使用原版的 <a href="https://highlightjs.org" target="_blank" rel="noopener">Highlight.js</a> 。你可以在<a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">官方 Demo </a>页面查看它各个语言在各个风格（Style）下的显示效果。</p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>由于 <a href="http://cps.ninja">cps.ninja</a> 使用的是<a href="https://github.com/chpwang/hexo-theme-pln" target="_blank" rel="noopener"> pln 主题</a>，所以下面的步骤将以该主题为例来设置 <strong>Highlight.js</strong> 。</p><h4 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h4><p>前往 Highlight.js 的<a href="https://highlightjs.org/download/" target="_blank" rel="noopener">官方下载页面</a>，在 <strong>Custom package</strong> 的部分勾选你希望获得高亮支持的语言（想一步到位就全选），勾选完毕后点击 Download 按钮下载，得到 <code>highlight.zip</code> 压缩包；</p><h4 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h4><p>解压刚刚的 <code>highlight.zip</code> 压缩包，得到 <code>highlight.pack.js</code> 文件和 <code>styles</code>文件夹（该文件夹中包含了各种<a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">显示风格</a>的 CSS 文件）。接着，将 <code>highlight.pack.js</code> 文件移动到 <code>themes/pln/source/js/</code> 目录下，而 <code>styles</code> 文件夹（包括里面的所有 CSS 文件）则移动到 <code>themes/pln/source/css/highlight</code> 目录下；</p><h4 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h4><p>修改根目录下 <code>_config.yml</code> 文件中 highlight 部分的设置（主要目的是关闭它，其他设置只是顺便说明一下）：</p><pre><code class="lang-yml">highlight:  enable: false          ## 关闭 hexo 自带的 highlight   line_number: false  # auto_detect: false   ## 这里要注释掉是因为 hexo 自带的 highlight 的 auto_detect 这个属性有 bug ，且之后要被官方抛弃    tab_replace: 2</code></pre><h4 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h4><p>修改 <code>themes/pln/layout/_partial/after_footer.ejs</code> ，增加了以下两行（目的是调用第二步里我们下载的 <code>highlight.pack.js</code> 文件）：</p><pre><code class="lang-html">&lt;script src=&quot;/js/highlight.pack.js&quot;&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</code></pre><p>修改 <code>themes/pln/layout/_partial/head.ejs</code> ，增加了以下一行（通过调用指定的 CSS 文件选择相应的高亮风格，下面的例子里选择的风格是 <a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">Vs 2015</a>）：</p><pre><code class="lang-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/highlight/styles/vs2015.css&quot;&gt;</code></pre><hr><h3 id="其他微调"><a href="#其他微调" class="headerlink" title="其他微调"></a>其他微调</h3><ul><li><p>修改文件 <code>themes/pln/source/css/main.scss</code>，在末尾（为了覆盖前面的设置，所以加在末尾）添加 CSS 设置，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="noopener"><code>white-space</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap" target="_blank" rel="noopener"><code>word-wrap</code></a> 属性会分别让 Chrome 和 Safari 浏览器支持代码块（code block）左右滑动显示超出内容（overflow）：</p><pre><code class="lang-css">pre code {  white-space: pre;  /* this code line alone can make code block to slide in Chrome */  word-wrap: normal; /* add this line to make code block to slide in Safari */}</code></pre></li><li><p>修改 <code>themes/pln/source/css/highlight.scss</code> 文件里 <strong>.code-block</strong> 类的 <em>border-color</em> 属性为 <code>#2d2d2d</code> ，使得代码块的边框颜色与背景一致；</p><pre><code class="lang-css">.code-block {  // ...  border-color: #2d2d2d;  // ... }</code></pre></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成上文提到的所有操作之后，使用下面代码让高亮设置生效：</p><pre><code class="lang-bash">## 生成压缩版的 css（让 pln 主题的相关设置生效）$ pwd~/Documents/blog  ## 确认当前目录，因为下面 sass 命令要输入相关路径$ sass --style compressed themes/pln/source/css/main.scss:themes/pln/source/css/m.min.css  ## 清空缓存，并重新生成文件（让 _config.yml 里的设置生效）$ hexo clean$ hexo g</code></pre><h4 id="一些心得："><a href="#一些心得：" class="headerlink" title="一些心得："></a>一些心得：</h4><ul><li><p>写文章的过程中，有时候会遇到 Markdown 和 Tex 语法冲突或者奇怪显示的情况，不要慌，只需要调整一下写法就能实现想要的效果。实在不行，还可以在 Chrome 的开发者模式下调节 html ，设定出想要的效果后直接复制 html 代码，然后粘贴在 .md 文件里；</p></li><li><p>按照以上方式挂载 Highlight.js 之后（此时，Tex 语法也已通过<a href="/2019/03/16/hexo-with-latex/">这篇介绍</a>配置支持）， Markdown 语法中在使用 <code>``` </code> 标记代码块（code block）时，其间不能有<strong>连续两个</strong>空白的行，只能有<strong>一个</strong>；</p></li><li><p>不能紧贴着 Markdown 的 list 标记内容写，之间要有一行空格。之前的「紧贴」是为了实现把代码块（code block）归属于某 list 的 bullet 的那种缩进效果。现在请直接使用 tab 来缩进；</p></li></ul><hr><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>添加 Hightlight.js 参考了：</p><ul><li><a href="https://xiaobailong24.me/2017/05/26/Blog-Code-Highlightjs/" target="_blank" rel="noopener">使用 Highlightjs 为 hexo-theme-indigo 主题配置代码高亮</a></li><li><a href="https://www.ieclipse.cn/2016/08/10/Web/hexo-filter-highlight/" target="_blank" rel="noopener">Highlight.js 添加代码行号</a></li></ul><p>修复代码显示 Bug 的过程参考了：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors" target="_blank" rel="noopener">CSS Selectors - CSS：叠层样式表 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space" target="_blank" rel="noopener">white-space - CSS：叠层样式表 | MDN</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap" target="_blank" rel="noopener">word-wrap - CSS：叠层样式表 | MDN</a></li><li><a href="https://stackoverflow.com/questions/44754987/getting-osx-safari-to-honor-css-white-space-pre" target="_blank" rel="noopener">Getting OSX Safari to honor css “white-space: pre”</a></li><li><a href="https://www.w3schools.com/cssref/css3_pr_word-wrap.asp" target="_blank" rel="noopener">CSS word-wrap property - W3Schools</a></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让 Hexo 搭建的博客支持 LaTeX</title>
      <link href="/2019/03/16/hexo-with-latex/"/>
      <url>/2019/03/16/hexo-with-latex/</url>
      
        <content type="html"><![CDATA[<p>数学是个充斥着糟糕符号的领域，这些符号在语义上的随意性给知识的交流和传承带来了巨大的困扰，人们在参与数学活动的时候，超过一半的时间是用来尝试理解这些数学符号，而不是处理数学问题本身。尽管如此，使用这些符号来表达数学思想确实是现阶段不可避免的。</p><p><a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTeX</a> 可以让我们在博客里使用这些数学符号，它有着特定的语法。下面的教程展示了如何让<a href="/2016/10/08/how-to-blog-with-hexo/">通过 Hexo 技术搭建的博客</a>支持显示使用 LaTeX 语法所描述的数学表达式。</p><hr><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>安装 <a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">hexo-math</a> 插件，该插件（plugin）可支持使用 <a href="https://www.mathjax.org" target="_blank" rel="noopener">MathJax</a> 或 <a href="https://katex.org" target="_blank" rel="noopener">KaTeX</a> 来实现 LaTeX 排版系统，进而在网页上渲染出数学表达式（本文以 MathJax 为例）。</p><pre><code class="lang-bash">## 打开终端，进入 hexo 博客所在文件夹$ cd ~/blog## 安装 hexo ； --save 参数会让 npm 在安装 hexo-math 之后自动将它写入 package.json 文件里，以便之后多电脑同步时使用$ npm install hexo-math --save</code></pre><p>将 Hexo 默认的 markdown 渲染引擎 <a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a> 更换为 <a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a> ，引擎是在默认的渲染引擎的基础上修改了一些 bug 而已。此处不更换也没问题，本文以更换为例。</p><pre><code class="lang-bash">## 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）$ npm uninstall hexo-renderer-marked --save## 安装新引擎 hexo-renderer-kramed $ npm install hexo-renderer-kramed --save</code></pre><hr><h3 id="修改-kramed-配置，解决语义冲突"><a href="#修改-kramed-配置，解决语义冲突" class="headerlink" title="修改 kramed 配置，解决语义冲突"></a>修改 kramed 配置，解决语义冲突</h3><p>由于 LaTeX 与 Markdown 语法存在冲突（例如在 markdown 中，<em>斜体</em>可以用 <code>*</code> 或者 <code>_</code> 表示，而 LaTeX 也会用到 <code>_</code> ），所以我们要对 kramed 默认的语法规则进行修改，否则之后会出现很多奇怪的排版样式。</p><p>打开 <code>~/blog/node_modules\kramed\lib\rules\inline.js</code> 文件（Hexo 博客所在文件夹的根目录下的 <code>node_modules</code> 文件夹），把第 11 行的 <code>escape</code> 变量的值修改为：</p><pre><code class="lang-javascript">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</code></pre><p>同时把第 20 行的 <code>em</code> 变量修改为：</p><pre><code class="lang-javascript">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>改好后的代码块显示如下：</p><pre><code class="lang-javascript">// ~/blog/node_modules\kramed\lib\rules\inline.jsvar inline = {  //escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,      // 注释掉的默认规则  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,            // 新增的规则  autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/,  url: noop,  html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*?&gt;/,  link: /^!?\[(inside)\]\(href\)/,  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,  reffn: /^!?\[\^(inside)\]/,  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,  //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    // 注释掉的默认规则  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,                               // 新增的规则  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,  br: /^ {2,}\n(?!\s*$)/,  del: noop,  text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| {2,}\n|$)/,  math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,};//...</code></pre><hr><h3 id="设置-config-yml-开启-MathJax-渲染引擎（重要）"><a href="#设置-config-yml-开启-MathJax-渲染引擎（重要）" class="headerlink" title="设置 _config.yml 开启 MathJax 渲染引擎（重要）"></a>设置 _config.yml 开启 MathJax 渲染引擎<code>（重要）</code></h3><p>在 <code>~/blog/_config.yml</code> 文件（注意，是 Hexo 博客文件夹<strong>根目录</strong>中的 <code>/_config.yml</code> 而不是主题目录下的 <code>/themes/next/_config.yml</code>）中增加 MathJax 的支持，并手动设置下面的 src（这一步很重要，使用默认的 src 会导致数学表达式渲染显示失败。这里的关键是 src 中的 <code>?config=TeX-MML-AM_CHTML</code> 这个字段）</p><pre><code class="lang-yml">......# MathJaxmath:  engine: &#39;mathjax&#39;  mathjax:    src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML   ......</code></pre><hr><h3 id="使用-LaTeX-语法显示数学表达式"><a href="#使用-LaTeX-语法显示数学表达式" class="headerlink" title="使用 LaTeX 语法显示数学表达式"></a>使用 LaTeX 语法显示数学表达式</h3><p>经过以上所有设置后，重启 Hexo ，让各种设置生效</p><pre><code class="lang-bash">$ hexo clean   ## 清除缓存 - 让新的 markdown 渲染引擎 hexo-renderer-kramed 生效$ hexo s       ## 启动服务器 - 让 _config.yml 文件中的配置生效</code></pre><h4 id="LaTeX-的常用语法如下（更多语法请参考基本语法）："><a href="#LaTeX-的常用语法如下（更多语法请参考基本语法）：" class="headerlink" title="LaTeX 的常用语法如下（更多语法请参考基本语法）："></a>LaTeX 的常用语法如下（更多语法请参考基本语法）：</h4><ul><li><p>使用 <code>\\(</code> 和 <code>\\)</code> ，或者 <code>`$</code> 和 <code>$`</code> 来包裹一个内联（inline）的数学表达式，建议优先用后者，前者常出现语法冲突。后者有问题再换用前者。（参见 hexo-renderer-kramed 的<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">官方说明</a>了解更多 <strong>Tips</strong> ）</p><pre><code class="lang-tex hljs">`<span class="hljs-formula">$<span class="hljs-tag">\<span class="hljs-name">pi</span></span>$</span><span class="hljs-tag">`</span>`<span class="hljs-formula">$<span class="hljs-tag">\<span class="hljs-name">int_a^b f(x) dx</span></span>$</span><span class="hljs-tag">`</span><span class="hljs-tag">\<span class="hljs-name">\</span></span>(lim_{x<span class="hljs-tag">\<span class="hljs-name">rightarrow</span></span> <span class="hljs-tag">\<span class="hljs-name">infty</span></span>}<span class="hljs-tag">\<span class="hljs-name">frac</span><span class="hljs-string">{1}</span><span class="hljs-string">{\sin x}</span></span><span class="hljs-tag">\<span class="hljs-name">\</span></span>)<span class="hljs-tag">\<span class="hljs-name">\</span></span>(lim_{n<span class="hljs-tag">\<span class="hljs-name">rightarrow</span></span> <span class="hljs-tag">\<span class="hljs-name">infty</span></span>}(1+2^n+3^n)^<span class="hljs-tag">\<span class="hljs-name">frac</span><span class="hljs-string">{1}</span><span class="hljs-string">{x+\sin n}</span></span><span class="hljs-tag">\<span class="hljs-name">\</span></span>)</code></pre><p>上述代码分别显示为： <script type="math/tex">\pi</script> ，<script type="math/tex">\int_a^b f(x) dx</script> ，<script type="math/tex">lim_{x\rightarrow \infty}\frac{1}{\sin x}</script> 和 \(lim_{n\rightarrow \infty}(1+2^n+3^n)^\frac{1}{x + \sin n}\)</p></li></ul><ul><li><p>使用 <code>\\[</code> 和 <code>\\]</code> 或者一对 <code>$$</code> 来包裹一个块状（block）的数学表达式（这类表达式会在页面上居中显示）</p><pre><code class="lang-tex">$$A = \begin{bmatrix}        a_{11}    &amp; a_{12}    &amp; ...    &amp; a_{1n}\\        a_{21}    &amp; a_{22}    &amp; ...    &amp; a_{2n}\\        a_{31}    &amp; a_{22}    &amp; ...    &amp; a_{3n}\\        \vdots    &amp; \vdots    &amp; \ddots &amp; \vdots\\        a_{n1}    &amp; a_{n2}    &amp; ... &amp; a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}$$</code></pre><p>以上代码会显示一个矩阵（居中显示）：</p><script type="math/tex; mode=display">A = \begin{bmatrix}        a_{11}    & a_{12}    & ...    & a_{1n}\\        a_{21}    & a_{22}    & ...    & a_{2n}\\        a_{31}    & a_{22}    & ...    & a_{3n}\\        \vdots    & \vdots    & \ddots & \vdots\\        a_{n1}    & a_{n2}    & ... & a_{nn}\\    \end{bmatrix} , b = \begin{bmatrix}        b_{1}  \\        b_{2}  \\        b_{3}  \\        \vdots \\        b_{n}  \\    \end{bmatrix}</script><p>下面是概率界的贝叶斯公式：</p><pre><code class="lang-tex">$$P(A_i \mid B) = \frac{P(B\mid A)P(A_i)}{\sum_{j=1}^{n}P(A_j)P(B \mid A_j)}$$</code></pre><script type="math/tex; mode=display">P(A_i \mid B) = \frac{P(B\mid A)P(A_i)}{\sum_{j=1}^{n}P(A_j)P(B \mid A_j)}</script><p><code>sign</code> 函数：</p><pre><code class="lang-tex">\begin{equation}  sign(x)=\begin{cases}        -1 &amp; \text{if $x&lt;0$},\\        0 &amp; \text{if $x=0$},\\        1 &amp; \text{if $x&gt;0$}.       \end{cases}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}  sign(x)=\begin{cases}        -1 & \text{if $x<0$},\\        0 & \text{if $x=0$},\\        1 & \text{if $x>0$}.       \end{cases}\end{equation}</script><p>其他看起来复杂的数学表达式：</p><pre><code class="lang-tex">$$  \begin{split}  \frac{\partial{\mathcal{E}}}{\partial{x_l}} &amp; =   \frac{\partial{\mathcal{E}}}{\partial{x_L}}\frac{\partial{x_L}}{\partial{x_l}}\\\\  &amp; = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big(1+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}     \mathcal{F}(x_i,\mathcal{W}_i)\Big)  \end{split}$$</code></pre><script type="math/tex; mode=display">  \begin{split}  \frac{\partial{\mathcal{E}}}{\partial{x_l}} & =   \frac{\partial{\mathcal{E}}}{\partial{x_L}}\frac{\partial{x_L}}{\partial{x_l}}\\\\  & = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big(1+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}  \mathcal{F}(x_i,\mathcal{W}_i)\Big)  \end{split}</script></li></ul><hr><h3 id="引用与延伸"><a href="#引用与延伸" class="headerlink" title="引用与延伸"></a>引用与延伸</h3><p>有关 Hexo 设置参考资料：</p><ul><li><a href="https://linkinpark213.com/2018/04/24/mathjax/" target="_blank" rel="noopener">MathJax - Use Math in Hexo, Just Like Tex! (Including Common Issue Solutions)</a></li><li><a href="https://www.jianshu.com/p/d95a4795f3a8" target="_blank" rel="noopener">hexo 下 LaTeX 无法显示的解决方案</a></li><li><a href="http://www.sail.name/2018/05/31/use-mathjax-in-hexo/" target="_blank" rel="noopener">在 hexo 使用 mathjax</a></li></ul><p>更多 LaTeX 语法请参考：</p><ul><li><a href="http://data-blog.udacity.com/posts/2016/10/latex-primer/" target="_blank" rel="noopener">A Primer on Using LaTeX in Jupyter Notebooks</a>（写得挺好的，所以尽管原文页面已无法访问，还是写出来做个纪念。网上能搜到该文，我的 Dropbox 里也有保存）</li><li><a href="https://docs.latexbase.com/" target="_blank" rel="noopener">Online LaTeX reference</a>（比上面更详细更多细节）</li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨一工连载第 3 话：世界上还有一种英雄主义</title>
      <link href="/2019/02/10/yang-yi-gong-series-3/"/>
      <url>/2019/02/10/yang-yi-gong-series-3/</url>
      
        <content type="html"><![CDATA[<p><strong>攻略组玩家之间所谈论的「傻X」是些什么样人？</strong><br>内心敏感的攻略组不会公开定义他们心目中的「傻X」，甚至不会承认「傻X」的存在：“什么东西？没见过，不了解。”</p><hr><p><strong>为什么攻略组玩家有时不承认世界上存在「傻X」？</strong><br>战术性地向世界示弱，以便专注于他们想做的事。</p><hr><p><strong>「傻X」们算是坏人吗？</strong><br>和平年代没有那么多坏人。事实上，「傻X」中的很多人具有正直、善良、热心肠等美好的品质，只是这些品质同时结合了缺乏<strong>实践</strong>的智力而已。</p><p><code>......但玩家们因此就认为世界上没有坏人也是危险的。</code></p><hr><p><strong>为什么说「智力上的不平等是最大的不平等」？</strong><br>所谓的「最大」只是夸张的说法，经历不同的玩家之间有各自心中的「最大」。</p><p>过去的我会认为，智力的差异是造成玩家间生存优势<strong>差距不断扩大</strong>的主要因素。</p><p>后来的修行则让我逐渐有了新的想法：智力上的不平等只是<strong>表象</strong>。影响<strong>最深远</strong>的不平等，或者应该中性地说，影响最深远的<strong>差异</strong>，还是「<strong>运气</strong>」。君子之泽也会五世而斩。</p><p>和种群那种超长时间尺度的命运不同，在个人的命运中，<strong>经济状态</strong>差异造成的影响远比智力差异大。丽贝卡喜欢崇拜、可在我看来臭名昭著的楚留香老师在 2019 就提到「资产排名没到前 20% 的玩家过去十年是负增长，未来大概率会更加负」的统计推论。楚留香也许不靠谱，但她的这番言论仍然值得重视。</p><p><strong>智力</strong>，通常会被认为是认知的<strong>门槛</strong>。但我发现大部分健康的正常人，智力上都不会有很大的短板。对于市面上绝大多数的技能和概念，他们都有能力掌握。只不过经济状态<strong>关键性地</strong>决定了玩家们各式各样的学习<strong>需求</strong>和学习<strong>激情</strong>。比如「长期关系恋爱课」这种简单而绝世的课程有多少玩家有资本去学习呢？就算能掏出几百块钱报班，但不会有<strong>学习激情</strong>去为此付出<strong>足够的</strong>时间。</p><p>这东西和创业、养育子女类似，没有激情是无法应对过程中的各种痛苦的。</p><p>糟糕的经济状态将让玩家们不自觉地处于「<strong>生存</strong>模式」而不是「<strong>生活</strong>模式」。于是，对于世上形形色色的绝世武功，还在为生存忙碌的玩家们虽然<strong>有能力</strong>学习，但是<strong>没资格</strong>学习。这也是<a href="/2019/02/04/yang-yi-gong-series-1/">第一话</a>中提到的「<strong>广度优先</strong>」策略具有超高门槛的原因：经济状态很大程度限制了玩家们的<strong>激情</strong>，进而限制认知的广度：人们无暇<strong>知</strong>道，也没有爱<strong>好</strong>，更谈不上<strong>乐</strong>在其中。</p><blockquote><p>知之者不如好之者，好之者不如【樂】之者。</p><footer><strong>《论语·雍也》</strong></footer></blockquote><p>这种「良好到能<strong>守护</strong>甚至<strong>激发</strong>玩家们认知激情」的<strong>经济状态</strong>，是<strong>最大</strong>的「不平等」。</p><hr><p><strong>由于「神隐」玩家的存在，自以为是的攻略组遇到的未必就是「傻X」。他们将如何知道自己对「傻X」的识别是正确的还是错误的？</strong><br>很难知道。不过攻略组玩家会在<strong>谨慎确认</strong>对方和自己的诉求之后才会得出判断——比如采用<a href="https://rationalwiki.org/wiki/Rapoport%27s_Rules" target="_blank" rel="noopener">拉波波特法则（Rapoport’s rule）</a>。做到这样的程度应该就足够了。当然，也有攻略组坚持认为，不是所有对手都值得如此耗费时间地去尊重，直接拉黑省时省力。</p><p>总的来说，「<strong>真正意义上的对错交给命运</strong>」是位于攻略组顶端、行为模式千差万别的高阶玩家们为数不多的共识。</p><p>因为正像「能量守恒定律」一样，人类的伦理纲常公序良俗，如果严格较真，最终都漏洞百出，无法自洽。所以攻略组不会关心光头的精确定义，只需要直接判断谁是光头就好。<strong>双重标准</strong>是人类可悲的地方，也是其伟大的地方。</p><hr><p><strong>玩家们当如何应对来自「傻X」们的伤害？</strong><br>一、锻炼识别人类情绪及其变化的能力（比如通过看书学习），实现<strong>对自身情绪的掌控</strong>。如果自己情绪控制能力弱或者天生敏感内心脆弱，也可以寻求<a href="https://www.youtube.com/channel/UCL_f53ZEJxp8TtlOkHwMV9Q" target="_blank" rel="noopener">专业心理医生</a>的帮助。有些类型的伤害强行抗几次，很快就会脱敏。</p><p>二、遇到伤害先多反省自己，通过<strong>思考自己的诉求和行为</strong>来判断自己是否是全责，或存在部分过错。如果你认为自己每次都是对的，那你最好去找<a href="https://www.youtube.com/channel/UCL_f53ZEJxp8TtlOkHwMV9Q" target="_blank" rel="noopener">专业的心理医生</a>交流一下。</p><p>三、尝试和身边同在修行的伙伴，尤其是具有毒蛇嘴的伙伴交流伤害事件也有助于<strong>自我反思</strong>。要是身边没有能交流的，就找找古今中外的大神们神交。从他们的作品里和故事中寻求自省，热血和温暖（如果你竟然认为不存在这样的大神，一定要寻找<a href="https://www.youtube.com/channel/UCL_f53ZEJxp8TtlOkHwMV9Q" target="_blank" rel="noopener">专业心理医生</a>咨询——没想到这样的你也有耐心看我这冗长的连载）。这些伙伴和大神资源依赖玩家们平日的积累，比如日常「装X」和上网。</p><p>四、<strong>心灵按摩</strong>。找一些高质量的心灵鸡汤作品看看。可以是影视，也可以是文字，比如罗曼罗兰的「世界上只有一种英雄主义，那就是看清生活的真相之后依然热爱生活」。此外，宗教也是人类精神世界的重要支撑。需要注意的是，它是一种让人无须磨练也能获得精神力量的方式，不及那些通过修行获得的精神韧性那么可靠。顺便提一下，判断某种意识形态属于宗教的三个必备条件是 ABC ：Assure（确认）, Believe（信仰）, Convert（皈依）。宗教<strong>确认</strong>人可以救赎，宗教<strong>信仰</strong>某种<strong>精确</strong>的神学，宗教能让无信仰者<strong>皈依</strong>。</p><p>五、对自己进行<strong>积极的心理暗示</strong>，自我鼓励。比如属于「装X」基本功的「对着自己装X」：“……你这副浪样天不妒你妒谁？”。不需要在意其中幼稚的属性，自我催眠能缓解伤害带来的痛苦。</p><p>六、<strong>神隐</strong>。在隐身状态（不引起别人的注意的状态）下修行，达到提前过滤掉不必要的「傻X」的效果。在玩家们采用的各种神隐方式中，「装X」最实用。这种方式可以实现即使在众目睽睽的聚光灯下也能让自己的存在对<strong>特定人群</strong>无影无踪。与世隔绝孤军奋战虽然也能隐身，但是那样无法享受各种资源和<strong>自我存在感</strong>带来的修行方面的助益。比如 24 小时商业中心的物资供应，比如与其他人沟通交流的机会。</p><p>七、寻找一个<strong>无危害的发泄方式</strong>，比如玩游戏，比如私下里骂娘（绝对不能公开，即便要公开，也只在自己的小圈子里公开）。若是经常需要发泄，建议求助<a href="https://www.youtube.com/channel/UCL_f53ZEJxp8TtlOkHwMV9Q" target="_blank" rel="noopener">专业心理医生</a>。</p><p>八、情况如果特别糟糕，沦为声名狼藉的斗士、走上修罗之道与对方斗智斗勇也是一个办法。此方案要求玩家们具有<strong>相当程度的体力</strong>。因为情况糟糕通常意味着遇到了占据天时地利的「傻X」。他们或人数众多、或能持之以恒、又或者时间不值钱，消耗战方面具有极大的优势，平时不锻炼的玩家很容易吃不消。攻略组应该要做好<strong>至少 20 年</strong>（对，你没看错，就是 20 年，四分之一的人生）持续行动的准备，并且<strong>要时刻警惕自己，避免被巨大的情感、精力和金钱付出深深套牢绑架，或是迷失在“过剩的正义”当中</strong>。也许 2003 年 3 月中国湖南湘潭 22 岁女教师黄静的这个真实故事能给玩家们一些启示：<a href="http://news.cctv.com/law/20060712/101205.shtml" target="_blank" rel="noopener">漫长的告别</a></p><p>玩家们进攻的道路上危机四伏，没有沦陷的觉悟，建议还是走「神隐」路线。</p><p>九、当遇到上述<strong>走上修罗之道</strong>以对抗「傻X」的攻略组玩家时，试着守护他们。他们为我们沦为了恶魔。</p><p>值得提醒的是，在攻略之道以外，等待着玩家们的是<strong>同样（如果不是更加的话）无边无际</strong>的「虚无之道」，它是否真的比攻略之道轻松就只有空之女神才知道了，那是<strong>神知道的世界</strong>。</p><hr><p><strong>清华北大哈佛耶鲁这些学校里真的也是百分之八十的「傻X」吗？</strong><br>深谙「装X」神隐效果的攻略组们不会有任何的预设立场（Assume nothing）——毕竟面前的「傻X」可能是装出来的——并对各种可能出现的情况都游刃有余。他们的思维方式不是「名校里<strong>也是</strong>绝大多数XX」，而是「名校里，<strong>如果</strong>绝大多数是XX，我也不会感到意外」。新手玩家可以重复感受一下这两种思维的差异。攻略组在意的是名校所聚集的各类优秀的修行资源，比起这些资源，其他可能存在的问题都是小事。</p><p>有个无关紧要不过也许有玩家会感兴趣的八卦是，在<strong>初阵</strong>的时候，所有攻略组的玩家们都会<strong>严重低估</strong>名校学生、乃至名校教职工队伍的真相的残酷程度。<strong>所有因预先有心理准备而对残酷程度提前进行的补偿性高估，到头来都会是低估。</strong></p><hr><p><strong>为什么「傻X」浓度高达百分之八十的玩家群体非但没有走向灭亡，反而还能一起合作让经济持续增长几个世纪？</strong><br>羊群前进的方向是由领头羊来决定的，剩下那不到百分之二十的玩家起着关键作用。更深层次的原因还包括玩家们自私自利的天性等等。不过这不是个适合完整剧透的话题，在意修行效果的攻略组们不会希望过早出现过多的预设立场（Assume nothing）。</p><hr><p><strong>肚子里已然能撑船、能开飞机、能装航空母舰的宰相级玩家，为什么即便能得体应对日常「傻X」，当面对在至暗时刻帮助过自己的「恩人型傻X」、自己一直视为信仰或灯塔的「偶像型傻X」、还有得过诺贝尔奖的「权威型傻X」时，还是会失态，甚至崩溃？</strong><br>获得宰相属性的玩家无疑是异常优秀的。他们的情商（识别情绪与控制情绪的能力）已到达了很高的水准。然而这之后的境界要面对的是自己心灵中<strong>最柔软</strong>的部分，是攻略组们<strong>赖以前行</strong>的敏锐感受器。与这些 Boss 的对决将直接威胁到玩家们<strong>长期的认知</strong>，超出了单纯的情绪能掌控的局面。它考验的是玩家们<strong>对自己珍视珍爱的事物的取舍能力和觉悟</strong>。</p><p>与「恩人型」对决时，要保持「岂能尽如人意，但求无愧我心」的心态；与「偶像型」的对决，则建议「清华北大哈佛耶鲁也不会让我们感到意外」；至于「权威型」……</p><p>与「权威型」的对决通常要面对的不是一个人，而是一群人，一大群人，大部分的人，乃至大半个世界。这个群体中还会同时包含「恩人型」、「偶像型」等各种 Boss 级别的「傻X」，是最容易让已然到达宰相境界的玩家依然崩溃的对决。该级别的对决通常意味着玩家们抵达了事关<strong>高阶</strong>「觉醒」的关键转折点（高阶的意思是攻略组们的集体觉醒而非单个玩家的觉醒。这是一种蕴含着无尽希望的觉醒）。然而<strong>抵达</strong>是一回事，<strong>跨越</strong>又是另外一回事。简单地排斥是危险的。尝试容纳，与其和谐共处同样困难重重：<strong>正义间的对决异常残酷，“完美”的正义会突破正义自身，从而不再正义。而“瑕疵”的正义同样会面临巨大的牺牲</strong>（多数时候这不是简单的“善恶”对决。是“善”与“善”之间的对决）。</p><p>开启「神隐」模式固然是一种避其锋芒的解决方法，但如果所有人都「神隐」，攻略组将<strong>永远无缘高阶觉醒</strong>。</p><p>极少有玩家能挺身而出，因为代价很大，通常大到严重影响他们希望守护的那些人和事物。大部分进阶玩家会放弃对决，转而选择<strong>悄悄帮助</strong>挺身而出的攻略组。</p><p>做好了觉悟正面对决的攻略组，基本只有一条路，那就是发挥之前竭尽全力的修行成果，遍体鳞伤地和提供协助的进阶玩家们一起，尝试在一次又一次失态和崩溃之中寻找平衡。这一过程凶险万分，即使训练有素的攻略组仍然会在不知不觉中忘记当初战斗的理由，迷失在纯粹的战斗之中，乃至走上修罗之道，沦为碰瓷犯和恶魔。这也许是战斗不可避免的代价。（希望各攻略组能意识到，胜负的关键并<strong>不在于打倒</strong>「权威型傻X」，而<strong>在于争取</strong>那些……的玩家。在诸多对立价值中寻找平衡的过程中，次优解也许比最优解更值得推进）：</p><blockquote><p>……达尔文发布了这个「进化论」以后，到处去宣传和讲这个东西。然后有一次在一场活动中，有人拿出一个猴子，然后在台下冲着达尔文举起那个猴子，说「你丫才是它的后代呢」。然后现场观众也都欢笑鼓掌。然后他们被自己机智、幽默、锐利、深刻、阴损的这个风格给深深地迷住了。但是我们先知先觉的人呢，总是心里怀着悲悯之情。然后就觉得，虽然你是个傻逼，但是我们会带着你走向更美好的生活……然后过程中不需要你感激，不需要你理解，不需要你懂。你只要享受后果就可以了。</p><footer><strong>爱新觉罗·罗</strong></footer></blockquote><p>和所有被跨越的绝望一样，其实真的正面对决了也没什么。确实很吓人，但也没什么大不了。谎言的代价，并非在于人们会把谎言误认为真相带来的损失，而在于人们听多了谎言，便再也无法相信和分辨出真相。绝望的真正危险，也在于玩家们不再相信跨越的可能性。</p><p>祝愿这些挺身而出的攻略组们<strong>最终能有机会感谢</strong>「第一的执念」长期维持着的危机感、恐惧和绝望；感谢「健身锻炼」带来的充沛体力；感谢「装X」塑造出的精神韧性；感谢空之女神汇合了他们过去所有的挥霍。</p><hr><p><strong>面对差得让人时刻想说脏话的沿途风景，只在意“远方”的攻略组玩家们如何在浮躁中取舍和自处？</strong><br>一、积极地结伴同行（不必担心你的伙伴拖你后腿，你几乎只会找到当下和自己同一水平的玩家，不会低也不会高。有些邪恶的玩家也因此不时通过伙伴的质量来判断自身的实力。更有甚者会参考自己是否仍然被某些人<strong>讨厌</strong>或<strong>认同</strong>来判断修行方向的正确性）；</p><p>二、尝试珍惜每个阶段和自己同行的玩家。即使大家来自不同的星球，即使终将去往不同的地方，能这样在地球上短暂地相聚，还是很不容易的。想通了这个，心态就很容易健康起来；</p><p>三、修行那些能带来精神上陪伴效果的技能（比如乐器）；</p><p>四、多接触文艺型玩家们留下的精神财富：「……就算是舒适安逸，不甘平庸的灵魂还是会驱使他们在心里不停地追问，什么才是真正的……」；</p><p>五、保持危机感（不断冲击第一名以感受身为第一的恐惧是最佳保持方式），必要时进入「神隐」状态（隐身换来专注）；</p><p>六、每一次取舍都思考一下该事件在自己<strong>整个生命尺度里</strong>可能造成的影响（比如是否存在复利效应等等）；</p><hr><p><strong>看清了生活的真相之后，除了试着依然热爱生活，还有什么英雄主义的选择？</strong><br>持续贯彻和训练自己的<strong>好奇心</strong>。</p><p>即使面对真相带来的恐惧、痛苦、以及无力感，<strong>仍然愿意且有能力</strong>贯彻好奇心的玩家，是这个时代…哦不…在任何一个时代都是伟大的英雄。</p><p>好奇心会对他人造成伤害，乃至毁灭。<strong>但是</strong>，在攻略的最前线，「真相」比「善良」更重要，也更加凶险（善良这东西本身<strong>已然</strong>暗藏着值得高度警惕的凶险：往往是那些善良的愿望把玩家们带入了人间地狱）。尽管对于恰同学少年的灵长类来说，<strong>天然的潜力</strong>之一就是那无所畏惧的好奇心。可是，这类未经训练的好奇心，是无法应对各种凶险的。</p><hr><p><strong>还有什么鸡汤？</strong><br>在可观测的宇宙中，星系总数超过 <a href="https://zh.wikipedia.org/wiki/星系" target="_blank" rel="noopener">2 万亿</a>。定位出银河系后，还要过滤掉大约 <a href="https://zh.wikipedia.org/wiki/类地行星" target="_blank" rel="noopener">400 亿</a>颗位于适居带内的类地行星，然后才到 ZZ9 Plural Z Alpha —— 这个孕育了 <a href="https://zh.wikipedia.org/wiki/物种#cite_note-9" target="_blank" rel="noopener">870 多万</a>个不同物种的地方。于是，就算不考虑近 <a href="https://en.wikipedia.org/wiki/History_of_the_world" target="_blank" rel="noopener">5000 年</a>人类文明的时间维度、对应的地理空间维度、还有 60 多亿的数量，我们作为同一物种的人类在地球上相遇的概率仍然难以想象地趋近于〇。</p><p>然而这件事还是发生了……なんと素晴らしい……</p><p>无奇迹说（<a href="https://en.wikiquote.org/wiki/No_miracles_argument" target="_blank" rel="noopener">No miracles argument</a>）？</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨一工连载第 2 话：神最烦装逼犯</title>
      <link href="/2019/02/10/yang-yi-gong-series-2/"/>
      <url>/2019/02/10/yang-yi-gong-series-2/</url>
      
        <content type="html"><![CDATA[<p><strong>玩家们讨论的「装X」到底是什么？</strong><br>吹牛皮，向观众展示自己的某种优势。比如为了表现身材好，穿上紧身衣在镜子面前自拍一张发朋友圈。</p><p>「装X」本质上是一种表演。它和舞台或荧幕上诸如舞蹈、影视剧等其他各种形式的表演没有什么不同。在部分攻略组玩家的眼中，甚至人们的一举一动都是某种形式的表演（比如职场中刻意避免说出自己的真正想法、约会时打扮一番等等）。在他们看来，人生在世，活的就是个“形式”。如果活的只是人的“本质”（一堆肉？基本粒子？），那就太没意思了。</p><hr><p><strong>「装X」的具体行为是怎样的？</strong><br><img src="/2019/02/10/yang-yi-gong-series-2/1st-ds7-Beijing.jpg" title="北京首辆 DS7"></p><p>所有的「装X」行为基本都可以归结为以下三类：</p><p>一、<strong>直接展示</strong>自己的某种优势。例如为了展示自己的品味，朋友圈发一张法系 DS7 的照片，配上「北京首辆」之类非常直白的文案。圈中的玩家只能含恨怒赞。“嫉妒”之情，情非得已（得体附议）。</p><p>二、假装<strong>不经意地显露</strong>出自己的某种优势。例如同样是为了展示品味，发一张 DS 1:43 车辆模型的照片（购置车辆后，厂家会赠送模型或雨伞，所以有模型代表有车，甚至是特定型号的车，比如歌剧院限量版，或者应该说 OPERA 版的 DS7 ）。懂的人会知道「装X者」有车，是 OPERA 顶配，根据发圈时间还能进一步推出是北京首辆等等。知情的玩家无不窃窃私语。羡慕之情，情难自控（同好附议）。</p><p>三、假装自己具有某种<strong>其实没有</strong>的优势。例如，与别人的 DS7 合照发朋友圈。主演的玩家时刻小心翼翼。造作之情，情不自禁（自我附议）。</p><hr><p><strong>「直接展示优势」和「假装有优势」这两种行为我能理解，可「假装不经意间显露出自己的某种优势」是个什么情况？怎么会有这种需求？</strong><br>「假装有优势」由于水准低，且被戳穿后通常会造成巨大的负面效果，<strong>风险大</strong>。攻略组极少有人能驾驭。</p><p>「直接展示优势」的一个潜在问题是会引发各路牛鬼蛇神的嘲讽、嫉妒、挑刺等消耗精力的事件。这种「装X」方式在实际修行中<strong>不是</strong>最优策略：“……本来我是想帮忙，现在却得为自己的建议辩解。”</p><p>「假装不经意地显露出自己的某种优势」在展示的同时可以<strong>过滤掉</strong>自己不想要的观众（即懂的人秒懂，不懂的人没必要懂），效果拔群。是玩家们常用的「装X」方式。</p><p><code>注意，「假装不经意地显露某种优势」包括</code><strong><code>故意</code></strong><code>展示自己的某种劣势。因为在某方面的极度劣势有时会暗示着另一个方面的极端优势。这是神隐玩家们的招牌伎俩。比如失业在家看起来是劣势，但很可能意味着......</code></p><hr><p><strong>为什么大家都讨厌「装X犯」？</strong><br>通常情况下人们真正有意见的不是「装X」本身，而是「装X」的水准。被认为是「装X犯」的玩家一般是因为水准<strong>太低</strong>。</p><hr><p><strong>为什么多数玩家只能装出低水准的「X」？</strong><br>因为他们没有经过<strong>足够的</strong>刻意训练。这一般是对「装X」<strong>作为一场演出的本质和严肃性</strong>没有正确的觉悟导致的。</p><hr><p><strong>「装X」和弄虚作假有什么区别？</strong><br>假装自己具有某种优势的这一类「装X」显然属于弄虚作假。其风险巨大，不建议经常使用。玩家们所要修炼的「装X」和优秀的表演一样，展示的是一种受过训练，受到控制的真实。虽然不是天然的真实，但可以肯定这和弄虚作假无关。</p><p>为了便于理解，一丝不挂，蓬头垢面，就是一种天然的真实；工作场合穿着得体，则是受过训练，受到控制的真实。工作场合的穿着和行为举止没有旅行休闲时那么风骚，显然<strong>不能被指责</strong>为弄虚作假，即使它是苦心经营出来的得体（从礼仪就是反人类本性的角度看，哪一种得体不是“苦心经营”的呢）。</p><hr><p><strong>攻略组的玩家为什么要修炼他们的「装X」技能？</strong><br>对于大部分攻略组玩家，「装X」的目的是为了更有效地精进一项技能，提高自身的实力，即<strong>「装 X 直到牛 X 」</strong>- <a href="https://www.youtube.com/watch?v=Ks-_Mh1QhMc" target="_blank" rel="noopener">Fake it till you make it</a> 。比如为了展示身材，必须持续锻炼身体，于是最终获得了更好的运动协调性和耐力。如果没有「展示身材」这一个激励环节，锻炼协调性和耐力的过程将无比艰辛，痛苦万分；再比如职场上，除了做好分内的事之外，你还额外做了很多管理层才需要做的事，那么你被提升到管理层岗位就是<strong>自然而然</strong>的，因为你显然已经胜任这个岗位了。先做某个岗位的事情，把自己当成（装作）这个岗位的人，才容易被提升到相应的岗位。「拿多少钱就只做多少事」的态度会让人原地踏步。</p><p>类似这些“原理”有点类似「意识影响行动；行动影响感觉；意识无法直接影响感觉」的理论精华。</p><p>对极小部分的攻略组玩家来说，「装X」的另一层目的是为了将自己隐藏在茫茫的人海之中，并且释放出只有修行道路上的同类才能看懂的信号。过滤异类、吸引同类，有助于避免他们在修行过程中不必要的精力消耗。隐身的至高境界是用最激进的方式原形毕露。激进到无以复加、激进到形神俱灭……这便是神隐隐于「装X」。例如，到处强调自己是某个领域的第一，很可能的结果就是你希望过滤掉的观众都会觉得你水平不行（神隐玩家能同时做到给特定同类释放实力信号且不因此激怒大众）。在一些特殊的时刻，玩家甚至可以做到只有一个「观众」才看得出你真正想展示的东西。比如男生搭讪的一个良好效果就是要让搭讪目标<strong>之外</strong>的人都看不出来他在搭讪，毕竟这通常是只属于两个人的私密活动。</p><p>默默无闻的隐身没法和这个世界的高阶玩家交互，<strong>自我存在感</strong>很弱，难以高效地前进。世上只存在竞技场上与众玩家切磋出来的高手，不存在深山老林里独自修行出来的高手……当然，也许哲学领域除外。</p><p>有些玩家会提到「装X」带来的流量具有商业潜力等等，这是攻略之外话题了，不在攻略组玩家们的主线上。</p><hr><p><strong>如果完全不「装X」，玩家们会受到什么样的影响？</strong><br>玩家们将<strong>极难</strong>推进他们的修行，入门到放弃几乎会发生在一瞬之间。</p><p>「装X」另外一个不起眼却影响深远的作用是，重新审视自身的「尊严」和「荣耀」所带来的阻碍和动力。这会极大程度地提高精神上的韧性。不装的玩家将无缘此种在「绝望」和「觉醒」的临界时刻至关重要的<strong>精神韧性</strong>，以至于彼时被「尊严」、「荣耀」、「人物关系」等事物束缚。</p><hr><p><strong>为什么会这样？</strong><br>因为人是社会性动物，「和世界持续交互」体现和强化了<strong>自我的存在感</strong>，对修行效果有巨大增益。「观众」，或者说「见证者」，几乎是唯一能给与有效反馈的重要对象。其他方面实力相当的情况下，没有「观众」的玩家在修行效率上将<strong>落后多个数量级</strong>。</p><p>PS：<br>「<strong>存在感</strong>」是人类的一种<strong>本能</strong>，更是我们得以不断攻略前行的<strong>力量来源</strong>。<br>周末的下午百无聊赖，干什么都提不起劲，不知不觉就到了晚上，则玩家对这个周末的下午就是没有记忆的。生命中的一个下午就这样消失了，玩家并没有感觉到自己是一个鲜活的存在，没有实感。如此状态下，玩家们只会像蜜蜂一样靠着本能重复过去、日常，不会有改变、突破的欲望和动力。只有强烈地感受到自己的存在，我们才有欲望去和世界交互，进而精进和改善自己。<br>「装X」和释放情绪一样，可以<strong>强化</strong>自我的存在。「装X」经常也会伴随着情绪释放，属于更加主动积极的行为。<br>与其他玩家建立长期稳定的关系则可以<strong>延伸</strong>自我：除自己外，别人那还有其他的「我」。世上存在多个「我」。</p><hr><p><strong>攻略组的玩家是如何提高自己「装X」能力的？</strong><br>提升「装X」技能的常规方式自然是<strong>经常装</strong>、<strong>到处装</strong>。分析观众的反馈，之后反复打磨「装X」的细节。</p><p>也许 Peggy Klaus 的书 <a href="https://www.amazon.com/gp/product/B001J2UVA2/ref=dbs_a_def_rwt_hsch_vapi_taft_p1_i0" target="_blank" rel="noopener">Brag!: The Art of Tooting Your Own Horn without Blowing It</a> 中总结的原则能帮新手们快速入门：不要误导观众；得分场合；避免没完没了；切记撒谎欺骗等。</p><p>其次，效率最高的方式是模仿「装X」效果好的玩家。可多接触优秀的作品来熏陶自己。长期坚持一个对自律性有要求的技能（例如器乐、运动）也有巨大帮助，除了锻炼自律，还因为可以保持足够的严肃，避免情绪失控带来语言上的轻佻，尤其是在自己春风得意的时候。</p><p>再者，时间对于各类别出心裁的花招是极其<strong>残酷</strong>的（无论是语言上还是工具上），背后的<strong>思想</strong>才是关键。「装X」这项技能<strong>根本上</strong>的进化依赖自身的<strong>品味</strong>和思考的<strong>深度</strong>。在我这个时代，一个很能说明问题的例子是王国维的<a href="https://zh.wikipedia.org/wiki/王国维#人生三重境界" target="_blank" rel="noopener">学问三境界</a>：</p><blockquote><p>古今之成大事业、大学问者，必经过三种之境界。‘昨夜西风凋碧树，独上高楼，望尽天涯路’，此第一境也；‘衣带渐宽终不悔，为伊消得人憔悴’，此第二境也；‘众裡寻他千百度，蓦然回首，那人却在灯火阑珊处’，此第三境也。</p><footer><strong>王国维</strong></footer></blockquote><p>其实王国维想说的无外乎<strong>刚开始</strong>「孤独无措」，<strong>然后</strong>「勤学苦练」，<strong>最后</strong>「豁然开朗」。但他非要插入一句古诗词来代替，故弄玄虚。某些时候这样的花招也许能增加一些幽默感、画面感或者带有讽刺意味，不过这始终是个坏习惯。善弈者通盘<strong>无</strong>妙手。可以为了「<strong>精确</strong>」而啰嗦，要避免为了「<strong>装逼</strong>」而啰嗦。</p><blockquote><p>……你们觉得我的演讲技巧有问题，是吗？那又怎么样？哼…这个简直跟说吉米亨德里克斯弹吉他的指法不正确一样可笑。</p><footer><strong>约翰·罗梅罗</strong></footer></blockquote><p>最后，要保持<strong>自信</strong>。很多玩家其实没机会思考真正意义上的<strong>自信</strong>到底是什么，以为充其量只是<strong>接纳</strong>不完美的自己。真正的自信是：「<strong>既不（打算）影响别人，也不被别人所影响</strong>」。这样的「装X」才最有魅力。</p><p><code>PS：</code><br><code>可以认为杨一工连载系列（本连载）里所有的文字和表达都是装逼，且大多属于「假装不经意地显露优势」这一类带有强过滤、强信号的神隐型装逼 —— 即懂的人秒懂，享受找到同类的喜悦和伤感，不懂的则会无感地跳过此类装逼细节（比如</code><a href="/2018/12/24/yang-yi-gong-series-0/"><code>第 0 话</code></a><code>中的「远方」一词的引号，比如「...低层级（Low Level）困惑...」这样看似带有歧视的描述等等都属于这些细节）。之所以会这么写，是因为作者在应对人生必将失去的那部分自由的过程中，了解到了向世界示极致之弱的必要性（即怎么示弱都不过分）。</code></p><p><code>虽然这些「装X」细节是如此地转瞬即逝，若是不经提醒、不再重复阅读，它们很可能在你今后的世界里就永远消失了，但这并不特别影响玩家们对连载主要观点的理解。察觉神隐的存在只有两种方式，第一是成为同类的神隐玩家，第二就是与其建立长期关系。</code></p><hr><p><strong>什么场合下适合「装X」？</strong><br>其中的分寸感特别微妙。一个常见的规则是你希望给「观众」<strong>留下印象</strong>的时候适合「装X」，比如演讲。如果你想保持或提升「观众」<strong>对你的好感</strong>，就得谨慎「装X」，甚至完全避免，比如职场上的跨部门合作。</p><p>总的来说，分寸感要在大量实践中逐渐把握。场合不对将无法获得正确的反馈，也就无法达成玩家们各自的目标。</p><hr><p><strong>装 40 分钟的「X」合理的准备时间是一个星期？</strong><br>这个说法来自于我心目中排名第一的英语教师约翰·罗梅罗——也就是坊间戏称的「龙哥」或「爱新觉罗·罗」——的备课时间（哎，真是太XX装了）。根据他的经验，准备一堂质量过关的课程，备课时间<strong>不应少于</strong>课程时长的 100 倍。也就是 40 分钟的课程需要<strong>不少于</strong> 66 小时（七天时间）来准备是比较合理和稳妥的。哪怕是 15 分钟的一个汇报，也<strong>至少</strong>要一整天约 8 到 10 个小时。</p><p>这样的时间配比并非试图传递一个死板的<strong>教条</strong>，它的作用是提醒玩家们在「装X」的过程中要通过<strong>巨量的彩排</strong>来改善效果。尽管龙哥的实际行动确实就是字面意义上的 100 倍准备时间。</p><p>很多攻略组玩家在长期「以教为学」的修行方式下已经养成了即兴彩排的习惯，对他们来说，每一次表达和交流都不同程度地在为之后的「装X」进行彩排。</p><hr><p><strong>疲于日常的我们为什么会有一星期的准备时间？</strong><br>保持余裕的最好方式是<strong>养成习惯</strong>，或者说时刻准备着。已经养成彩排习惯的玩家无疑是幸运的。至于其他玩家，多<a href="https://evernote.com" target="_blank" rel="noopener">记笔记</a>是一个良好的习惯。平时多收集「装X」素材，尽早适应日常海量的信息处理。各种觉得有价值的东西都可以记录下来。此外，一份日程表也许有助于效率低下的玩家，很多 <a href="https://www.omnigroup.com/omnifocus/" target="_blank" rel="noopener">TODO</a> 类的软件都能快速实现这样的日程表。</p><p>还可以参考工业界中的「<strong>流程</strong>」。工业生产线上往往会制定相应的流程和规范，让人们的行为可以达到“<strong>无脑</strong>”的状态，进而<strong>提高</strong>产出，<strong>降低</strong>成本。比如一个零基础的玩家培训几周就能参与编程或者修图设计，都“<strong>得益于</strong>”制造干活机器的<strong>流程</strong>。跑出属于自己的训练「流程」，让训练彩排可以向日常刷牙一样<strong>纪律化，常态化</strong>。</p><p>顺便说一下，<strong>21 天的重复所能养成的习惯基本都是那种无脑的简单动作</strong>，比如刷牙。像做笔记这种比较烧脑而复杂的习惯，仅依靠简单的重复养成效果极差，需要专门训练自己的“主观能动性”。寻找你的「观众」甚至是「假想的观众」会让形成新习惯的过程容易很多。</p><p>有些玩家会选择堕入颇具争议的自恋之道，老实说，效果也是同样惊人。</p><hr><p><strong>整个学生时代，或者说所有修行的日子中被严重低估以至于多数玩家完全忽略了的重要修炼项目是什么？</strong><br>锻炼身体（注意！是<strong>搭配饮食</strong>的锻炼）。锻炼的重要程度和人们对它的熟悉程度一样（有多熟悉就有多重要）。高水准的「装X」极其消耗体力，经常需要在负重和高压力状态下行动。任何一个严肃对待「装X」乃至更加一般化的「修行」的玩家，都强烈建议以行动来感受耐力（高强度持续输出所能坚持的时长）和体力（总输出）带来的巨大复利。该复利主要体现在玩家们余裕的提升。</p><p>有实力的邪道玩家可以找个靠谱的健身教练来少走弯路。</p><hr><p><strong>你说的我都看懂了，可我心理上仍然对「装X」行为难为情，怎么办？</strong><br>尝试一下这碗鸡汤：人们不会记得你说过什么，也不会记得你做过什么，但是他们……</p><hr><p><strong>（打断）「但是他们永远都不会忘记我带给他们的感觉」吗？</strong><br>我想说的是，但是他们之中<strong>你喜欢、在乎的那些人</strong>，会不知不觉中持续受益于你竭尽全力「装X」所造就的<strong>改变</strong>。</p><hr><p><strong>你怎么知道神最烦装 X 犯？</strong><br>耶稣不是最烦法利赛人（Pharisees）吗？</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨一工连载第 1 话：第一之为责任</title>
      <link href="/2019/02/04/yang-yi-gong-series-1/"/>
      <url>/2019/02/04/yang-yi-gong-series-1/</url>
      
        <content type="html"><![CDATA[<p><strong>好吧，你先来和我们说说什么是「牛X」？毕竟它是个抽象的概念。</strong><br>「牛X」就是第一名。</p><hr><p><strong>第二名、第三名不算「牛X」吗？要我说，位于第一百名的玩家也很厉害喔~</strong><br>「也很厉害」其实就是「不厉害」的意思。第一名的优势通常比其他所有名次加在一起还大。部分攻略组玩家会激进地认为<strong>第一名之后都是落后</strong>，并且抱着必死的觉悟（这样的描述也许仍然低估了攻略组的觉悟，他们之中很多人都曾无数次有过自杀的念头，可终究还是咬牙强笑坚持了下来），为第一之名赌上一切。</p><p>越是逼近过各式各样的第一，就越能领会这种「<strong>激进</strong>」。</p><hr><p><strong>「第一」的感觉是怎样的？</strong><br>无尽的恐惧。</p><p>具体来说，第一名们在严肃反思起自己过去的修行时，总会不自觉地感谢幸运之神的眷顾。有些时候，看似平淡或不经意的一个选择，实际上<strong>凶险万分</strong>，攸关生死（林柳老师^_^）。彼时的淡定和无奈，仅仅因为自己的<strong>无知</strong>（还好选对了）；在另一些时候，看似<strong>反人性</strong>且具有极大风险的行动，在当时的危急局势下却包含着至关重要的<strong>胜负转折</strong>，远胜于其他安全稳妥的选项。考虑到选择了冒险的玩家不出意外还将面对前所未有的<strong>多方压力</strong>，能顺利坚持下来实在是太幸运了。</p><p>由于不知道幸运之神是否还会再次降临，玩家们只能分秒必争，不断提升生命的密度来增加胜率。不敢仅靠自己当前已有的优势就对未来心存侥幸。</p><p><code>公元 2013 年 4 月 8 日北京时间凌晨 1 点，北半球某校园里的一个男生经过短暂的犹豫后决定辍学。当时的他并没有完全想清楚该行为的利与弊（如果有利的话），甚至对未来也有着比过去更加绝望的迷茫。可是，他却对自己的决定感到莫名地兴奋和轻松，而这，仅仅只是因为他的直觉在过去半年里不断地告诉他：不应该再以这样的方式继续修行......</code></p><p><code>......19 天后，公元 2013 年 4 月 27 日下午太平洋东部某小岛上，命运的事件发生了。历史的车轮开始缓缓转向，人们原本的生命轨迹也因此悄然剧变。多年以后，另一个时代的主角们在回顾这个平淡瞬间时，都不禁感到后怕。但此时，事件中心的人物们对即将发生的一切还全然不知。</code></p><hr><p><strong>为什么你说「第一」是一种幻想？</strong><br>因为运气成分很大，大到让新人们近乎绝望的程度。例如，一个常见的运气是玩家所出生和成长的家庭（战斗在战斗还没开始的时候，就已经开始了）。玩家们越是追求第一，越能真切地感受到各种运气带来的<strong>无奈</strong>。</p><p>不知道算不算<strong>命运的补偿</strong>，「<strong>无知</strong>」和「<strong>谎言</strong>」间接保护了绝大部分新人（不能简单地认为前辈们对新人故意撒谎。大多情况下，这些谎言，或者说错误的信息，是多种因果交织在一起导致的）。如果一开始就知道这么难，多数玩家会知难而退。正所谓千里之行始于足下，只有不知道难，每次只难一点点，辅以美好的幻觉，才不至于让行动的热情和勇气被击垮，才能<strong>持续行动</strong>，最终得以顺利抵达<strong>几乎不可能</strong>的彼岸。第一名的潜在候选们也是在这样的“保护”下成长的。直到完成各自的觉醒后，他们才得以独立，逐渐摆脱这种“保护”。等走到足够远后回头再看，之前所绝望的壁障已经不是无法跨越的了。当然，前方还有更大的绝望在等着，不过这时候玩家们的自负、侥幸、还有技能熟练度，已经<strong>足以</strong>支持他们继续前行。</p><hr><p><strong>攻略组玩家们追求第一名的理由是什么？</strong><br>应对世界的残酷和<strong>可能性</strong>。</p><p>修行中所建立的各种珍贵回忆和<strong>通感</strong>有助于我们从事新的实践。比如有些玩家一到冬天，或者闻到北京雪的气味，就能唤起学生时代冬季备考的励志和突破过程。这种珍贵的感觉支撑着他们度过了一个又一个寒冷绝望的夜晚。</p><p>世界的残酷和可能性都<strong>远超</strong>玩家们的想象，危机意识是绝望的唯一<strong>克星</strong>。以「第一」为目标是保持危机感的<strong>必要条件</strong>，故而它是所有攻略组玩家的<strong>基本责任</strong>。「第一」之外的妥协只会让玩家对自身实力和周边环境心存可悲的<strong>侥幸</strong>。</p><hr><p><strong>可以说得再通俗点吗？为什么就这么执着于第一？</strong><br>王富贵：“为了能永远自由自在，快快乐乐地生活在一起。”</p><hr><p><strong>玩家们现在不算是自由自在，快快乐乐地生活在一起吗？</strong><br>王富贵：“我说的呀，是「<strong>永远</strong>」。”</p><hr><p><strong>要追求第一，而第一又是幻想，那追求这个幻想是否不切实际？</strong><br>是的。然而问题不在于我们的<strong>命运</strong>，而在于我们自己。过程的意义远大于目标本身。无论结果如何，追求第一的过程都会让玩家自身受益无穷。</p><hr><p><strong>怎么样才算是第一名？</strong><br>游刃有余。在所有对决中都能保有「<strong>余裕</strong>」。</p><p>多数时候，合适的对手会像一面镜子一样让我们能更好地确认自身的余裕，同时塑造自己内心中第一名的形象。当然，判断出谁属于“合适的对手”也是一个相当考验实力的课题就是了：「彼は我、我は彼……なれど汝は我等に非ず……」</p><hr><p><strong>你之前提到的让修行速度大幅提升的王道是什么？</strong><br>首先是了解人类认知过程的基本原理。比如知道大脑在认知学习的过程中<strong>喜欢节能</strong>，这使得已存在的既有认知会排斥新认知，以避免启动逻辑思考，消耗更多能量。了解这个原理后，我们很容易知道，新知识的掌握过程需要依靠<strong>刻意练习</strong>（极致的刻意练习是实现<strong>肌肉记忆</strong>。强制练习到<strong>不假思索</strong>的地步：数理化就默写公式，编程就默写代码，写作就默写范文，先不思考，练成之后再问「为什么」），并且知道要将这些刻意练习安排在一天中的能量峰值时段（一般是下午）。比方说很多玩家在学习外语的时候会感觉很难，这是因为母语占据了主导地位，大脑使用起来能量耗费更低（旧有的肌肉记忆），于是它倾向于排斥要进行翻译动作的<strong>高能耗</strong>陌生语言，并不是因为玩家们已经过了语言学习的最佳年龄（长期作为谬误的语言学习关键期假说）。此时要做的刻意练习应该是为了建立新的“肌肉记忆”。再比如，<strong>多人组团学习</strong>比单打独斗的效率高。在学校和同学们一起学习比在家里一个人自习的效果好（顺便说一下，多数学校很少进一步在班上采取分小组学习和竞争的方式是因为这对教师的要求极高，就算是顶尖学校也很难请得到这些老师）；又比如，<strong>以教为学</strong>会让学习效率更上一层楼，尤其是成为“老师”后还逐渐能做到对“学生”进行「苏格拉底式的提问」这样的地步——掌握引导他人觉醒的实力有极大的战略意义；还比如，训练自己的<strong>恐惧和情绪</strong>成为<strong>敏感而精准的导航仪</strong>。主动利用它们，可以高效理清前进的方向（比起思考如何获得第一名，不如想想如果做了哪些事情就无法达成第一，然后努力的方向就是避开这些事情）；总之，对大脑认知特性的了解能提升具体技能的习得效率。</p><p>其次是了解世界运行的机制。比如人类的政治金融是怎样运作的；比如人类商业社会如何演进；再比如人类的工业系统如何协同；了解这些可以更好地把握技能树的方向，或者说修行的战略。因为不同的「第一名」之间战略意义是不一样的，比如下围棋的第一名，程序语言设计领域的第一名，还有对冲基金的第一名，这三者并不是同级别的「第一」。通俗来说，职业和技能有高低贵贱之分。</p><p>拥有智慧之后是<strong>保持纪律</strong>，不让各种情绪波动<strong>过于</strong>左右你修行中的决策。影响玩家情绪的因素是玩家们对眼前状况和各种行为的认知，这归根结底是一个<strong>观念问题</strong>。比如有些新手玩家被老师冤枉之后很恼火，从此不再好好学习。这样的观念如不进化，未来将不能面对攻略之道上更加艰难的关卡。当然，也要认识到人类的情绪有着无比强大的用法和潜力（例如用来探测自身的弱点所在，还有强化自身存在感等等），不能简单地排斥它，要学会和它共处，掌握释放情绪的技巧。</p><p>仅做好以上三个方面，就能难以置信地大幅提升修行的效率。但需要注意，上述方法论里所描绘的行动策略，终究远不如<strong>自身的行动</strong>本身来得重要（纪律）。类似地，更多的技能，也比不上自身的情绪管理重要。被情绪控制的自我，不是真实的自我。在这种状态下，欲望也不是真实的。</p><hr><p><strong>谁是领先玩家？什么是让修行速度进一步爆炸性提升的邪道？为什么只有领先玩家才有机会走邪道？</strong><br>领先玩家就是经济和人力资源实力雄厚的玩家（如继承了前辈们资源的玩家。他们的前辈比其他人的前辈有更多的修行成果）。使用<strong>大量资金</strong>，不计成本地在每一个环节都最大限度地节省时间和体力的方式是爆炸性提升修行速度的<strong>邪道</strong>。比如学习某门功课时，直接雇佣该课程领域中最顶级的老师和学生（对谁才是「顶级」的判断，来自于玩家的人力资源实力，可从前辈那继承）。这意味着除了高额的学费之外，很可能还得搬到该老师所在的城市，并且要靠近商业中心以便 24 小时食物供应。此外，还要找到和自己一样对第一名有执念且实力相当的同学组团以达到最好的效果等等。能花钱搞定的修行环节，绝对不浪费任何时间，这是普通玩家做不到的。</p><hr><p><strong>极限修行速度下的玩家们所面临的隐患是什么？</strong><br>战略错误。</p><p>修行方向一旦出现失误，修行速度越快越悲剧，<strong>突破某个临界点之后，不论多么努力，哪怕是彻底的自我否定，也几乎不可能重新回到攻略的主线，只能沦为不时阻碍和恶心攻略组的「NPC 玩家」</strong>。比如在职业教育和高等教育之间的取舍，或是在社会传送带（当前的学校旨在把我们训练成工业系统里的螺丝钉，整个教育系统相当于传送带：小学、中学、大学、研究生、博士……）和创业之间的取舍，就很容易出现这种一失足成千古恨的情况。另一个更加常见的情况是上文提到的<strong>刻意练习</strong>。刻意练习能让我们以极快的速度在所修行的领域里推进，不过如果你刻意练习的技能或领域在战略上是悲剧的，后果可不是浪费时间这么简单。</p><p><strong>战略错误</strong>是当前时代隐形的残酷之一，也是让所有追求第一名的玩家都极度恐惧的事情。这就是为什么有些玩家并不急于以极限速度向第一冲刺。耐心看清楚局势再加速修行也不迟（例如玩家蒋施主中学时代就用力<strong>过猛</strong>，形成的写作习惯根深蒂固，导致进入工业界后还在以高中议论文作文的水平写东西）。当然，更多的玩家是由于无知和懒惰，没在一开始就满速修行，从而不知不觉避免了危机。</p><p>执着于第一的玩家为了能在<strong>第一时间</strong>承认和纠正自己战略错误，会<strong>义无反顾</strong>地舍弃金钱，地位，尊严，荣耀，甚至是多年的修行积累。十年一剑，当弃则弃。</p><p>在哪个城市长期居住是一个战略，练习魔兽争霸（20世纪初的一款竞技游戏）的对战技术也是一个战略。玩家们为了各自的战略，甘愿付出数年，乃至十数年的心血。或背负贷款，或日夜煎熬。然而到了<strong>是非成败转头空</strong>的那一刻，是否能果断放弃以止损呢？贷款没还完的房说卖就卖？游戏圈的伙伴和荣耀当弃就能弃吗？作为个人的你能从容放弃，守护他人的你又如何面对责任和期待呢？</p><p>惯性付出的玩家们继续惯性前行。然后青山依旧，然后几度夕阳，然后渔樵江渚，然后尽付笑谈……个中残酷，当局者清而不能自拔。</p><blockquote><p>We are the victims of our own success.</p><footer><strong>Ross Douthat</strong></footer></blockquote><p>玩家们被自己的成功<strong>束缚</strong>着，难以踏出进入新世界的那一步。这正是「<strong>深度优先</strong>」策略的隐患：由于太成功，因此过于依赖自己的优势，于是在安全感的作用下难以离开自己的专业去尝试学习新技能。</p><p>了解世界运行的机制可以极大程度避免战略错误的发生，再就是遇到好老师触发<strong>觉醒</strong>。不过归根结底，在「路线正确」，或者说「路线虽不对，但后果在可承受范围内」这件事上，<strong>运气</strong>还是关键。所以，要通过提高我们经历的<strong>丰富程度</strong>，来提高我们的<strong>胜率</strong>。这就是「<strong>广度优先</strong>」策略的理念。</p><blockquote><p>天赋使你有学习的欲望，运气则让你有学习的资本。但天赋某种意义上也是运气。</p><footer><strong>杨一工</strong></footer></blockquote><p>持续行动方能拨云见日。无论前方再怎么“风烟雾雨青山暮，不辨茫茫来去路”，务实的行动始终是<strong>最大限度</strong>打开局面的最佳方式。<strong>谨慎试错，但不要害怕试错</strong>。</p><hr><p><strong>你多次提到的「觉醒」是个什么样的经历或状态？</strong><br>「<strong>初阶</strong>觉醒」说的是玩家有能力明确<strong>自己想要</strong>什么，对当下行动的<strong>最终目的</strong>有着清醒认识。这里的「最终」可以是未来 5 年这样的短期目标，也可以是一生的终极目标。</p><p>「明确目标」不仅仅只是知道而已，要经得起残酷的现实对该目标的检验（比如你准备买房，会面临「为什么不租房」，「为什么不投资变现代价更低的股票或基金」等等问题。多问自己：“<strong>然后呢</strong>？”）。玩家们要在各种<strong>不断进化</strong>的需求和<strong>伪</strong>需求之间挣扎探索，直到能毫不犹豫且逻辑清晰地<strong>舍弃</strong>主线以外的支线。无论诱惑有多大，阻力（有时是亲朋好友的关心和爱）有多大。</p><p>普通玩家和觉醒者之间的差距主要体现在「<strong>判断</strong>」，而不是「<strong>执行</strong>」上。举例来说，做题、考试、持续训练，进而掌握一项技能。这样的事多数人都会做（尽管执行力也是一道门槛）。但是当 100 种甚至更多的技能和策略摆在面前，到底要选择哪种，却极少有人能判断。另一些时候，觉醒玩家还会创造出市面上没有的第 101 种技能和策略来实现自己的需求。具备这样级别的判断力，才算实现「<strong>初阶</strong>觉醒」。初级玩家甚至不知道市面上 100 种技能的存在。</p><p>「<strong>进阶</strong>觉醒」指的是知道<strong>别人想要</strong>什么。这不仅要求强大的「<strong>同理心</strong>」，还要求玩家有足够的「<strong>生活阅历</strong>」，必要时甚至要<strong>引导</strong>对方的思路，因为他人有时候自己也不知道想要啥。没有生活阅历<strong>支撑</strong>的共情是脆弱而且危险的，就像是出于“人道主义”和“正义”来无脑<strong>反对战争</strong>一样。「进阶觉醒」的具体表现是玩家知道如何拆分任务、处理冲突，步步为营地实现一个完整的项目作业。脱离嘴炮、耐心克制，灵活应对残酷的<strong>基层</strong>和痛苦的<strong>实践</strong>。前文提到的「<strong>在所有对决中都能保持余裕</strong>」说的就是这个。</p><p>这意味着玩家们赖以前行的思考方式（有时也被称为思维模型，方法论，或者观念）发生了翻天覆地的更新（是 upgrade 而不仅仅是 update），尤其是针对目标的观念发生变化。玩家们的情商——也就是<strong>识别</strong>情绪的能力（无论是识别自己还是识别他人），以及掌控情绪的能力（无论是掌控自己还是掌控环境的情绪），极度依赖进阶觉醒。情绪，是位于顶点的攻略组玩家都会感到棘手的东西。幸运的玩家无论身处怎样的险境，都能顺利地用行动响应自身和他人的情绪，让情绪更好地<strong>辅助</strong>自己前行。</p><p>想起某聚会上大家说起<a href="https://www.wikipedia.org" target="_blank" rel="noopener">维基百科</a>募捐的事，有人嘲笑在场的捐款者：“傻X，你们知不知道维基百科的基金会其实特有钱？他们比你们富多了！”……没觉醒的玩家们很难对此进行体面的回应，也不好控制这一刻自身情绪的波动和下一刻自身的行为。</p><p>类似的案例还有情侣逛街遇到女方的前任迎面一句「我玩剩下的垃圾你还要？」该如何回复等等……</p><p>总的来说，玩家们在修行过程中会逐渐总结出属于自己的各种思维模型，这些模型深深地影响着他们的决策树，进而<strong>左右命运</strong>。还有就是，不同思维模型的重要级别是不一样的。我们越是赖以生存或前行的思维模型，重要级别越高，越能迎来「觉醒」。觉醒之后，玩家的行为模式会发生巨变。</p><p>发生觉醒的关键是要<strong>遭遇契机</strong>（比如某本书，某个老师，或某个事件），并且在契机来临之前完成<strong>足够的积累</strong>（量变是质变的前提）。两者缺一不可，尽管契机是<strong>更重要</strong>的一个因素。另一个现实是，最优秀的教师门下也只有小部分学生能实现觉醒。因为学生之间的<strong>积累有差异</strong>。这种差异不仅仅是<strong>量</strong>上的，而且是<strong>质</strong>上的（学生甲乙两人掌握的知识技能一样，然而面对同一契机最终只有甲实现了觉醒，这是因为甲心中<strong>积累的疑问</strong>和乙不一样，甲和乙所追求的<strong>精进方向</strong>不一样，两人「<strong>心目中的第一名</strong>」不一样）。比如在基因层面防止哺乳动物近亲结合的「青梅竹马保护」和「公司财务报表的五项关键指标」这两个思维模型就能使小部分玩家迎来觉醒，但对绝大多数人没啥用。</p><p>觉醒之后的玩家们，攻略实力的精进速度会达到一生中的巅峰状态。</p><hr><p><strong>「新手」，「专家」和「神」这三个不同的修行境界分别是怎样的？</strong><br>对某项具体技能来说，比如使用 Java 语言编程，零基础的玩家被归为「新手」，技艺精湛的玩家就是「神」，介于两者<strong>中间</strong>的就是「专家」。作为一个参考，在人类工业体系里完成日常工作的玩家基本上都介于「新手」和「专家」之间。该中间态境界有时也被称为「高级新手」。在这个意义上，玩家们无须成为专家，就能胜任大部分工作（拜工业化社会里标准化风气的盛行所赐，大部分领域里，零基础的玩家经过短期标准化培训就能上岗）。你可以认为这是人类工业化时代<strong>可悲</strong>的地方，也可以认为是其<strong>伟大</strong>的地方。</p><p>很多领域都能观察到「高级新手」，比如英语老师，比如设计师，比如程序员（工程师？）。</p><hr><p><strong>日常玩家也只是「高级新手」？那「神」的领域简直难以想象。「神」有弱点吗？超越「神」的第四隐藏境界如果存在，是什么呢？</strong></p><p>玩家们将在这个问题上遭遇攻略生涯中<strong>最重要、影响也最深远</strong>的一次思考：是「<strong>深度优先</strong>」，还是「<strong>广度优先</strong>」？是「<strong>维护稳定</strong>」还是「<strong>持续冒险</strong>」？</p><p>如果不考虑身体健康的因素，「神」的弱点就是强大实力所形成的<strong>习惯</strong>，或者说<strong>依赖性</strong>。人若是精通了某种“技能”，使用它的过程中会产生愉悦感、安全感，以至于逐渐依赖它，迷恋它，向它臣服，对它不假思索，对它不可自拔。</p><p>「习惯」会自动过滤掉所有被认为“无用”的信息和选项以提高玩家行动效率。就像人的大脑会让环境音变成背景音，以让我们维持注意力一样。由于最精要的思考方式和经验已经完全融入自身的血液，<strong>在没有外界干扰的情况下</strong>，神级玩家可以完全依赖自己的习惯（直觉和肌肉记忆）。你很难忍住不依赖它，你甚至<strong>意识不到</strong>你在依赖它。</p><p>专精一项技能，达到神级水平，就是隐患重重的「<strong>深度优先</strong>」策略。该策略下，玩家们的<strong>技能树</strong>缺少多样性，进而<strong>缺少韧性</strong>，异常脆弱。比如神级足球运动员只会踢足球；神级特级教师只会教语文知识，还是关于如何考高分的这类语文知识……一旦环境变化，神级玩家将难以应对（想想当离开俱乐部和学校后，他们何去何从？考公务员？）。</p><p>即便环境稳定，神级玩家也会因为太过专一，而没法突破自己实力的天花板，让自己变得更好。</p><p>（突然想起相机公司的胶片技术世界顶尖、利润丰厚，以至于完全没有动力探索成像仍然糟糕的数码技术线路）</p><blockquote><p>如果你“精通乐理”，你会对当世的乐理知识侃侃而谈。不会、也不能容忍对此理论体系本身产生质疑。</p><footer><strong>Ian</strong></footer></blockquote><p>突破「神」的境界会重新成为「新手」，所以可以认为<strong>「新手」就是第四隐藏境界</strong>。这是一个跳过「神」、在其之后的境界。它所实践的是广受鄙视但充满活力的「<strong>广度优先</strong>」策略。</p><p>「广度优先」要求掌握<strong>多</strong>领域的知识和技能，但它并非<strong>纯粹</strong>追求数量，而是要通过「数量」来确保尽快掌握那些可以作为<strong>基石</strong>的战略级领域。广度优先的另一意义在于开拓玩家新的<strong>知觉</strong>和视角。这会潜移默化地提升玩家的判断能力（见闻色？），进而促发觉醒。</p><p>具备战略意义的技能部分取决于<strong>时代和周遭环境</strong>，部分取决于玩家要实现的<strong>攻略</strong>，所以需通过不断实践来建立这方面的认知。比如，通常被认为是战略级技能的金融和财务知识，在我这完全比不上<strong>搭讪技能</strong>那么重要。不过这是属于我的实践结论，有其<strong>时空坐标</strong>，不一定适用其他玩家。</p><p>简言之，攻略组们要增加实践的广度，来提高遭遇战略级技能的<strong>概率</strong>：「提高生命<strong>密度</strong>，进而提升<strong>胜率</strong>」。</p><p>横看成岭侧成峰，除了技能树需要韧性外，玩家的进一步成长也需要多领域、多元化的<strong>不同视角</strong>，以做到足够地<strong>开放</strong>、<strong>敬畏</strong>和<strong>自律</strong>。因为在「广度优先」的实践中，焦虑和欲望会丰富到混沌的程度，并逐渐开始<strong>产生激烈的冲突</strong>。欲望与欲望间的对抗让玩家们<strong>被迫</strong>严肃考虑其中的取舍。而无数的焦虑，则让玩家们<strong>被迫</strong>适应危机。在这数不清的「被迫」里，玩家们才得以了解自己、接纳自己，<strong>找到</strong>各自的羁绊之地。</p><p>位于攻略组顶端的玩家，心中都容纳着两套以上<strong>截然相反</strong>的认知体系而仍能——或者说<strong>才能</strong>（因为相互制约）——行事自如。</p><blockquote><p>白洁的主卧工字墙、姜美晨的餐桌互动朝向、王洁燕的厨房采光、李冰的缩小主卫和我的异形落地镜……靠着这些多元视角，最终在实用性的镣铐下成功地维护住了全屋良好的空间状态。</p><footer><strong>2022年03月23日</strong></footer></blockquote><p>得益于 20 世纪初中国这个持续工业化的和平时代，「广度优先」的难度大大降低了。玩家们不必样样精通，只需要达到前文提到的「新手」或「<strong>高级新手</strong>」的水平即可。当然，这仍然要比「深度优先」<strong>难得多</strong>。比如困难之一就是提供「广度优先」所需要的<strong>体力</strong>。困难之二比较隐性，就是有效学习一项战略级事物的时候会进入某种专注状态，这种状态下，你会<strong>全面笼罩</strong>在当前知识树下，<strong>不允许</strong>被其他知识打断，俗称 <a href="https://www.ldoceonline.com/dictionary/in-the-zone" target="_blank" rel="noopener">in the zone</a> 。比如练习一首钢琴曲的时候，由于非常专注，一天时间很快会过去，然后又是一天，然后一个月，然后半年……这种状态下，如果半中间去再研究个计算机程序语言设计，那钢琴的状态就会被打断，之前的练习有可能白费。「<strong>广度优先</strong>」由于涉及领域很多，需要维护的这样的状态也就会很多，十分考验玩家<strong>应对信息流的余裕</strong>。</p><p>无论我们精通了何种技能，都应该对此保持冷静和警惕，就像演奏乐曲的时候不应该被乐曲的情绪影响一样。冰冷之境才是避免节奏失控之道。</p><blockquote><p>At your highest moment, be careful. That’s when the devil comes for you.</p><footer><strong>Denzel Washington</strong></footer></blockquote><p>「工具切换」是重新成为新手的经典场景：从汽油车双踏板切换成电动车单踏板逻辑的司机（也许从骑马切换成汽车的质变更加有说服力），从 Windows 切换到 MacOS 的个人电脑用户，从中文世界切换到英文世界（甚至再切回中文：中文和中文其实也是两个世界）的玩家……这些案例都包含着新习惯与旧习惯、新领域和旧领域之间的冲突。</p><p>另外要重点说明的是，<strong>学习新知识是一项高风险的冒险行为</strong>。要有「投入大量资源却毫无收获」的觉悟。多数情况下进入新领域的尝试是浪费时间甚至是危险的，神所依赖的习惯<strong>在其活动范围内</strong>也几乎是正确的（毕竟是经过千锤百炼重重考验才建立起的习惯）。继续待在自己的舒适区是理智的选择。可是，攻略组们需要做出<strong>取舍</strong>决策的时刻<strong>必定</strong>会在一切准备妥当之前到来：是继续做“正确”的事？还是做些“不一样”的事？为了追求更好的认知、更自由地取舍前行，攻略组们即使心怀恐惧、遍体鳞伤，也会无数次投入资源（时间金钱）跨入新的领域。</p><p>「神之后的新手」有着比「神」更具穿透力的<strong>敏锐</strong>，同时还拥有「新手」的<strong>好奇心</strong>和可塑性。他们甚至能在「神」和「新手」这两种思考模式间<strong>自由而精准地切换</strong>。</p><p>举个例子，比如「矩阵是什么」这个问题。是的，玩家们都知道矩阵是一组列或行向量组成的展开式子，但（模式切换）为什么偏偏是二维展开？为什么不能是三维？四维？为什么矩阵的乘法规则要如此规定？这种能实现各种神奇运算并得到正确结果的诡异乘法（模式切换）仅仅是凑巧？还是被其背后某种本质所必然决定？那么这个本质是什么呢？矩阵的「相似」又是什么意思？哦？你说人们定义 <script type="math/tex">P^{-1}AP</script> 矩阵与 <script type="math/tex">A</script> 矩阵相似？（模式切换）为何要这样定义？该定义也许是「神」能接受的解释，但这不是「神之新手」们所满意的答案。</p><p>为什么要这样定义？背后的本质所描述的规律是什么？更具体地说，那些作为人类而不是公式性质的<strong>解释</strong>，那些小白也能瞬间领会的、在物理世界中的<strong>类比和映射</strong>才是「神之新手」所追寻的东西。</p><p>面对这些看似简单的问题，很多神级玩家，最后也只能用「就是这么规定的，记住就好」这样的话语来<strong>敷衍</strong>（「能量守恒定律为什么是“对”的？」「市场有效假说为什么是“正确”的？」等问题常常能诱导出这类<strong>敷衍</strong>）。可是，只有回答了这些问题，我们才能产生真正的「理解」，获得这一学问的关键性<strong>知觉</strong>。</p><p>如果有缘跟着「神之新手」级别的玩家一起修行，至少可以少走 20 年的弯路。这不仅因为<strong>第四境界</strong>的玩家本身很强，让我们的镜像神经元不断发挥作用，还因为他们会进一步作为节点，将我们与更加优秀的的资源连接起来——比如更优秀的人，更先进的装备和观念——获得获得难以想象的指数级成长。强烈建议带着宗教乃至邪教的信仰<strong>紧跟</strong>这些神之新手（没有信仰谈不上紧跟）。</p><hr><p><strong>咳咳……你说了那么多，我作为一个中学生还是各种看不懂，也懒得看。过几个月马上高考了，你直接说一个靠谱的攻略吧。</strong><br>大学尽量选北上广，地理位置离钱（资本 + 人力资源）越近越优先，专业次之。可以的话，避开文科类专业。</p><hr><p><strong>呵呵，感觉不靠谱。</strong><br>哦？你是毛老师吧？</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨一工连载第 0 话：连载前的一些话</title>
      <link href="/2018/12/24/yang-yi-gong-series-0/"/>
      <url>/2018/12/24/yang-yi-gong-series-0/</url>
      
        <content type="html"><![CDATA[<p>对于处在学生时代的修炼者们来说，眼前伴随着青春期的这次蜕变是一次有多倍数经验奖励的修行机会，少数有缘的玩家更是会在此次蜕变中完成「觉醒」的过程。错过的话，人生下一次同样级别的蜕变，要等到个人的创业时期了。</p><p>现实中并不是每一只井里的青蛙都打算跟随主流的蛙群奋力起跳，它们可能只希望忠于自己，推崇淡泊宁静，或者对井口之外不过是更大的一口井之类知无涯生有涯的低层级（Low Level）困惑耿耿于怀。虽然想明白非主流青蛙的这些哲学困惑对于战斗在最前线的攻略组玩家们来说是第二阶觉醒的必要条件之一，也是很重要的一环，然而在第一阶觉醒之前，搁置它们在效率上才是明智的选择。本连载即将分享的方法论是<strong>专门针对攻略组玩家的</strong>，也就是那些<strong>不满足于仅仅只是奋力起跳</strong>的青蛙们。希望能让身处蜕变时期的他们以更高的概率迎来属于各自的觉醒契机。</p><h3 id="遵循「能量守恒定律」的勇气"><a href="#遵循「能量守恒定律」的勇气" class="headerlink" title="遵循「能量守恒定律」的勇气"></a>遵循「能量守恒定律」的勇气</h3><hr><p>在修行的多数时候，要学的东西看似很多，实际上通常只要掌握基本的几项原理就可以了，其他的技能都能通过这些基本原理迅速学会。所有这些原理中最重要的，或者说最重要的之一，就是「<strong>行动才能打破现状</strong>」。</p><p>比起探索最佳的英语学习方法，先死记硬背再说；比起思考线性代数到底有什么用，先学一波再想；荒野之息里未知的庞然大物，先上去挑战一下再说……无论内心是否坚定，当玩家们踏出了第一步，远山近水便为之分明，亭台楼阁也会为之浮现。</p><blockquote><p>胆怯的智慧还在犹豫的时候，勇敢的无知已经开始行动了。</p><footer><strong>索尔·贝娄</strong></footer></blockquote><p>上面的引用文字也许不像网上所传那样出自诺贝尔文学奖得主索尔·贝娄（Saul Bellow）的作品（将来找机会问一下李海鹏），可无论如何它说得很精彩，每个人都能看到自己想看到的境界。对一部分特别忙碌的玩家来说，这句话表达了一种行动至上的务实态度。在这些人眼中，世界上大多数原理是靠<a href="https://www.bilibili.com/video/BV1SQ4y1q7Rs" target="_blank" rel="noopener"><strong>信仰</strong></a>证明的，包括人们熟知的「能量守恒定律」。</p><p>要理解玩家们的这种<strong>务实</strong>，我们需要知道「演绎（deduction）」和「归纳（induction）」这两个重要概念。类似「金属能导电；铜是金属；所以铜能导电」这样的，只要前两个条件成立，结论必定<strong>无懈可击</strong>地成立的推理过程就是演绎。而「能量守恒定律」这样的<strong>经验式</strong>推理则是典型的归纳：因为过去的实践都没有违背能量守恒定律，所以它未来也会一如既往地成立。显然，「归纳」是玩家们在难以实现「演绎」后的某种“妥协”。在数学领域的证明题中使用「归纳」将是〇分，与此相对，物理化学老师们对归纳推理通常没有一丝的心虚。</p><p>尽管信仰和信仰是不一样的，熟练区分「归纳」和「演绎」的玩家们还是会很快意识到，相信能量守恒定律和相信神创论没有什么本质的区别。坦然面对这个真相是不容易的，它暗示了演绎的<strong>绝对正确性</strong>难以实现。现实世界的大多数情况下，玩家们要解决的问题<strong>只能依赖归纳推理</strong>，这迫使其中的一些玩家最终在「正确的安全感」和「确实的行动」之间不得不“勇敢”地选择后者，将更多的时间和精力用来依照这些原理做事，而不是探究它们的对错——这是个需要做好相应觉悟的选择。</p><blockquote><p>Never let yourself be diverted either by what you wish to believe, or by what you think would have beneficent social effects if it were believed, but look only and solely at what the facts are.</p><footer><strong>Bertrand Russell</strong></footer></blockquote><h3 id="选择什么，不选择什么"><a href="#选择什么，不选择什么" class="headerlink" title="选择什么，不选择什么"></a>选择什么，不选择什么</h3><hr><p>行动，意味着我们要有所取舍。在现实的修行中，虽然「概率」这个概念也难逃「归纳」的范畴，部分理智的玩家们仍然开始使用它作为前行的原则——做“大概率”正确的事。把「概率」作为目前人类所能做到的极限，且承认这个极限在可预见的将来不会发生改变，是攻略组玩家们不断修炼自己<strong>思维模型</strong>的重要原因：<strong>思维模型</strong>造成了对「大概率正确」的认知差异。</p><p>选择什么，不选择什么，会使玩家之间会随着时间呈现出天上人间的差距，此差距很难依靠单纯的修行来缩小。比如 2008 年选择买房的玩家比努力工作的玩家在之后的十年间获得的资源更多。这是因为房子在这十年里将积累的是一个城市、一个省、一个国家、乃至一个时代所有玩家的努力，个人努力自然无法相提并论。你大可以认为两种选择背后的代价和觉悟所带来的取舍难度让决策双方不像表面看上去的那样高下立判，但就结果来说，选择比努力的效率要高一点点，这基本上已经是玩家们的共识。</p><blockquote><p>确实，你们付出的努力并不会对当下的你有什么实质性的帮助。所以看到别人做出成功选择我们很容易忽视努力的真谛。因为真正的改变，会出现在下一个回合的选择中。你会解锁比别人更多的选择。这，才是努力的意义。</p><footer><strong>Mr厉害</strong></footer></blockquote><p>「<strong>做选择的能力</strong>」贯穿攻略的全程，早点了解取舍的重要性和基本原则可以少走大量弯路。不过在我们启程之前，还有三点想说明一下：</p><ul><li><p>「<strong>实践</strong>」后产生的认知才是真正的认知。他人的经验和攻略作为一种「归纳」，当转化为视频和文字之类的「副本」，无论多么精美，所传递的信息量几乎都会不可避免地大幅度<strong>缩水</strong>。「非实时」只是部分原因，<strong>更关键</strong>的地方在于，如果没有训练和实践的积累，你很难通过单纯的思考或者他人的叙述<strong>清楚认知</strong>该「归纳」背后所隐含的代价是什么。这里的代价包含了其他玩家<strong>得出</strong>这个「归纳」所付出的代价（该归纳只是廉价的网络段子？还是烧了五亿的血泪？或是所谓行业的传统？），还有<strong>违背</strong>这个「归纳」将付出的代价。</p><p>此外，不同玩家对同样代价的<strong>承受能力</strong>是不一样的。比如五亿的损失对普通玩家来说是噩梦，而对某些玩家来说只是毛毛雨。又比如，有些玩家被人误解就会情绪失控，另一些玩家被千万人误解也不会影响他们的前行状态（顺便说一下，技艺精湛的神级玩家通常属于两个例子中情绪失控的前者，因为他们敏锐细腻的感受力的<strong>副产品</strong>就是情绪的高波动性）。这也是为什么高效的修行要紧跟着<strong>活生生</strong>的「人」，而不仅仅是他们的文字或视频。跟着「<strong>人</strong>」才能最直观地感受对方的实践。他们的情绪、他们的余裕、他们的一举一动和他们的不动，都比「副本」的指引更为有效。</p></li></ul><blockquote><p>……这就像你试图告诉一个审美还停留在一身名牌商标的乡镇企业家他的形象很土，就像你试图说服一个很激动的爱国小将抵制日货可笑，就像你试图跟一个幼儿解释糖不是世界上最好吃的东西。</p><p>这样做不仅无效，还可能很引起对方的愤怒和哭闹。</p><p>这不是几句话、一篇文章能解决的，用黄章晋老师的话说——中间可能隔着几十本书的信息量，或者是十几年的成长过程。</p><footer><strong>Stephen Chu</strong></footer></blockquote><ul><li><p>「<strong>执迷不悟</strong>」是常态。资深玩家们多次强调要注意的坑，新人们即使被反复洗脑之后仍旧会毫不犹豫地跳下去，这是很正常的事情，愿双方都能对此保持平常心。</p><p>出现这类情况的原因很多，除了自身的固有认知外，前辈资深玩家们的观点之间通常也存在微妙或者巨大的分歧。然而<strong>必须要做出选择</strong>的时刻总是会<strong>提前</strong>到来，新手未必能<strong>及时</strong>消化不同观点；再比如资深玩家的建议和人性有冲突，新人难以很好地控制自己的欲望等等。</p><p>值得一提的是，这并不代表前辈们的耳提面命毫无用处。它的作用在于，新人跳坑之后会清楚地想起，进而快速知道<strong>坑在哪</strong>、原理是什么、以及哪些资深玩家<strong>其实只是半吊子</strong>。倘若没有前辈的提点，新人们顶多只会察觉自己一直“掉血”，无法第一时间知道“伤害”来自哪里；</p></li><li><p>「<strong>信任</strong>」是一种威力巨大的修行机制，能<strong>最</strong>大程度提高前行的效率。与此同时，它的<strong>风险</strong>和它的威力一样可怕。这体现在弱者的实力<strong>不足以承受</strong>信任强者所需要付出的<strong>代价</strong>。</p><p>信任是有代价的。信错人只是其中一小部分潜在代价。主要代价是无论什么样的行动都会有失误的风险，<strong>风险是永远存在的</strong>。风险造成的损失对于强者来说是毛毛雨，而对相信强者的弱者则是致命打击（想想不同玩家对当前 5 亿人民币损失的承受能力吧）。只有具备足够的实力来<strong>承担损失</strong>，才可能有勇气去相信。不然只能做到部分相信，效率也因此大打折扣。</p><p>有些玩家会认为无知也能产生勇气。正所谓「胆怯的智慧 vs. 勇敢的无知」，他们觉得如果意识不到存在损失的风险，也能做到大胆前行。但其实这种情况一旦出现损失，很可能会导致今后<strong>再也没有</strong>勇气和能力去信任其他玩家，还挺麻烦的。还不如保持观望畏手畏脚的「胆怯智慧」。</p><p><strong>具备足够实力，就会敢于信任、有能力信任，进步也会神速。</strong>历史进程这东西，错过就再等几十年。反之就会畏手畏脚，陷入瓶颈，再难精进。说白了就是有实力才能承受试错损失，继而勇往直前。</p></li></ul><blockquote><p>除了最优秀的玩家之外，多数人都是跟着时代走的。这个时代没有…那就是没有。</p><footer><strong>施政</strong></footer></blockquote><h3 id="三个「X」"><a href="#三个「X」" class="headerlink" title="三个「X」"></a>三个「X」</h3><hr><p>接下来连载的三个<strong>有争议</strong>的话题，会对玩家们的行动提供相应的方法论，或者至少引发对方法论的思考。这些话题本质上都是关于取舍的——关于我的取舍，关于我的取舍原则和经验。它们毫无意外属于「归纳」的范畴。它们的实用性需要大家在<strong>实践</strong>中逐渐领会。</p><p>在连载的第一个话题「<strong>牛X</strong>」里，我会聊聊为什么说「牛X」是一种幻想？让修行速度大幅提升的王道是什么？为什么让修行速度进一步爆炸性提升的邪道只属于领先玩家？处在极限修行速度下的玩家们所面临的隐患是什么？在使用「新手」，「专家」和「神」这三个境界来描述的修行中，超越「神」的第四隐藏境界能给玩家们怎样的启发？为什么对身处修行期乃至事业期的玩家们来说，「纪律」是比「智商」更重要的品质？</p><p>连载的第二个话题是「<strong>装X</strong>」。其中将介绍「装X」的本质是什么？玩家们为什么要「装X」？为什么多数玩家只能装出低水平的「X」？为什么装 40 分钟的「X」合理的准备时间是一个星期？疲于日常的我们为什么会有一星期的准备时间？整个学生时代，或者说所有修行的日子中被严重低估以至于多数玩家完全忽略了的重要修炼项目是什么？</p><p>第三个关于「<strong>傻X</strong>」话题的连载里会提到，为什么说「世界上最大的不平等是智力上的不平等」？为什么「清华北大哈佛耶鲁也是百分之八十的傻X」这样的言论即使是真的，选择考入这些高等学府依然是得知真相后的玩家们明智的选择？为什么「傻X」浓度高达百分之八十的玩家群体非但没有走向灭亡，反而还能一起合作让经济持续增长几个世纪？肚子里已然能撑船、能开飞机、能装航空母舰的宰相级玩家，为什么即便能得体应对日常「傻X」，当面对在至暗时刻帮助过自己的「恩人型傻X」、自己一直视为信仰或灯塔的「偶像型傻X」、还有得过诺贝尔奖的「权威型傻X」时，还是会失态，甚至崩溃？为什么有些顶级玩家不承认世界上存在「傻X」？面对差得让人时刻想说脏话的沿途风景，只在意“远方”的攻略组玩家们如何在浮躁中取舍和自处？玩家们什么时候应该去看心理医生？</p><p>最后，祝各位玩得开心~</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络入门（更新中）</title>
      <link href="/2018/09/26/intro-to-neural-network/"/>
      <url>/2018/09/26/intro-to-neural-network/</url>
      
        <content type="html"><![CDATA[<p>神经网络（Neural Network）是深度学习（Deep Learning）领域里的一种计算方法</p><hr><h3 id="基本神经网络"><a href="#基本神经网络" class="headerlink" title="基本神经网络"></a>基本神经网络</h3><p>TODO<br>由于非线性方程是通用的函数逼近方法（非常多的函数的值都可以使用多项式来逼近，比如「根号 2 」的计算就是计算机通过计算泰勒展开完成的，而泰勒展开就是一种非线性方程），所以神经网络的隐藏层要使用非线性方程来搭建</p><p>神经网络的隐藏层里的非线性方程是由<strong>一个线性方程</strong>加上<strong>一个非线性激活函数</strong>组合而成</p><hr><h3 id="卷积神经网络（Convolutional-Neural-Network）"><a href="#卷积神经网络（Convolutional-Neural-Network）" class="headerlink" title="卷积神经网络（Convolutional Neural Network）"></a>卷积神经网络（Convolutional Neural Network）</h3><p><strong>卷积神经网络</strong>常用于解决图片分类的问题（image classification）。</p><p>数字化的图片是由像素组成的，而每一个像素都有自己的颜色（比如若用 RGB 表示，单个像素具有「红」，「绿」和「蓝」 3 个颜色通道），这样，一张图片就能表示成一个三维数组（Width, Height, ColorChannels）</p><p><strong>卷积神经网络</strong>的目标是让代表图片的三维数组在经过一系列的计算后，数组变得 much deeper，且 less wide and less high</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow 介绍（更新中）</title>
      <link href="/2018/09/21/TensorFlow/"/>
      <url>/2018/09/21/TensorFlow/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.tensorflow.org" target="_blank" rel="noopener">TensorFlow</a> 是 Google 的一个开源深度学习框架</p><hr><h3 id="安装-TensorFlow"><a href="#安装-TensorFlow" class="headerlink" title="安装 TensorFlow"></a>安装 TensorFlow</h3><p>可以使用 <code>pip</code> 安装（见<a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">这里</a>），也可以用 <code>conda</code> ，这里选用 <code>conda</code> 的安装方式。至于 conda 是什么？如何安装和配置？请参考<a href="/2018/05/27/set-up-anaconda/">安装和配置 Anaconda</a></p><pre><code class="lang-bash"># 最左边的 (ai-dl) 表示当前处于虚拟开发环境 ai-dl 中(ai-dl) $ conda install -c conda-forge tensorflow# 查看当前的虚拟开发环境中存在的 tensorflow 以及其版本(ai-dl) $ conda list | grep -ir &quot;tensorflow&quot;(standard input):tensorflow       1.10.0        py35_0    conda-forge</code></pre><p>测试 TensorFlow ，如果安装正确，Console 会打印出 “Hello, world!”</p><pre><code class="lang-python">### tensorflow_test.py ###import tensorflow as tf# Create TensorFlow object called tensorhello_constant = tf.constant(&#39;Hello World!&#39;)with tf.Session() as sess:    # Run the tf.constant operation in the session    output = sess.run(hello_constant)    print(output)</code></pre><p>PS:<br>有可能会遇到以下输出信息，这是因为你的 CPU 有线性加速功能 <strong>AVX2 FMA</strong> 而当前安装的 TensorFlow 不能使用它们（GPU 才能发挥 TensorFlow 的威力，所以 TensorFlow 不太支持 CPU），具体可以参见<a href="https://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u" target="_blank" rel="noopener">这里</a></p><pre><code class="lang-bash">(ai-dl) $ python tensorflow_test.py2018-09-21 23:20:36.754440: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMAb&#39;Hello World!&#39;</code></pre><hr><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li><p><a href="https://www.tensorflow.org/api_docs/python/tf/placeholder" target="_blank" rel="noopener"><strong>tf.placeholder</strong></a></p><pre><code class="lang-python"># TensorFlow uses arrays rather than tuples. It converts tuples to arrays. Therefore [] and () are equivalent.# Placeholder with [] shape takes a single scalar value directly.w = tf.placeholder(dtype=tf.int32, shape=(), name=&quot;foo0&quot;)x = tf.placeholder(dtype=tf.int32, shape=[], name=&quot;foo1&quot;)# Placeholder with [None] shape takes a 1-dimensional arrayy = tf.placeholder(dtype=tf.int32, shape=[None], name=&quot;foo2&quot;)# Placeholder with None shape can take in any value while computation takes place.z = tf.placeholder(dtype=tf.int32, shape=None, name=&quot;foo3&quot;)# Example# 创建 rank 4（维度为 4）的 Tensor# None 代表该维度可以是任意的数值，在深度学习神经网络中该维度通常代表 batch 的数量 - batch 的数量是超参数 batch size 决定的，因此是可变不固定的  inputs_real_img = tf.placeholder(tf.float32, [None, image_width, image_height, image_channels])# 创建标量（scalar）的 Tensorlearning_rate = tf.placeholder(tf.float32, [])</code></pre></li><li><p><a href="https://www.tensorflow.org/versions/r1.0/api_docs/python/tf/reshape" target="_blank" rel="noopener"><strong>tf.reshape</strong></a><br>MNIST 数据集是由 28px * 28px 单通道图片组成。tf.reshape 函数把 28px * 28px 的矩阵转换成了 784px * 1px 的单行向量 x。tf.reshape()  中 <code>-1</code> 的解释参见<a href="https://www.tensorflow.org/api_docs/python/tf/reshape" target="_blank" rel="noopener">官方文档</a>或<a href="https://blog.csdn.net/zeuseign/article/details/72742559" target="_blank" rel="noopener">这篇博客</a><br>简单来说就是 -1 这个位置的维度由 reshape() 函数自动计算出，到底是多少取决于其他维度的数据，只要所有元素的总和等于前面 x 的元素总和即可 - 可以看到，张量（tensor）x 中一共有 28 * 28 * 1 = 784 个元素，而 n_input = 784 ，所以 -1 这个位置的维度值为 28 * 28 * 1 / n_input = 784 /784 = 1，进而 x_flat 的维度就是 [1, 784]<br>更多关于 Shape 的知识细节可以从这篇延伸阅读开始：<br><a href="https://pgaleone.eu/tensorflow/2018/07/28/understanding-tensorflow-tensors-shape-static-dynamic/" target="_blank" rel="noopener">Understanding Tensorflow’s tensors shape: static and dynamic</a></p><pre><code class="lang-python">import tensorflow as tfn_input = 784  # MNIST data input (img shape: 28*28)n_classes = 10  # MNIST total classes (0-9 digits)# tf Graph inputx = tf.placeholder(&quot;float&quot;, [None, 28, 28, 1])y = tf.placeholder(&quot;float&quot;, [None, n_classes])x_flat = tf.reshape(x, [-1, n_input])</code></pre></li><li><p><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dropout" target="_blank" rel="noopener"><strong>tf.nn.dropout</strong></a> 和 <a href="https://www.tensorflow.org/api_docs/python/tf/layers/dropout" target="_blank" rel="noopener"><strong>tf.layers.dropout</strong></a> 的区别<br>两者都用于是给神经网络的隐藏层（Hidden Layers）添加 dropout 层的，它们之间的区别仅仅在于接收的参数不同，导致双方对 dropout 层有着不一样的控制能力。具体可参见 <a href="https://stackoverflow.com/questions/44395547/tensorflow-whats-the-difference-between-tf-nn-dropout-and-tf-layers-dropout" target="_blank" rel="noopener">what’s the difference between tf.nn.dropout and tf.layers.dropout</a></p></li></ul><hr><h3 id="基础神经网络-Vanilla"><a href="#基础神经网络-Vanilla" class="headerlink" title="基础神经网络 - Vanilla"></a>基础神经网络 - Vanilla</h3><p>Vanilla 前馈神经网络（Feed Forward Neural Network）<br>TODO</p><hr><h3 id="卷积神经网络-CNN"><a href="#卷积神经网络-CNN" class="headerlink" title="卷积神经网络 - CNN"></a>卷积神经网络 - CNN</h3><p>卷积神经网络（Convolutional Neural Network）<br>TODO</p><hr><h3 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络 - RNN"></a>循环神经网络 - RNN</h3><p>循环神经网络（Recurrent Neural Network）<br>TODO</p><hr><h3 id="生成对抗神经网络-GAN"><a href="#生成对抗神经网络-GAN" class="headerlink" title="生成对抗神经网络 - GAN"></a>生成对抗神经网络 - GAN</h3><p>生成对抗网络（Generative Adversarial Network）</p><pre><code class="lang-python">def model_inputs(real_dim, z_dim):    # tf.placeholder 的 shape 参数里值为 None 的维度代表该维度可以是任何值（整数）    # 此处该维度是用来放置 Batch 数量的，根据 Batch Size 不同的值，Batch 的数量也会不同，所以这是一个可变的维度       inputs_real = tf.placeholder(tf.float32, shape=(None, real_dim), name=&quot;input_real&quot;)    inputs_z = tf.placeholder(tf.float32, shape=(None, z_dim), name=&quot;input_z&quot;)    return inputs_real, inputs_z</code></pre><hr><h3 id="神经网络示例"><a href="#神经网络示例" class="headerlink" title="神经网络示例"></a>神经网络示例</h3><pre><code class="lang-python">### tensorflow_demo.py ###import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data# 使用 TensorFlow 提供的 MNIST 数据集，其中对数据的分批和 One-Hot 编码已经完成mnist = input_data.read_data_sets(&quot;.&quot;, one_hot=True, reshape=False)# 超参数 Parameterslearning_rate = 0.001training_epochs = 20batch_size = 128  # 如果没有足够内存，可以降低 batch sizedisplay_step = 1n_input = 784  # MNIST data input (img shape: 28*28 = 784)n_classes = 10  # MNIST total classes (0-9 digits)n_hidden_layer = 256 # 隐藏层的节点数（本例以一个隐藏层为例，给该层设置了 256 个节点「nodes」）# 设置层权重（Weights）和偏差（Bias）的储存weights = {    &#39;hidden_layer&#39;: tf.Variable(tf.random_normal([n_input, n_hidden_layer])),    &#39;out&#39;: tf.Variable(tf.random_normal([n_hidden_layer, n_classes]))}biases = {    &#39;hidden_layer&#39;: tf.Variable(tf.random_normal([n_hidden_layer])),    &#39;out&#39;: tf.Variable(tf.random_normal([n_classes]))}# tf Graph input - 输入层设置x = tf.placeholder(&quot;float&quot;, [None, 28, 28, 1])y = tf.placeholder(&quot;float&quot;, [None, n_classes])x_flat = tf.reshape(x, [-1, n_input])# Hidden layer with RELU activation# ReLU作为隐藏层激活函数layer_1 = tf.add(tf.matmul(x_flat, weights[&#39;hidden_layer&#39;]),\    biases[&#39;hidden_layer&#39;])layer_1 = tf.nn.relu(layer_1)# Output layer with linear activation# 输出层的线性激活函数logits = tf.add(tf.matmul(layer_1, weights[&#39;out&#39;]), biases[&#39;out&#39;])# Define loss and optimizer# 定义误差值和优化器cost = tf.reduce_mean(\    tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y))optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)\    .minimize(cost)# Initializing the variables# 初始化变量init = tf.global_variables_initializer()# Launch the graph# 启动图with tf.Session() as sess:    sess.run(init)    # Training cycle    # 训练循环    for epoch in range(training_epochs):        total_batch = int(mnist.train.num_examples/batch_size)        # Loop over all batches        # 遍历所有 batch        for i in range(total_batch):            batch_x, batch_y = mnist.train.next_batch(batch_size)            # Run optimization op (backprop) and cost op (to get loss value)            # 运行优化器进行反向传导、计算 cost（获取 loss 值）            sess.run(optimizer, feed_dict={x: batch_x, y: batch_y})</code></pre><hr><h3 id="保存训练进度"><a href="#保存训练进度" class="headerlink" title="保存训练进度"></a>保存训练进度</h3><p>在现实中，训练一个模型常常要用很长时间，若是由于某种原因 TensorFlow Session 被关闭，所有当前训练得到的权重（Weights）和偏差（Bias）都会丢失，需要重新训练。针对这种情况，TensorFlow 提供了一个 tf.train.Saver 的类用于把当前进程保存下来，这个过程本质上是把会话（Session）中所有 tf.Variable 存到你的文件系统。</p><pre><code class="lang-python">### tensorflow_save_demo.py ###import tensorflow as tf# The file path to save the data# 文件保存路径，保存为 .ckpt 文件save_file = &#39;./model.ckpt&#39;# Two Tensor Variables: weights and bias# 两个 Tensor 变量：权重和偏置项weights = tf.Variable(tf.truncated_normal([2, 3]))bias = tf.Variable(tf.truncated_normal([3]))# Class used to save and/or restore Tensor Variables# 用来存取 Tensor 变量的类saver = tf.train.Saver()with tf.Session() as sess:    # Initialize all the Variables    # 初始化所有变量    sess.run(tf.global_variables_initializer())    # Show the values of weights and bias   # 显示变量和权重    print(&#39;Weights:&#39;)    print(sess.run(weights))    print(&#39;Bias:&#39;)    print(sess.run(bias))    # Save the model    # 保存模型    saver.save(sess, save_file)</code></pre><hr><h3 id="加载训练进度"><a href="#加载训练进度" class="headerlink" title="加载训练进度"></a>加载训练进度</h3><p>把上面的代码所保存的进度（变量的值）加载到新模型里。<br>注意，你依然需要在 Python 中创建 weights 和 bias 两个 Tensor 。<br>使用 <code>tf.train.Saver.restore()</code> 函数把之前保存的数据加载到 weights 和 bias 当中。这里因为 <code>tf.train.Saver.restore()</code> 已经设定了 TensorFlow 变量，所以不需要再调用 <code>tf.global_variables_initializer()</code>了。</p><pre><code class="lang-python"># Remove the previous weights and bias# 移除之前的权重和偏置项tf.reset_default_graph()# Two Variables: weights and bias# 两个变量：权重和偏置项weights = tf.Variable(tf.truncated_normal([2, 3]))bias = tf.Variable(tf.truncated_normal([3]))# Class used to save and/or restore Tensor Variables# 用来存取 Tensor 变量的类saver = tf.train.Saver()with tf.Session() as sess:    # Load the weights and bias    # 加载权重和偏置项    saver.restore(sess, save_file)    # Show the values of weights and bias    # 显示权重和偏置项    print(&#39;Weight:&#39;)    print(sess.run(weights))    print(&#39;Bias:&#39;)    print(sess.run(bias))</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keras - 快速搭建神经网络（更新中）</title>
      <link href="/2018/09/21/keras/"/>
      <url>/2018/09/21/keras/</url>
      
        <content type="html"><![CDATA[<p>在深度学习中，<a href="https://keras.io" target="_blank" rel="noopener">Keras</a> 是一个常用的函数库，提供了各种神经网络（Neural Network）相关的函数，适合于快速建立一套神经网络。</p><p>关于什么是神经网络，它如何运作，参考<a href="/2018/09/26/intro-to-neural-network/">神经网络入门</a></p><hr><h3 id="安装-Keras"><a href="#安装-Keras" class="headerlink" title="安装 Keras"></a>安装 Keras</h3><p>在安装 <a href="https://keras.io/#installation" target="_blank" rel="noopener">Keras</a> 之前，需要先安装以下其中一个支持它的后端引擎（backend engines）：</p><ol><li><a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">TensorFlow</a></li><li><a href="http://deeplearning.net/software/theano/install.html#install" target="_blank" rel="noopener">Theano</a></li><li><a href="https://docs.microsoft.com/en-us/cognitive-toolkit/setup-cntk-on-your-machine" target="_blank" rel="noopener">CNTK</a></li></ol><p>本文中选择安装 TensorFlow（至于如何安装 TensorFlow ，可参见<a href="/2018/09/21/TensorFlow/">TensorFlow 介绍</a>）</p><p>通过终端里运行 <code>conda install keras</code> 命令来安装，至于 conda 命令是什么？如何安装和配置？请参考<a href="/2018/05/27/set-up-anaconda/">安装和配置 Anaconda</a></p><pre><code class="lang-bash">## 这里假定你已经安装设置好了 anaconda ，可以使用 conda 相关命令## 最左边的 (py36) 显示的是目前所处的开发环境名，参考上面的链接中关于「相互隔离的开发环境」的说明(py36) $ conda install kerasSolving environment: done## Package Plan ##  environment location: /anaconda3/envs/py36  added / updated specs:    - kerasThe following packages will be downloaded:    ...    ...Proceed ([y]/n)? y    ...    ...Preparing transaction: doneVerifying transaction: doneExecuting transaction: done(py36) $</code></pre><hr><h3 id="使用-Keras-建立神经网络"><a href="#使用-Keras-建立神经网络" class="headerlink" title="使用 Keras 建立神经网络"></a>使用 Keras 建立神经网络</h3><p>Keras 的使用非常简单，按照下面的步骤顺序即可制定出想要的「神经网络模型」。接下来只要向「模型」输入数据集就可以训练（training）了。训练完成后，再向「模型」输入数据就能得到预测结果：</p><ol><li><p>选择模型 - 序列模型（Sequential model）<br><a href="https://keras.io/models/sequential/" target="_blank" rel="noopener">Sequential</a> 是常用的神经网络结构模型，所以以它为例，其他都能依此类推</p><pre><code class="lang-python"># 载入 Sequential modelfrom keras.models import Sequential# 创建一个 Sequential modelmodel = Sequential()</code></pre></li><li><p>添加层（Layer）<br>创建名为 <strong>model</strong> 的 Sequential 后，就可依次添加各种「层」。神经网络由「层」组成，选择需要的「层」的种类，然后通过 <code>.add()</code> 添加。这里以全连接层（Fully Connected Layer）为例</p><pre><code class="lang-python"># 载入构建神经网络的层（layer）的类型from keras.layers.core import Dense, Activation# 第 1 层 - 添加有 29 个节点的全连接层以及 32 个节点的「输入层（Input Layer）」- 也就是每次有 32 个数据要输入 model.add(Dense(29, input_dim=32))# 第 2 层 - 添加使用 ReLU 函数的「激活层（Activation Layer）」model.add(Activation(&#39;relu&#39;))# 第 3，4 层 - 添加具有 10 个节点的「全连接层」，并指定使用 Softmax 函数（相当于同时再增加了一层「激活层」）model.add(Dense(10, activation=&#39;softmax&#39;))##... 层数可以一直添加，层数越多越复杂 ...### 第 (n-1) 层 - 添加具有 2 个节点的全连接层（此 n-1 层的节点数为 2 ，说明预测模型最终只输出 2 个值）model.add(Dense(2))# 第 n 层 - 添加使用 Sigmoid 函数的激活层（如果超过 2 个输出值，就要用别的激活函数 比如 softmax 函数）model.add(Activation(&#39;sigmoid&#39;))</code></pre></li><li><p>编译模型（Compile）<br>经过上面两步设置后，就可以开始编译（compile）了：</p><pre><code class="lang-python">model.compile(loss=&quot;categorical_crossentropy&quot;, optimizer=&quot;adam&quot;, metrics = [&#39;accuracy&#39;])</code></pre><p> 编译前还需要设定 <code>loss</code>（损失函数-神经网络中的概念），<code>metrics</code>（评估模型用的指标），还有 <code>optimizer</code>（优化程序 - 概念参考<a href="http://ruder.io/optimizing-gradient-descent/index.html#rmsprop" target="_blank" rel="noopener">此文</a>）。常见的 optimizer 有：</p><ul><li><strong>SGD</strong><br>这是随机梯度下降。它使用了以下参数：<ul><li>学习速率</li><li>动量（获取前几步的加权平均值，以便获得动量而不至于陷在局部最低点）</li><li>Nesterov 动量（当最接近解决方案时，它会减缓梯度）</li></ul></li><li><strong>Adam</strong><br>Adam (Adaptive Moment Estimation) 使用更复杂的指数衰减，不仅仅会考虑平均值（第一个动量），并且会考虑前几步的方差（第二个动量）</li><li><strong>RMSProp</strong><br>RMSProp (RMS 表示均方根误差）通过除以按指数衰减的平方梯度均值来减小学习速率</li></ul></li><li><p>训练模型（Training）<br>将训练集数据 <code>x_train</code> 和 <code>y_train</code> 输入上面编译出来的模型，来进行训练。此处 <code>batch_size</code> 是随机梯度下降（Stochastic Gradient Descent - 神经网络概念）过程中每份数据的数量； <code>epochs</code> 是训练重复的次数，每一次 epoch 都会遍历所有输入数据； <code>validation_data</code> 是验证集数据（神经网络概念）；最后的 <code>verbose</code> 是进度输出设置，0 为不输出进度，1 为输出每次 epoch 的进度条，2 为输出简单进度百分比的信息：</p><pre><code class="lang-python">model.fit(x_train, y_train, batch_size=20, epochs=100, validation_data=(x_vali, y_vali), verbose=2)</code></pre></li><li><p>预测（Predict）<br>模型训练好之后，就能对进行预测了。输入测试数据可以看模型的预测效果：</p><pre><code class="lang-python"># 此例中，模型要判断某个事件是否发生，故预测输出只有两个值：[没发生的概率，发生的概率]# 不同的情况下，预测模型输出的值的数量不一样，取决于你的神经网络结构score = model.evaluate(x_test, y_test, verbose=0)print(&quot;Accuracy: &quot;, score[1])  # 输出预测事件发生的正确率</code></pre></li></ol><hr><h3 id="Keras-中创建卷积层（Convolutional-Layer）"><a href="#Keras-中创建卷积层（Convolutional-Layer）" class="headerlink" title="Keras 中创建卷积层（Convolutional Layer）"></a>Keras 中创建卷积层（Convolutional Layer）</h3><p>「卷积层」是神经网络的另一种类型的「层」，添加方式和上文的「全连接层」一样，使用 <code>.add()</code> 。<strong>卷积层</strong>的相关概念请参见<a href="/2018/09/26/intro-to-neural-network/">神经网络入门</a>，这里直接说明创建方法：</p><pre><code class="lang-python"># 载入必要的模块 - 此处以 2D 卷积为例from keras.layers import Conv2D# 使用以下格式创建卷积层：# Conv2D(filters, kernel_size, strides, padding, activation=&#39;relu&#39;, input_shape)</code></pre><p>参数说明（<strong>*</strong> 为<strong>必传</strong>参数）：</p><ul><li><code>filters</code> <strong>*</strong> : 过滤器（ <strong>filter</strong> ）的数量</li><li><code>kernel_size</code> <strong>*</strong> : 指定（方形）卷积窗口的高和宽的数字（即每个 <strong>filter</strong> 的高和宽）</li><li><p><code>strides</code>: <strong>filter</strong> 在输入图片（input image）上每次移动的距离（用像素数量表示），如果不指定任何值，则 strides 设为 1，即以 1 个像素的距离移动<br><strong><em>提示</em></strong>：可以将 kernel_size 和 strides 表示为数字或元组（tuple）</p></li><li><p><code>padding</code>: （输入图片）边界的处理方式，选项包括 ‘valid’（舍弃边界）和 ‘same’（保留边界，filter 超出部分以 0 填充），如果不指定任何值，则 padding 设为 ‘valid’</p></li><li><p><code>activation</code>: 通常为 ‘relu’。如果未指定任何值，则不应用任何激活函数。强烈建议你向网络中的每个卷积层添加一个 ReLU 激活函数</p></li><li><p><code>input_shape</code> <strong>*</strong> : 指定输入的高度、宽度和深度（按此顺序）的<strong>元组（tuple）</strong><br><strong><em>注意</em></strong>：在模型中将卷积层当做第一层级（出现在输入层之后）时，<strong>必须提供</strong> input_shape 参数；如果卷积层不是网络的第一个层级，<strong>请勿包含</strong> input_shape </p></li></ul><p>其他关于<strong>卷积层</strong>的参数设置，参阅官方文档 <a href="https://keras.io/layers/convolutional/" target="_blank" rel="noopener">Convolutional Layers</a></p><p>代码示例：</p><pre><code class="lang-python"># 载入必要模块 - 上文中已载入# from keras.models import Sequential# from keras.layers import Conv2Dcnn_model_demo_1 = Sequential()   # cnn 为 convolutional neural network（卷积神经网络）的缩写### 示例 1### 假设我要构建一个 CNN，输入层接受的是 200 x 200 像素（对应于高 200、宽 200、深 1 的三维数组）的灰度图片；### 假设我希望下一层级是卷积层，具有 15 个过滤器，每个宽和高分别为 2 ；### 在进行卷积操作时，我希望过滤器每次跳转 2 个像素；### 我不希望过滤器超出图片界限之外，也就是说，我不想用 0 填充图片；### 构建此层级的代码如下：cnn_CLlayer1 = Conv2D(filters=15, kernel_size=2, strides=2, activation=&#39;relu&#39;, input_shape=(200, 200, 1))### 示例 2### 假设我希望 CNN 的下一层级是卷积层，并将示例 1 中构建的层级作为输入；### 假设新层级是 32 个过滤器，每个的宽和高都是 3 ；### 在进行卷积操作时，我希望过滤器每次移动 1 个像素；### 我希望卷积层查看上一层级的所有区域，因此不介意过滤器在进行卷积操作时是否超过上一层级的边缘；### 构建此层级的代码如下：cnn_CLlayer2 = Conv2D(filters=32, kernel_size=3, padding=&#39;same&#39;, activation=&#39;relu&#39;)### 示例 3### 如果在线查看代码，经常会在 Keras 中见到以下格式的卷积层：cnn_CLlayer3 = Conv2D(64, (2,2), activation=&#39;relu&#39;)   # 该层有 64 个过滤器，每个大小是 2x2，层级具有 ReLU 激活函数。层级中的其他参数使用默认值，因此卷积的 stride 为 1，填充设为 &#39;valid&#39; ### 示例 4### 因为 padding 设置了 valid ，该层输出的数据维度为（63, 63, 32），注意和 same 的输出数据维度对比进而了解两者区别cnn_CLlayer4 = Conv2D(filters=32, kernel_size=3, strides=2, padding=&#39;valid&#39;,     activation=&#39;relu&#39;, input_shape=(128, 128, 3))cnn_model_demo_1.add(cnn_CLlayer4)   # 添加「示例 4」的卷积层cnn_model_demo_1.summary()         # 输出查看#### summary() 输出结果 - 这里是卷积层 cnn_CLlayer4 的信息 ##### Using TensorFlow backend.# _________________________________________________________________# Layer (type)                 Output Shape              Param ## =================================================================# conv2d_1 (Conv2D)            (None, 63, 63, 32)        896# =================================================================# Total params: 896# Trainable params: 896# Non-trainable params: 0# _________________________________________________________________</code></pre><hr><h3 id="Keras-中创建最大池化层（Max-Pooling-Layer）"><a href="#Keras-中创建最大池化层（Max-Pooling-Layer）" class="headerlink" title="Keras 中创建最大池化层（Max Pooling Layer）"></a>Keras 中创建最大池化层（Max Pooling Layer）</h3><p>「最大池化层」是神经网络又一种类型的「层」，同样使用 <code>.add()</code> 添加，它通常使用在<strong>卷积神经网络中</strong>排在「卷积层」之后，将「卷积层」的输出作为输入。<strong>池化层</strong>的相关概念请参见<a href="/2018/09/26/intro-to-neural-network/">神经网络入门</a>，这里直接介绍创建方法：</p><pre><code class="lang-python"># 载入必要的模块 - 此处以 2D 卷积为例from keras.layers import MaxPooling2D# 使用以下格式创建最大池化层：# MaxPooling2D(pool_size, strides, padding)</code></pre><p>参数说明（<strong>*</strong> 为<strong>必传</strong>参数）：</p><ul><li><code>pool_size</code> <strong>*</strong> : 指定池化窗口高度和宽度的数字</li><li><code>strides</code>: 垂直和水平 stride（移动距离），如果不指定任何值，则 strides 默认为 <code>pool_size</code></li><li><code>padding</code>: 选项包括 ‘valid’（舍弃边界）和 ‘same’（保留边界，filter 超出部分以 0 填充），如果不指定任何值，则 padding 设为 ‘valid’<br><strong>注意</strong>：可以将 pool_size 和 strides 表示为数字或元组（tuple）</li></ul><p>其他关于<strong>最大池化层</strong>的参数设置，参阅官方文档 <a href="https://keras.io/layers/pooling/#maxpooling2d" target="_blank" rel="noopener">Max Pooling</a></p><p>代码示例：</p><pre><code class="lang-python"># 载入必要模块 - 上文中已载入# from keras.models import Sequential# from keras.layers import MaxPooling2Dcnn_model_demo_2 = Sequential()   # cnn 为 convolutional neural network（卷积神经网络）的缩写### 示例# 假设我要构建一个 CNN，并且我想通过在卷积层后面添加最大池化层，降低卷积层的维度# 假设卷积层的输出（output）大小是 (100, 100, 15)，我希望最大池化层的大小为 (50, 50, 15)# 要实现这一点，我可以在最大池化层中使用 2x2 窗口，stride 设为 2，代码如下：cnn_MPlayer = MaxPooling2D(pool_size=2, strides=2, input_shape=(100, 100, 15))#「示例 1」的卷积层# cnn_CLlayer1 = Conv2D(filters=15, kernel_size=2, strides=2, activation=&#39;relu&#39;, input_shape=(200, 200, 1))cnn_model_demo_2.add(cnn_CLlayer1)     # 添加上文中「示例 1」的卷积层cnn_model_demo_2.add(cnn_MPlayer)  # 添加「示例」中的最大池化层cnn_model_demo_2.summary()         # 输出查看#### summary() 输出结果 - 这里是「最大池化层」cnn_MPlayer 和「卷积层」cnn_CLlayer1 的信息 ##### Using TensorFlow backend.# _________________________________________________________________# Layer (type)                 Output Shape              Param ## =================================================================# conv2d_1 (Conv2D)            (None, 100, 100, 15)      75# _________________________________________________________________# max_pooling2d_1 (MaxPooling2 (None, 50, 50, 15)        0# =================================================================# Total params: 75# Trainable params: 75# Non-trainable params: 0# _________________________________________________________________</code></pre><hr><h3 id="用-Keras-建立一个完整的-CNN-模型架构"><a href="#用-Keras-建立一个完整的-CNN-模型架构" class="headerlink" title="用 Keras 建立一个完整的 CNN 模型架构"></a>用 Keras 建立一个完整的 CNN 模型架构</h3><p>下面代码所建立的 CNN 模型例子中，其目标是对输入图片（input image）中所包含的 <strong>10</strong> 个不同种类的对象进行预测，判断图片中含有哪一个对象。<br>该网络以 3 个<code>「卷积层」&amp;「最大池化层」</code>组合开始（共 6 个层）。这 3 个组合（6 个层级）旨在将图片像素数组输入转换为所有空间信息（spacial info - 即像素的位置排列信息）都丢失、仅保留图片内容信息（像素形成的各种对象 Patterns ，比如车轮的 Pattern ，眼睛的 Pattern）的数组 。然后在 CNN 的第七个层级将该数组扁平化为向量。后面跟着两个密集层（Dense Layer - 即全连接层），旨在进一步说明图片中的内容。最后一层针对数据集中的每个对象类别都有一个条目，并具有一个 softmax 激活函数，使其返回概率。</p><pre><code class="lang-python"># 载入必要模块 - 上文中已载入一部分# from keras.models import Sequential# from keras.layers import Conv2D, MaxPooling2D, Dense  # 要用到三个种类的「层」：「卷积层」，「池化层」，「全连接层」from keras.layers import Flatten  # Flattern 函数用于将多维张量（Tensor）转换为 1 维张量，即向量 Vectorfrom keras.layers import Dropout  # Dropout 函数用于随机关闭「层」中的节点，缓解模型过拟合效应（over fitting）cnn_model = Sequential()  # cnn 为 convolutional neural network（卷积神经网络）的缩写# 添加 3 个「卷积层」&amp;「最大池化层」组合，共 6 个层，不断减小图片中的空间信息（width 和 height），并提取出图片中的 Patterns（不同对象的图形规律）信息 cnn_model.add(Conv2D(filters=16, kernel_size=2, padding=&#39;same&#39;, activation=&#39;relu&#39;, input_shape=(32, 32, 3)))cnn_model.add(MaxPooling2D(pool_size=2))cnn_model.add(Conv2D(filters=32, kernel_size=2, padding=&#39;same&#39;, activation=&#39;relu&#39;))cnn_model.add(MaxPooling2D(pool_size=2))cnn_model.add(Conv2D(filters=64, kernel_size=2, padding=&#39;same&#39;, activation=&#39;relu&#39;))cnn_model.add(MaxPooling2D(pool_size=2))cnn_model.add(Dropout(0.2))                     # Dropout 值设置为 0.2 代表每个节点都有 20% 的概率被关闭cnn_model.add(Flatten())                        # 将多维张量（Tensor）转换为 1 维向量cnn_model.add(Dense(500, activation=&#39;relu&#39;))    # 将上面的一维向量 Vector 输入到一个全连接层cnn_model.add(Dropout(0.3))                     # Dropout 值设置为 0.3 代表每个节点都有 30% 的概率被关闭cnn_model.add(Dense(10, activation=&#39;softmax&#39;))  # 建立一个 10 节点的全连接层作为输出层，用 Softmax 函数输出 10 个种类各自的概率# 编译 - 采用的误差损失函数为「多类别交叉熵」cnn_model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=&#39;rmsprop&#39;, metrics=[&#39;accuracy&#39;])</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas 进阶（待完善）</title>
      <link href="/2018/09/17/pandas-advanced-features/"/>
      <url>/2018/09/17/pandas-advanced-features/</url>
      
        <content type="html"><![CDATA[<p>在<a href="/2018/06/01/numpy-and-pandas/"> NumPy 和 Pandas 入门</a>一文里已介绍了 Pandas 的安装方式，本文会直接详细介绍 Pandas 的常用类型 <strong>Series</strong> 和 <strong>DataFrame</strong> 所包含的各种方法，推荐全文检索</p><hr><h3 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h3><p>终端里进入 Python 的 交互式解释器（interactive interpreter），并载入 Pandas</p><pre><code class="lang-bash">$ pythonPython 3.6.5 |Anaconda, Inc.| (default, Apr 26 2018, 08:42:37)[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import pandas as pd</code></pre><hr><h3 id="Pandas-里的-Series-类型"><a href="#Pandas-里的-Series-类型" class="headerlink" title="Pandas 里的 Series 类型"></a>Pandas 里的 Series 类型</h3><ul><li><h4 id="Series-类型的常见-Methods"><a href="#Series-类型的常见-Methods" class="headerlink" title="Series 类型的常见 Methods"></a>Series 类型的常见 Methods</h4><pre><code class="lang-bash">## 把 list 类型转换为 Series 类型&gt;&gt;&gt; s = pd.Series(list(&#39;abbca&#39;))## Series 的数据结构由左边的 index 和右边的 values 组成，还有隐藏参数 position（根据从上到下的顺序，按位置排列，0 是第一位，1是第二位）## Series 里的 index 可以是其他类型，不一定是整数&gt;&gt;&gt; s0    a1    b2    b3    c4    adtype: object## 判断某个元素（element）是否在 Series 的 index 里&gt;&gt;&gt; 1 in sTrue&gt;&gt;&gt; &quot;a&quot; in sFalse## 将 Series 里的元素去重 - 相当于变为集合（set）&gt;&gt;&gt; s.unique()array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=object)## 取出 Series 里值为 b 的所有元素（element），返回一个 Series 类型的子集&gt;&gt;&gt; s[s == &quot;b&quot;]1    b2    b## 寻找 Series 里值为 b 的元素（element）所对应的 index 的值&gt;&gt;&gt; s[s == &quot;b&quot;].indexInt64Index([1, 2], dtype=&#39;int64&#39;)## 取第一个 index 的值&gt;&gt;&gt; s[s == &quot;b&quot;].index[0]1## 根据 index 移除 Series 里的某一个元素 - 返回新的 Series 而不改变原来的变量 s 的值 &gt;&gt;&gt; s.drop(index=1)0    a2    b3    c4    adtype: object## 接下来就可以判断某个元素（element）否在 Series 的值（value）里&gt;&gt;&gt; &quot;a&quot; in s.unique()True## 根据 index 排序 - 返回一个新的 Series ，内部元素根据 index 大小排列&gt;&gt;&gt; s.sort_index()&gt;&gt;&gt; s_list = pd.Series([...           [&#39;slim&#39;, &#39;waist&#39;, &#39;man&#39;],...           [&#39;slim&#39;, &#39;waistline&#39;],...           [&#39;santa&#39;]])&gt;&gt;&gt; s_list0    [slim, waist, man]1     [slim, waistline]2               [santa]dtype: object## 将一个 Series 里的所有 list 类型数据的元素合成一个新的 Series&gt;&gt;&gt; one_united_series = s_list.apply(pd.Series).stack().reset_index(drop=True)&gt;&gt;&gt; one_united_series0         slim1        waist2          man3         slim4    waistline5        santadtype: object</code></pre></li><li><h4 id="Series-类型的向量运算"><a href="#Series-类型的向量运算" class="headerlink" title="Series 类型的向量运算"></a>Series 类型的向量运算</h4><p>pandas 里的 Series 类型的相加是根据 <strong>index</strong> 匹配相加减的，而不是根据 <strong>position</strong></p><pre><code class="lang-bash">## 相加的几种情况## Addition when indexes are the same&gt;&gt;&gt; s1 = pd.Series([1, 2, 3, 4], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; s2 = pd.Series([10, 20, 30, 40], index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])&gt;&gt;&gt; print(s1 + s2)a    11b    22c    33d    44dtype: int64## Indexes have same elements in a different orders3 = pd.Series([10, 20, 30, 40], index=[&#39;b&#39;, &#39;d&#39;, &#39;a&#39;, &#39;c&#39;])&gt;&gt;&gt; print(s1 + s3)a    31b    12c    43d    24dtype: int64## Indexes overlap, but do not have exactly the same elements&gt;&gt;&gt; s4 = pd.Series([10, 20, 30, 40], index=[&#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])&gt;&gt;&gt; print(s1 + s4)a     NaNb     NaNc    13.0d    24.0e     NaNf     NaNdtype: float64## Indexes do not overlap&gt;&gt;&gt; s5 = pd.Series([10, 20, 30, 40], index=[&#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;])&gt;&gt;&gt; print(s1 + s5)a   NaNb   NaNc   NaNd   NaNe   NaNf   NaNg   NaNh   NaNdtype: float64</code></pre></li></ul><p>一维数据<br><code>s1.loc[&#39;a&#39;]</code> 按照 Series 类型的索引（index）读取<br><code>s1.iloc[1]</code> 按照 Series 类型的位置（position）读取，相当于 <code>s1[1]</code></p><hr><h3 id="Pandas-里的-DataFrame-类型"><a href="#Pandas-里的-DataFrame-类型" class="headerlink" title="Pandas 里的 DataFrame 类型"></a>Pandas 里的 DataFrame 类型</h3><p><a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html" target="_blank" rel="noopener">pandas.DataFrame</a> 是一种能够有效处理 <code>.csv</code> 文件内容的二维数据结构，允许每一列（column）各不相同的数据类型。</p><p>二维数据<br>读取行（row）的方式参照一维数据<br>读取列（column）的方式为 <code>s1[&#39;column_name&#39;]</code><br><code>s1.values</code> 返回的是 NumPy 的 Array 类型的数据（二维数组）- 注意该类型的数据要求全部元素都是同一类型 - 一般这样做是为了求所有元素的平均值，即 <code>s1.values.mean()</code></p><ul><li><h4 id="DataFrame-类型的创建"><a href="#DataFrame-类型的创建" class="headerlink" title="DataFrame 类型的创建"></a>DataFrame 类型的创建</h4><pre><code class="lang-bash">## DataFrame creation - 创建 DataFrame 类型要有 column 的值&gt;&gt;&gt; import pandas as pd## You can create a DataFrame out of a dictionary mapping column names to values&gt;&gt;&gt; df_1 = pd.DataFrame({&#39;A&#39;: [0, 1, 2], &#39;B&#39;: [3, 4, 5]})&gt;&gt;&gt; df_1   A  B0  0  31  1  42  2  5## You can also use a list of lists or a 2D NumPy array&gt;&gt;&gt; acid_df = pd.DataFrame([[3.51], [3.20], [3.26], [3.01], [3.16]], columns=[&#39;pH&#39;])&gt;&gt;&gt; acid_df     pH0  3.511  3.202  3.263  3.014  3.16## Subway ridership for 3 stations on 4 different days&gt;&gt;&gt; ridership_df = pd.DataFrame(...      data=[[   0,    0,    2],...            [1478, 3877, 3674],...            [1613, 4088, 3991],...            [1560, 3392, 3826]],...      index=[&#39;05-01-11&#39;, &#39;05-02-11&#39;, &#39;05-03-11&#39;, &#39;05-04-11&#39;],...      columns=[&#39;R003&#39;, &#39;R004&#39;, &#39;R005&#39;]... )&gt;&gt;&gt; ridership_df          R003  R004  R00505-01-11     0     0     205-02-11  1478  3877  367405-03-11  1613  4088  399105-04-11  1560  3392  3826## Grads for 4 students at two exams&gt;&gt;&gt; grades_df = pd.DataFrame(...      data={&#39;exam1&#39;: [43, 81, 78, 75],...            &#39;exam2&#39;: [24, 63, 56, 56],...            &#39;gender&#39;: [&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;]},...      index=[&#39;Andre&#39;, &#39;Barry&#39;, &#39;Chris&#39;, &#39;Dan&#39;]...  )&gt;&gt;&gt; grades_df       exam1  exam2  genderAndre     43     24    MaleBarry     81     63    MaleChris     78     56  FemaleDan       75     56    Male</code></pre></li><li><h4 id="DataFrame-类型的常用方法（methods）"><a href="#DataFrame-类型的常用方法（methods）" class="headerlink" title="DataFrame 类型的常用方法（methods）"></a>DataFrame 类型的常用方法（methods）</h4><pre><code class="lang-bash">## 查看整体数据的信息 - 有几行；有几列；每列的数据类型；每列多少非空数据；## 有些列的数据是 object ，实际上它们是字符串，且这是因为它们将指针存储到字符串，而不是字符串本身&gt;&gt;&gt; grades_df.info()&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;Index: 4 entries, Andre to DanData columns (total 3 columns):exam1     4 non-null int64exam2     4 non-null int64gender    4 non-null objectdtypes: int64(2), object(1)memory usage: 128.0+ bytes## Accessing elements## 读取第一行，即 position = 0 的数据&gt;&gt;&gt; ridership_df.iloc[0]## 读取 index = &#39;05-05-11&#39; 的数据，即第 5 行&gt;&gt;&gt; ridership_df.loc[&#39;05-05-11&#39;]## 读取 column = &#39;R003&#39; 的数据，即第 1 列&gt;&gt;&gt; ridership_df[&#39;R003&#39;]&gt;&gt;&gt; ridership_df.R003  ## 虽然这种方式也能读 R003 列的数据，但 column 是中文名就不行了，故还是推荐上面的方式## 读取 position = [1, 3] 的数据&gt;&gt;&gt; ridership_df.iloc[1, 3]## slicing 切片 - 二维数据包含两个 axis，所以第一个 row_indexer 是指定沿着 index 方向的切片，第二个是指定沿着 column 方向的切片 &gt;&gt;&gt; df.loc[row_indexer,column_indexer]      ## 按照 index 取值&gt;&gt;&gt; df.iloc[row_indexer,column_indexer]     ## 按照 position 取值## Example - 读取 position = [1:4] 的数据 - 即 2 到 5 行（row）的数据## 两个表达式效果一样，因为右侧不填就默认是 :（即取全部）&gt;&gt;&gt; ridership_df.iloc[1:4]&gt;&gt;&gt; ridership_df.iloc[1:4, :]&gt;&gt;&gt; df_cancer.loc[:,&#39;id&#39;:&#39;fractal_dimension_mean&#39;]  ## 取所有行（row），取 &quot;id&quot; 列到 &quot;fractal_dimension_mean&quot; 列之间的所有列 ## 读取 column = &#39;R003&#39; 和 column = &#39;R005&#39; 的数据，即第 1，3 列（column）数据&gt;&gt;&gt; ridership_df[[&#39;R003&#39;, &#39;R005&#39;]]## 取出 ridership_df 里 &quot;R003&quot; 这一列的值大于 0 的所有行（row）&gt;&gt;&gt; ridership_df[ridership_df[&#39;R003&#39;] &gt; 0]## 读取第一行，即 position = 0 的数据里，最大值所在的列（column）的名字&gt;&gt;&gt; ridership_df.iloc[0].idxmax()&#39;R005&#39;## 读取第一列，即 column = &#39;R003&#39; 的数据里，最大值所在的行（row）的名字&gt;&gt;&gt; ridership_df[&#39;R003&#39;].idxmax()&#39;05-03-11&#39;## 读取前 3 行 - 输出数据里的一个小片段，看数据是否正常符合预期## 如果直接使用 .head() 不指定数字，默认是前 5 行&gt;&gt;&gt; ridership_df.head(3)          R003  R004  R00505-01-11     0     0     205-02-11  1478  3877  367405-03-11  1613  4088  399105-04-11  1560  3392  3826## 直接改变 Dataframe 表格的某一列（columns）- 缩小为原来的 1/2&gt;&gt;&gt; ridership_df[&quot;R005&quot;] = ridership_df[&quot;R005&quot;]/2&gt;&gt;&gt; ridership_df          R003  R004    R00505-01-11     0     0     1.005-02-11  1478  3877  1837.005-03-11  1613  4088  1995.505-04-11  1560  3392  1913.0# Pandas axis&gt;&gt;&gt; df_1   A  B0  0  31  1  42  2  5# 求和 - 针对每列求和&gt;&gt;&gt; df_1.sum()A     3B    12dtype: int64# 求和 - 针对每行求和&gt;&gt;&gt; df_1.sum(axis=1)0    31    52    7dtype: int64# 求和 - 针对全体数据求和&gt;&gt;&gt; df_1.values.sum()15# 矩阵的转置 - 反转 column 和 index，两者互换，不会改动原变量 df_1，不会动到同一块内存，而是返回一个生成新的值&gt;&gt;&gt; df_1.transpose()   0  1  2A  0  1  2B  3  4  5</code></pre></li><li><h4 id="apply-和-applymap-（未完待做）"><a href="#apply-和-applymap-（未完待做）" class="headerlink" title="apply 和 applymap （未完待做）"></a>apply 和 applymap （未完待做）</h4><p><code>.apply()</code> 作用在每一行或者每一列上（通过参数 axis 指定），而 <code>.applymap()</code> 作用在每个元素上</p><pre><code class="lang-bash"># 基本形式 df.apply(func, axis=&quot;columns&quot;)# axis 的值设为 0 或 &quot;index&quot; 则将函数 func 作用到 每一列（column）上# axis 的值设为 1 或 &quot;columns&quot; 则将函数 func 作用到 每一行（row）上&gt;&gt;&gt; df_1.apply(lambda x:x/2, axis=0)     A    B0  0.0  1.51  0.5  2.02  1.0  2.5# 作用在特定的某一列上 - Dataframe 类型的列就是 Series 类型，Series 也有 .apply()# 此处 apply 里的函数 func 接收的参数类型是 Series 里的元素，而上面的 func 接收的参数类型是 Series 类型&gt;&gt;&gt; df_1[&quot;A&quot;].apply(lambda x:x/2)0    0.01    0.52    1.0Name: A, dtype: float64# To do&gt;&gt;&gt; df.applymap()</code></pre></li><li><h4 id="用-Pandas-读取文件，储存为-DataFrame-数据类型进行操作"><a href="#用-Pandas-读取文件，储存为-DataFrame-数据类型进行操作" class="headerlink" title="用 Pandas 读取文件，储存为 DataFrame 数据类型进行操作"></a>用 Pandas 读取文件，储存为 DataFrame 数据类型进行操作</h4><pre><code class="lang-bash"># 读取 .csv 文件，返回一个 DataFrame 类型的数据，包含了该 .csv 文件的内容&gt;&gt;&gt; df = pd.read_csv(&quot;filename.csv&quot;)# Example - 可设定分隔符号（默认是逗号，此处设定为分号），也可设定 index_col 参数来指定使用数据中的某一列作为索引（index）&gt;&gt;&gt; subway_df = pd.read_csv(&quot;nyc_subway_weather.csv&quot;, sep=&quot;;&quot;, index_col=[&#39;Longitude&#39;, &#39;Latitude&#39;])# 生成包含数据的 .csv 文件# index=False 是指定不保存索引（index），index=True（默认值）则索引被保存为新的一列 Unnamed:0&gt;&gt;&gt; subway_df.to_csv(&#39;nyc_subway_weather_edited.csv&#39;, index=False)# 显示前 5 行（row）的数据 &gt;&gt;&gt; df.head(5)# 显示倒数 5 行（row）的数据 &gt;&gt;&gt; df.tail(5)# 显示 DataFrame 数据包含的列的名字（column names）&gt;&gt;&gt; df.columns# 显示用于描述该组数据特征的内容 - 数量(count)，平均值(mean)，标准差(std)，最小值(min)，最大值(max)&gt;&gt;&gt; df.describe()# 显示数据的储存方面的信息 - 包含的数据类型，非空(non-null)数量，数据占用内存容量(memory usage)&gt;&gt;&gt; df.info()# 显示数据的行（rows）数和列（columns）数 - 返回的是 tuple 数据类型&gt;&gt;&gt; df.shape# 统计名为 column_name 的某列（column）中，有多少种不同的值&gt;&gt;&gt; df[&#39;column_name&#39;].value_counts()# 统计名为 column_name 的某列中，有多少「非空」行（row）- 即有多少「非空」样本&gt;&gt;&gt; df[&#39;column_name&#39;].count()# Example - 统计 Gender 这列中 &quot;Male&quot; 和 &quot;Female&quot; 这两种取值的数量（因为此列只有这两种取值）# 在此其实就是统计男女数量&gt;&gt;&gt; df_share_bike[&#39;Gender&#39;].value_counts()Male      244Female     86Name: Gender, dtype: int64# 返回名为 column_name 的某列中，数据的集合（去除相同重复的数据）&gt;&gt;&gt; df[&#39;column_name&#39;].unique()# 将某列的数据类型转换成 datetime 类型&gt;&gt;&gt; df[&quot;time_column_name&quot;] = pd.to_datetime(df[&quot;time_column_name&quot;])# 删除（remove）不需要的列 - 注意此处 axis=1&gt;&gt;&gt; df.drop([&quot;column_name_01&quot;, &quot;column_name_02&quot;], axis=1, inplace=True)# 也可以这样 drop 不需要的列，效果一样&gt;&gt;&gt; df.drop(columns=[&quot;column_name_01&quot;, &quot;column_name_02&quot;])# 提取出某列中，值为 some_value 的所有行，组成一个新的 DataFrame 数据 df_new&gt;&gt;&gt; df_new = df[df[&quot;column_name&quot;] == &quot;some_value&quot; ]# 等效于以下 .query() 方法 - 注意引号位置，.query() 采用 string to evaluate 的方式对待传入参数&gt;&gt;&gt; df_new = df.query(&quot;column_name == &#39;some_value&#39;&quot;)&gt;&gt;&gt; df_new = df.query(&quot;column_name == @var&quot;)         # 若要配合变量 var 使用，则要在变量前添加符号 @ # 使用 .cut() 按照取值范围分组（类似切片） - 常配合 .groupby() 一起使用&gt;&gt;&gt; bin_edges = [2.72, 3.11, 3.21, 3.32, 4.01]         # 规定各个的取值范围的边界：[2.72 ~ 3.11]、[3.11 ~ 3.21]、[3.21 ~ 3.32] 和 [3.32 ~ 4.01] &gt;&gt;&gt; bin_names = [&quot;extreme&quot;, &quot;high&quot;, &quot;moderate&quot;, &quot;low&quot;] # 对每个酸度水平类别（取值范围）进行命名# 创建 levels 列 - .cut() 返回的是 Series 类型&gt;&gt;&gt; acid_df[&#39;levels&#39;] = pd.cut(acid_df[&#39;pH&#39;], bin_edges, labels=bin_names)&gt;&gt;&gt; acid_df     pH    levels0  3.51       low1  3.20      high2  3.26  moderate3  3.01   extreme4  3.16      high</code></pre></li><li><h4 id="整理-DataFrame-数据"><a href="#整理-DataFrame-数据" class="headerlink" title="整理 DataFrame 数据"></a>整理 DataFrame 数据</h4><p>通常原始数据都有各种瑕疵，比如重复项和丢失项，DataFrame 类型提供了一些处理方法（methods）</p><pre><code class="lang-bash">&gt;&gt;&gt; df_missing = pd.DataFrame(...                data=[[np.nan, 2, np.nan, 0],...                      [3, 4, np.nan, 1],...                      [np.nan, np.nan, 1, 4],...                      [np.nan, 3, np.nan, 4],...                      [0, 3, 1, 0]],...                columns=list(&#39;ABCD&#39;),...                index=list(&#39;abcce&#39;))&gt;&gt;&gt; df_missing     A    B    C  Da  NaN  2.0  NaN  0b  3.0  4.0  NaN  1c  NaN  NaN  1.0  4c  NaN  3.0  NaN  4e  0.0  3.0  1.0  0# 取每一列的均值来填充该列的丢失项 - C 列全部丢失，所以没有均值，也就没填充# 注意要加上 inplace=True 参数才能修改 df_missing，否则就只是返回新数据而已&gt;&gt;&gt; df_filled = df_missing.fillna(df_missing.mean())&gt;&gt;&gt; df_filled     A    B    C  Da  1.5  2.0  1.0  0b  3.0  4.0  1.0  1c  1.5  3.0  1.0  4c  1.5  3.0  1.0  4e  0.0  3.0  1.0  0# 查看重复项（默认显示第一个重复 row 的值为 True）- 默认只有全部列（column）的值都相同的行（row）&gt;&gt;&gt; df_filled.duplicated()a    Falseb    Falsec    Falsec     Truee    Falsedtype: bool# 大型数据库用以下方法直接看「总重复数」，避免输出一堆数据&gt;&gt;&gt; sum(df_filled.duplicated())1# 剔除掉重复项 - 用 inplace=True 参数修改 df_filled 本身&gt;&gt;&gt; df_filled.drop_duplicates(inplace=True)&gt;&gt;&gt; df_filled     A    B    C  Da  1.5  2.0  1.0  0b  3.0  4.0  1.0  1c  1.5  3.0  1.0  4e  0.0  3.0  1.0  0# 剔除掉含有至少含有一个丢失项的行（rows） - Drop the rows where at least one element is missing# 可以设置参数 axis=1 来剔除列（columns）&gt;&gt;&gt; df_drop_missed = df_missing.dropna()&gt;&gt;&gt; df_drop_missed     A    B    C  De  0.0  3.0  1.0  0# 任何列是否有空值 - 返回 False 则没有空值，返回 True 则存在空值&gt;&gt;&gt; df_drop_missed.isnull().sum().any()False&gt;&gt;&gt; df_missing.isnull().sum().any()True</code></pre></li><li><h4 id="groupby-用法-pandas-DataFrame-groupby"><a href="#groupby-用法-pandas-DataFrame-groupby" class="headerlink" title="groupby 用法 - pandas.DataFrame.groupby"></a>groupby 用法 - pandas.DataFrame.groupby</h4><p>DataFrame 类型的 <a href="http://pandas.pydata.org/pandas-docs/version/0.23/generated/pandas.DataFrame.groupby.html" target="_blank" rel="noopener">groupby</a> 也是常用的分析数据的 method</p><pre><code class="lang-bash">&gt;&gt;&gt; df1 = pd.DataFrame({&quot;X&quot; : [&#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;B&#39;],...                     &quot;Y&quot; : [1, 4, 3, 2],...                     &quot;Z&quot; : [1, 2, 2, 1],...                     &quot;M&quot; : [24,29,9,19]})# 用 groupby 按照列 &#39;X&#39; 的取值分组 - &#39;X&#39; 列中，取值相同的行（row）将被划分为同一组# 看中括号可知参数可以是一个 list，即按照多个列分组，此时不同列之间的「取值组合」所对应的行（row），构成了不同的组&gt;&gt;&gt; grouped_df1=df1.groupby([&quot;X&quot;])# 读取分组后的 grouped_df1 中，名为 &#39;A&#39; 的组 - 即得到一个由所有 X 取值为 &#39;A&#39; 的行（row）构成的 dataFrame 数据&gt;&gt;&gt; grouped_df1.get_group(&#39;A&#39;)   X  Y  Z   M0  A  1  1  242  A  3  2   9# 分组后可直接求出所有列（columns）中，各组的平均数等&gt;&gt;&gt; grouped_df1.mean()     Y    Z     MXA  2.0  1.5  16.5B  3.0  1.5  24.0# 也可以单独查看某一列（column）里，各个组的平均数&gt;&gt;&gt; grouped_df1[&quot;Y&quot;].mean()XA    2B    3Name: Y, dtype: int64# 查看一共分了几个组&gt;&gt;&gt; grouped_df1.ngroups2&gt;&gt;&gt; len(grouped_df1)2# 查看每个组的大小（Size）- 包含内容多（也就是 rows 多）的组，Size 比较大# 此例中，值为 A 的组和值为 B 的组都包含了两个「行」（rows），即他们的 Size 一样&gt;&gt;&gt; grouped_df1.size()XA    2B    2dtype: int64# .size() 返回的是一个 Series 类型，所以可以用以下方法查看 Size 排名第前 N 或后 N 的 Group&gt;&gt;&gt; s = grouped_df1.size()&gt;&gt;&gt; s.nlargest(1)XA    2dtype: int64&gt;&gt;&gt; s.nlargest(2)XA    2B    2dtype: int64</code></pre></li><li><h4 id="使用-pandas-get-dummies-来对数据进行-One-hot-编码"><a href="#使用-pandas-get-dummies-来对数据进行-One-hot-编码" class="headerlink" title="使用 pandas.get_dummies 来对数据进行 One-hot 编码"></a>使用 pandas.get_dummies 来对数据进行 One-hot 编码</h4><p>在处理数据时，有时需要将数据中的类别信息转换成数字（数字便于计算），人们会给不同类别分别设定一个独立的变量，这些变量就被称为 dummy variables 。以性别为例（性别通常为 2 类），这时就有 2 个变量（two variables），如果是「male」则代表男性的变量值为 1 ，代表女性的变量值为 0 —— 即变量取值组合 (1,0) 为男性，(0,1) 为女性。再比如区分猫狗猪三类，此时就有 3 个变量，变量取值组合 (1,0,0) 为「猫」，(0,1,0) 为「狗」，(0,0,1) 为「猪」。这种编码方式就称为 One-hot 编码 —— 之所以不用单一变量通过取值 0 , 1 和 2 来分别编码猫狗猪，是因为这样会暗含这三个类别具有<strong>相关性</strong>而不是<strong>独立</strong>的<br>这个 <a href="https://www.youtube.com/watch?v=0s_1IsROgDc" target="_blank" rel="noopener">Youtube 视频</a>也介绍了 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.get_dummies.html" target="_blank" rel="noopener">get_dummies</a> 的用法，推荐参考</p><pre><code class="lang-bash"># 使用上文的 acid_df 为例介绍 pandas.get_dummies 用法&gt;&gt;&gt; acid_df     pH    levels0  3.51       low1  3.20      high2  3.26  moderate3  3.01   extreme4  3.16      high# 对 column = &quot;levels&quot; 这一列的值进行编码（该列的值共有 4 种）&gt;&gt;&gt; pd.get_dummies(acid_df[&quot;levels&quot;])   extreme  high  moderate  low0        0     0         0    11        0     1         0    02        0     0         1    03        1     0         0    04        0     1         0    0# 根据传统，编码时要加上前缀（prefix），以进一步说明编码信息# 此外该列的值共有 4 种，但只需要对其中 3 种进行编码就能知道所有信息，所以人们通常会抛弃其中一列# 使用 iloc 切片实现抛弃其中一列 - 取所有行（row），取第 2 列（column）和第 2 列之后的所有列（参考上文对 iloc 的描述）&gt;&gt;&gt; pd.get_dummies(acid_df[&quot;levels&quot;], prefix=&quot;level&quot;).iloc[:, 1:]       level_high  level_moderate  level_low0           0               0          11           1               0          02           0               1          03           0               0          04           1               0          0# 一步实现 5 个操作#「编码指定的所有列（columns）」,「添加前缀（默认添加的是原列名称）」,「切片抛弃」,「整合编码后数据表和原始表 acid_df」和「把原始表 acid_df 中的 &quot;levels&quot; 这一列删除」# 注意，操作后 acid_df 的内容并没有改变，整个操作只是输出一个整合后的表，需要新建变量来保存&gt;&gt;&gt; pd.get_dummies(acid_df, columns=[&quot;levels&quot;], drop_first=True)     pH  levels_high  levels_moderate  levels_low0  3.51            0                0           11  3.20            1                0           02  3.26            0                1           03  3.01            0                0           04  3.16            1                0           0</code></pre></li><li><h4 id="合并两个-DataFrame"><a href="#合并两个-DataFrame" class="headerlink" title="合并两个 DataFrame"></a>合并两个 DataFrame</h4><p>使用 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html" target="_blank" rel="noopener">DataFrame.merge</a> 来合并两个 DataFrame 类型的数据，可以参考<a href="https://pandas.pydata.org/pandas-docs/stable/merging.html#database-style-dataframe-joining-merging" target="_blank" rel="noopener">这里</a>查看 Merge 更详细的规则：</p><pre><code class="lang-bash">## 语法：left_df.merge(right_df, how=&#39;inner&#39;, on=&quot;column_name&quot;)## how=&quot;left&quot; - 合并 column_name 之外的所有列，以左边（left_df）column_name 列的取值为准，在右边（right_df）寻找同样的取值合并，找不到则合并后右列的取值为 NaN## how=&quot;right&quot; - 合并 column_name 之外的所有列，以右边（right_df）column_name 列的取值为准，在左边（left_df）寻找同样的取值合并，找不到则合并后左列的取值为 NaN ## how=&quot;inner&quot; - 在左右的 column_name 列取值相同的行（row），才会合并## how=&quot;outer&quot; - 无论左右的 column_name 一列是否有相同取值的行（row），都会合并，相应的列（column）的值以 NaN 填充## 语言是苍白的，只有尝试几次才能明白，或者查看上述官方文档的链接# 数据一&gt;&gt;&gt; sub_df = pd.DataFrame(...             [[&quot;05-01-11&quot;, 4388333, 2911002, &quot;R003&quot;, 0, 40.689945, -73.872564],...              [&quot;05-02-11&quot;, 4388348, 2911036, &quot;R004&quot;, 1, 40.691320, -73.867135]],...             columns=[&quot;DATEn&quot;, &quot;ENTRIESn&quot;, &quot;EXITSn&quot;, &quot;UNIT&quot;, &quot;hour&quot;, &quot;latitude&quot;, &quot;longitude&quot;]) &gt;&gt;&gt; sub_df      DATEn  ENTRIESn   EXITSn  UNIT  hour   latitude  longitude0  05-01-11   4388333  2911002  R003     0  40.689945 -73.8725641  05-02-11   4388348  2911036  R004     1  40.691320 -73.867135# 数据二&gt;&gt;&gt; wea_df = pd.DataFrame(...             [[&quot;05-01-11&quot;, 0, 40.689945, -73.872564, 30.24],...              [&quot;05-02-11&quot;, 1, 40.691320, -73.867135, 30.32]],...             columns=[&quot;DATEn&quot;, &quot;hour&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;pressurei&quot;])&gt;&gt;&gt; wea_df      DATEn  hour   latitude  longitude  pressurei0  05-01-11     0  40.689945 -73.872564      30.241  05-02-11     1  40.691320 -73.867135      30.32# 合并&gt;&gt;&gt; sub_df.merge(wea_df, on=[&quot;DATEn&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;hour&quot;], how=&quot;inner&quot;)      DATEn  ENTRIESn   EXITSn  UNIT  hour   latitude  longitude  pressurei0  05-01-11   4388333  2911002  R003     0  40.689945 -73.872564      30.241  05-02-11   4388348  2911036  R004     1  40.691320 -73.867135      30.32# 数据三 - date 这一列和 sub_df 中的 DATEn 列名字虽然不同，但描述的是同一个东西&gt;&gt;&gt; wea_df_date      date  hour   latitude  longitude  pressurei0  05-01-11     0  40.689945 -73.872564      30.241  05-02-11     1  40.691320 -73.867135      30.32# 此时我们的合并语法要加上 left_on 和 right_on 这两个参数&gt;&gt;&gt; sub_df.merge(wea_df_date,...           left_on=[&quot;DATEn&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;hour&quot;],...           right_on=[&quot;date&quot;, &quot;latitude&quot;, &quot;longitude&quot;, &quot;hour&quot;],...           how=&quot;inner&quot;)</code></pre></li><li><h4 id="将一个-DataFrame-数据添加到另一个-DataFrame-里"><a href="#将一个-DataFrame-数据添加到另一个-DataFrame-里" class="headerlink" title="将一个 DataFrame 数据添加到另一个 DataFrame 里"></a>将一个 DataFrame 数据添加到另一个 DataFrame 里</h4><p>使用 <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.append.html" target="_blank" rel="noopener">DataFrame.append</a> 来实现添加一个 DataFrame 类型的数据：</p><pre><code class="lang-bash">&gt;&gt;&gt; df_base = pd.DataFrame([[1, 2], [3, 4]], columns=list(&#39;AB&#39;))&gt;&gt;&gt; df_base   A  B0  1  21  3  4&gt;&gt;&gt; df_addition = pd.DataFrame([[5, 6], [7, 8]], columns=list(&#39;Ab&#39;))&gt;&gt;&gt; df_addition   A  b0  5  61  7  8# 添加 df_addition 到 df_base 尾部 - 返回新的 DataFrame 而不改变原来的 df_base&gt;&gt;&gt; df_base.append(df_addition)   A    B    b0  1  2.0  NaN1  3  4.0  NaN0  5  NaN  6.01  7  NaN  8.0# 重命名列的名字（column name）- 默认返回新的 DataFrame，要改动原变量要设置参数 inplace=True&gt;&gt;&gt; df_addition.rename(columns={&quot;b&quot;: &quot;B&quot;})# 参数 columns 也可以接收函数 - 此处多余的 else 是为了展示 lambda 中的完整 if 语法&gt;&gt;&gt; df_addition.rename(columns=lambda x: &quot;B&quot; if x == &quot;b&quot; else x, inplace=True)# 确认两个数据集的列标签相同&gt;&gt;&gt; df_addition.columns == df_base.columnsarray([ True,  True])# 如果数据太多，也可以这样确认 - 当且仅当元素（elements）都为非空，非零或者 True，.all() 返回 True&gt;&gt;&gt; (df_addition.columns == df_base.columns).all()True# 再次合并 - 返回新的 DataFrame 而不改变原来的 df_base&gt;&gt;&gt; df_base.append(df_addition)   A  B0  1  21  3  40  5  61  7  8# 设置 ignore_index=True 即可“解决” index 问题（默认 ignore_index=False），如果这是你想要的效果的话 &gt;&gt;&gt; df_base.append(df_addition, ignore_index=True)   A  B0  1  21  3  42  5  63  7  8</code></pre></li></ul><hr><h3 id="用-Pandas-绘制数据分析图"><a href="#用-Pandas-绘制数据分析图" class="headerlink" title="用 Pandas 绘制数据分析图"></a>用 Pandas 绘制数据分析图</h3><p>Pandas 库里本身就提供的绘制图像的方法（Methods）可以作用于 <strong>Series</strong> 和 <strong>DataFrame</strong> 两种类型的数据上，这些方法（Methods）都是基于常用绘图库 <a href="https://matplotlib.org" target="_blank" rel="noopener">matplotlib</a> 封装的（wrappers around matplotlib functions），所以名字大都和 matplotlib 里的一样。用 Pandas 绘图主要是为了快速可视化，若要更加复杂的分析图，还是得载入 Matplotlib 库（进一步查看<a href="/2018/06/15/matplotlib-cheat-sheet/"> Matplotlib 使用指南</a>）</p><pre><code class="lang-bash"># 生成直方图（histogram）- figsize 参数是设定直方图的大小（即宽高）&gt;&gt;&gt; df.hist(figsize=(8, 8))# 可对 Series 数据类型使用&gt;&gt;&gt; df[&quot;column_name&quot;].hist(figsize=(8, 8))# 生成直方图的另一种方法 - 使用 title 参数添加标题&gt;&gt;&gt; df[&quot;column_name&quot;].plot(kind=&quot;hist&quot;, title=&quot;title_name&quot;)# 如果列的数据类型是 String ，可以配合上述的 .value_counts() 方法统计数字，然后生成图表# 下面 kind=&quot;bar&quot; 是生成柱状图（bar charts）- 注意区别于直方图&gt;&gt;&gt; df[&quot;string_column&quot;].value_counts().plot(kind=&quot;bar&quot;)# 生成饼图（pie chart）&gt;&gt;&gt; df[&quot;string_column&quot;].value_counts().plot(kind=&quot;pie&quot;, figsize=(8, 8))# 同时显示所有变量间的相关关系图（散点图 scatter）和直方图 - 类似锤子科技 TNT 的 Poker Dealer&gt;&gt;&gt; pd.plotting.scatter_matrix(df, figsize=(15, 15))# 显示具体的两个变量的数据图 - 配合上述的 Poker Dealer 全变量显示后&gt;&gt;&gt; df.plot(x=&quot;column_1_name&quot;, y=&quot;column_2_name&quot;, kind=&quot;scatter&quot;)</code></pre><p>PS:<br>如果你用 <a href="http://jupyter.org" target="_blank" rel="noopener">Jupyter notebook</a>，记得加上 <code>% matplotlib inline</code> 以让图标显示在内容流中。<br>如果是在终端里使用 <a href="https://ipython.org" target="_blank" rel="noopener">IPython</a>，则要用 <code>plt.show()</code> 来显示图像：</p><pre><code class="lang-python">import matplotlib.pyplot as pltplt.plot([1,2,3,4])plt.show()</code></pre><hr><h3 id="Axis-参数"><a href="#Axis-参数" class="headerlink" title="Axis 参数"></a>Axis 参数</h3><p>Numpy 里的 Array 类型，Pandas 里的 Series 类型和 DataFrame 类型都通常能设置一个 axis 参数，代表操作方向（是对 column 操作，还是对 row 操作），但每次用的时候都需要先测试一下，才能确保参数值 <code>1</code> 和 <code>0</code> 到底分别代表哪个方向</p><p>对于 Array 类型和 Series 类型：</p><ul><li><p><code>axis = 0</code></p></li><li><p><code>axis = 1</code></p></li></ul><p>对于 DataFrame 类型：</p><ul><li><p><code>axis = 0</code> 或 <code>axis = &quot;index&quot;</code><br>along the index（沿着 index 方向 - 垂直纵向）</p></li><li><p><code>axis = 1</code> 或 <code>axis = &quot;columns&quot;</code><br>along the column（沿着 column 的方向 - 水平横向）</p></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy 进阶（待完善）</title>
      <link href="/2018/09/17/numpy-advanced-features/"/>
      <url>/2018/09/17/numpy-advanced-features/</url>
      
        <content type="html"><![CDATA[<p>在机器学习等相关数据行业中，NumPy 库里经常用到的是 <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html" target="_blank" rel="noopener">ndArray</a> 类型，该类包含了很多方便的函数（方法和函数本质上是同一个东西），下面就详细介绍它们，可通过全文检索来查询</p><hr><h3 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h3><p><a href="/2018/06/01/numpy-and-pandas/">NumPy 和 Pandas 入门</a>一文里已介绍了 Numpy 的安装方式，这里我们终端里进入 Python 的交互式解释器（interactive interpreter）后，将直接载入 Numpy 库</p><pre><code class="lang-bash">$ pythonPython 3.6.5 |Anaconda custom (64-bit)| (default, Apr 26 2018, 08:42:37) [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import numpy as np</code></pre><hr><h3 id="ndArray-类型的常见-Methods"><a href="#ndArray-类型的常见-Methods" class="headerlink" title="ndArray 类型的常见 Methods"></a>ndArray 类型的常见 Methods</h3><pre><code class="lang-bash">## shape - 查看线性空间的维度（注意观察以下 3 个例子的 shape 输出区别&gt;&gt;&gt; tensor_0 = np.array(5)&gt;&gt;&gt; tensor_0.shape()     ## 零维张量（zero dimensional Tensor），即标量（Scalar）&gt;&gt;&gt; tensor_1 = np.array([1, 2, 3, 4])&gt;&gt;&gt; tensor_1.shape(4,)   ## 一维张量（one dimensional Tensor），即矢量（Vector）—— 注：Python 不能将 (4) 识别为具有一个项的元组（tuple），所以它需要逗号，类似 1 被识别为 int ，1. 则被识别为 float  &gt;&gt;&gt; tensor_2 = np.array([[1], [2], [3], [4]])&gt;&gt;&gt; tensor_2.shape(4, 1) ## 二维张量（two dimensional Tensor），即矩阵（Matrix）&gt;&gt;&gt; tensor_4 = np.array([[[[1],[2]],[[3],[4]],[[5],[6]]],[[[7],[8]],\...     [[9],[10]],[[11],[12]]],[[[13],[14]],[[15],[16]],[[17],[17]]]])&gt;&gt;&gt; tensor_3.shape(3, 3, 2, 1)  ## 四维张量（four dimensional Tensor）) —— 维度大于 2 的，全部统一称为 Tensor## 注意 numpy 的 ndArray 类型是传「址」的，不是传「值」的## 要用 numpy.copy() 来传「值」&gt;&gt;&gt; tensor_1_addr = tensor_1&gt;&gt;&gt; tensor_1_value = np.copy(tensor_1)&gt;&gt;&gt; tensor_1[3]=1&gt;&gt;&gt; tensor_1[0]=4&gt;&gt;&gt; tensor_1array([4, 2, 3, 1])&gt;&gt;&gt; tensor_1_addr     ## 更改 tensor_1 之后，tensor_1_addr 随之改变array([4, 2, 3, 1])&gt;&gt;&gt; tensor_1_value    ## 更改 tensor_1 之后，tensor_1_value 不受影响array([1, 2, 3, 4])## 计算平均值&gt;&gt;&gt; np.mean(tensor_1)2.5## 计算最大值&gt;&gt;&gt; np.amax(tensor_1)4## 计算最大值所对应的 index（tensor_1[3] 是 array 中的最大值 4）&gt;&gt;&gt; np.argmax(tensor_1)3## 计算最小值&gt;&gt;&gt; np.amin(tensor_1)1## 计算中位数&gt;&gt;&gt; np.median(tensor_1)2.5## 计算标准差 - ddof 参数代表贝塞尔校正，当用样本标准差估算总体标准差的时候需要调整求平均时的分母（通常调整为 N-1）## ddof 参数默认值为 0 ，代表分母使用的是数据的总量 N ，更准确的来说分母是（N - ddof），当 ddof = 0 分母为 N## The divisor used in calculations is (N - ddof), where N represents the number of elements.  &gt;&gt;&gt; np.std(tensor_1, ddof=0)1.118033988749895&gt;&gt;&gt; items = [1, 2, 3, 4, 5]## 计算自然对数的底 e 的幂 - 即 2.71828... 的幂&gt;&gt;&gt; np.exp(1)2.718281828459045&gt;&gt;&gt; np.exp(items)  # 注意输入类型是 list , 返回的类型则是 ndArrayarray([  2.71828183,   7.3890561 ,  20.08553692,  54.59815003,       148.4131591 ])## 计算自然对数的值 - 即以 2.71828... 为底的对数的值&gt;&gt;&gt; np.e2.718281828459045&gt;&gt;&gt; np.log(np.e)1.0## 将两个 ndArray 类型简单首尾连接结合在一起&gt;&gt;&gt; np.append(tensor_1_addr, tensor_1_value)array([4, 2, 3, 1, 1, 2, 3, 4])</code></pre><hr><h3 id="ndArray-类型的矩阵相关计算"><a href="#ndArray-类型的矩阵相关计算" class="headerlink" title="ndArray 类型的矩阵相关计算"></a>ndArray 类型的矩阵相关计算</h3><pre><code class="lang-bash">&gt;&gt;&gt; matrx_a = np.array([[1,2,3,4],[5,6,7,8]])&gt;&gt;&gt; matrx_aarray([[1, 2, 3, 4],       [5, 6, 7, 8]])&gt;&gt;&gt; matrx_b = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])&gt;&gt;&gt; matrx_barray([[ 1,  2,  3],       [ 4,  5,  6],       [ 7,  8,  9],       [10, 11, 12]])## 矩阵的转置 - 返回的是新索引，共享相同的数据（同一内存地址），要谨慎修改## NumPy 在进行转置时不会实际移动内存中的任何数据，只是改变对原始矩阵的索引方式&gt;&gt;&gt; matrx_b.Tarray([[ 1,  4,  7, 10],       [ 2,  5,  8, 11],       [ 3,  6,  9, 12]])## 矩阵的元素级计算（注意区别于矩阵的乘法）&gt;&gt;&gt; matrx_a * 0.25array([[0.25, 0.5 , 0.75, 1.  ],       [1.25, 1.5 , 1.75, 2.  ]])## 找出矩阵中所有元素的最大值&gt;&gt;&gt; np.nanmax(matrx_a)8## 向量点积&gt;&gt;&gt; a = [[1, 0], [0, 1]]&gt;&gt;&gt; b = [[4, 1], [2, 2]]&gt;&gt;&gt; np.dot(a, b)array([[4, 1],       [2, 2]])## 矩阵的乘法&gt;&gt;&gt; np.matmul(matrx_a, matrx_b)array([[ 70,  80,  90],       [158, 184, 210]])## 使用 reshape() 调整矩阵形状，以便进行矩阵的乘法&gt;&gt;&gt; matrx_a.reshape([1,8])array([[1, 2, 3, 4, 5, 6, 7, 8]])&gt;&gt;&gt; matrx_a.reshape([8,1])array([[1],       [2],       [3],       [4],       [5],       [6],       [7],       [8]])## 创建一个和矩阵 matrx_a 相同行数和列数的新矩阵，并以 0 填充&gt;&gt;&gt; np.zeros_like(matrx_a)array([[0, 0, 0, 0],       [0, 0, 0, 0]])</code></pre><hr><h3 id="ndArray-类型的风骚操作"><a href="#ndArray-类型的风骚操作" class="headerlink" title="ndArray 类型的风骚操作"></a>ndArray 类型的风骚操作</h3><pre><code class="lang-bash">## 根据另一个 list 里的 True 或 False（真假布尔值）来选出指定 list 里的元素## True 或 False（真假布尔值）的 list 里的元素也可以是 0 和 1（0 在 python 中是 False，1 是 True）&gt;&gt;&gt; from itertools import compress   # 载入 intertools 库里的 compress 函数&gt;&gt;&gt; list_a = [1, 2, 4, 6]&gt;&gt;&gt; fil = [True, False, True, False]&gt;&gt;&gt; list(compress(list_a, fil))[1, 4]</code></pre><hr><h3 id="Axis-参数"><a href="#Axis-参数" class="headerlink" title="Axis 参数"></a>Axis 参数</h3><p>Numpy 里的 Array 类型，Pandas 里的 Series 类型和 DataFrame 类型都通常能设置一个 axis 参数，代表操作方向（是对 column 操作，还是对 row 操作），但每次用的时候都需要先测试一下，才能确保参数值 <code>1</code> 和 <code>0</code> 到底分别代表哪个方向</p><p>对于 Array 类型和 Series 类型：</p><ul><li><p><code>axis = 0</code></p></li><li><p><code>axis = 1</code></p></li></ul><p>对于 DataFrame 类型：</p><ul><li><p><code>axis = 0</code> 或 <code>axis = &quot;index&quot;</code><br>along the index（沿着 index 方向 - 垂直纵向）</p></li><li><p><code>axis = 1</code> 或 <code>axis = &quot;columns&quot;</code><br>along the column（沿着 column 的方向 - 水平横向）</p></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib 使用指南</title>
      <link href="/2018/06/15/matplotlib-cheat-sheet/"/>
      <url>/2018/06/15/matplotlib-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p>Matplotlib 是 python 世界里常用的绘图函数库，包含很多好用的方法，此处只展示几个简单的示例，更多绘图方式参见<a href="https://pandas.pydata.org/pandas-docs/stable/visualization.html" target="_blank" rel="noopener">这里</a></p><hr><h3 id="示例1-用-Matplotlib-创建柱状图"><a href="#示例1-用-Matplotlib-创建柱状图" class="headerlink" title="示例1 - 用 Matplotlib 创建柱状图"></a>示例1 - 用 Matplotlib 创建柱状图</h3><pre><code class="lang-python">import matplotlib.pyplot as pltimport seaborn as sns    # seaborn 的载入是为了让图像更好看，通常都会搭配 matplotlib.pyplot 一同载入使用</code></pre><p>pyplot 的 <a href="https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.bar" target="_blank" rel="noopener">bar</a> 功能中有两个必要参数：条柱的 x 坐标和条柱的高度。</p><pre><code class="lang-python">plt.bar([1, 2, 3], [224, 620, 425])</code></pre><p>可以利用 pyplot 的 <code>xticks</code> 功能，或通过在 <code>bar</code> 功能中指定另一个参数，指定 x 轴刻度标签。以下两个框的结果相同。</p><pre><code class="lang-python"># 绘制条柱plt.bar([1, 2, 3], [224, 620, 425])# 为 x 轴指定刻度标签及其标签plt.xticks([1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></pre><pre><code class="lang-python"># 用 x 轴的刻度标签绘制条柱plt.bar([1, 2, 3], [224, 620, 425], tick_label=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code></pre><p>用以下方法设置轴标题和标签。</p><pre><code class="lang-python">plt.bar([1, 2, 3], [224, 620, 425], tick_label=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])plt.title(&#39;Some Title&#39;)plt.xlabel(&#39;Some X Label&#39;)plt.ylabel(&#39;Some Y Label&#39;)</code></pre><hr><h3 id="示例2-折线图（设定-x-和-y-更一般性的作图）"><a href="#示例2-折线图（设定-x-和-y-更一般性的作图）" class="headerlink" title="示例2 - 折线图（设定 x 和 y 更一般性的作图）"></a>示例2 - 折线图（设定 x 和 y 更一般性的作图）</h3><pre><code class="lang-python"># 用合适的标签创建线图y_axis = df.groupby(&#39;acidity_levels&#39;)[&quot;quality&quot;].mean()labels = [&#39;Extreme&#39;, &#39;High&#39;, &#39;Moderate&#39;, &#39;Low acidic&#39;]x_axis = range(len(labels))plt.plot(x_axis, y_axis)plt.title(&#39;Average Quality Ratings by Acidic Levels&#39;)plt.xlabel(&#39;Acidic Levels&#39;)plt.ylabel(&#39;Average Quality Rating&#39;);plt.xticks(x_axis, labels);      # 设定 x 轴上的标签（不是 x 轴变量的名字，而是把原先 x_axis 的每个值对应地换成相应的 label）</code></pre><hr><h3 id="示例3-柱状图（Bar-chart）"><a href="#示例3-柱状图（Bar-chart）" class="headerlink" title="示例3 - 柱状图（Bar chart）"></a>示例3 - 柱状图（Bar chart）</h3><pre><code class="lang-python"># genre_counts 的类型是 Series&#39;&#39;&#39;genre_counts :    Action             57    Adventure          56    Science Fiction    41    Thriller           31    Fantasy            28    Drama              28    Family             20    Crime              15    Comedy             13    Animation           7    Mystery             7    War                 4    Western             3    Romance             2    Horror              2    History             1    dtype: int64&#39;&#39;&#39;labels = list(genre_counts.index)# 使用 pandas 自带的 .plot() 快速出图后，再用 plt 进行细节设置genre_counts.plot(kind=&quot;bar&quot;, title=&quot;Top Popular Movie Genres&quot;);plt.xlabel(&#39;Genre&#39;)plt.ylabel(&#39;Movies Count&#39;);</code></pre><hr><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><pre><code class="lang-python"># 设置显示说明图例（legend）plt.legend()# 设置好各种参数后，用以下指令生成图像plt.show()</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy 和 Pandas 入门</title>
      <link href="/2018/06/01/numpy-and-pandas/"/>
      <url>/2018/06/01/numpy-and-pandas/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://docs.scipy.org/doc/numpy/user/quickstart.html" target="_blank" rel="noopener">numpy</a> - Numerical Python 和 <a href="https://pandas.pydata.org" target="_blank" rel="noopener">pandas</a> - Python Data Analysis Library 是 Python 语言处理数据时常用的两个库，专门用来进行诸如线性代数方面的计算。通过 Python 的库管理软件 Anaconda 等可以很容易地安装（进一步查看<a href="/2018/05/27/set-up-anaconda/">安装和配置 Anaconda </a> ）</p><pre><code class="lang-bash">## 同时安装 numpy 和 pandas 两个软件包（Packages）- 左边的 (py3) 表示当前处于 Anaconda 的虚拟环境 py3 中(py3) $ conda install numpy pandas</code></pre><pre><code class="lang-python"># 载入 numpy 和 pandas - 演示文件 ~/demo_script.py import pandas as pdimport numpy as np# code block......</code></pre><p>NumPy 和 Pandas 包含很多好用的东西，这里只介绍常用的几个数据类型和相应的函数，更多风骚操作还是得看官方文档和 Google 。</p><p>PS：<br>为了在描述过程中区分 numpy 里的 ndArray 数据类型和 Pandas 里的 Series 类型，下文对于 ndArray 将使用 <strong>position</strong> 来称呼它的引用，而对于 Series 则用 <strong>index</strong> （Series 也有 <strong>position</strong>）。你将很快看到两者的不同。</p><hr><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>使用 NumPy 和 Pandas 这两个库时，通常是使用里面的三个数据类型：</p><ul><li>NumPy 里的 <strong>ndArray</strong> 类型（也常被非官方地说成 Numpy 的 Array 类型）</li><li>Pandas 里的 <strong>Series</strong> 类型</li><li>Pandas 里的 <strong>DataFrame</strong> 类型 - 其中每列 (column) 都是一个 Series</li></ul><p>这些数据类型包含了常见的分析计算数据的方法 (methods)，其计算数据的速度比 Python 自带的 list 等类型要快，以下是它们的特点和区别：</p><ol><li>NumPy 里的 <strong>ndArray</strong> 类型要求其中储存的<strong>数据类型必须一致</strong>，所以它主要用来处理大规模类型相同的 2 维或多维数据；</li><li>Pandas 里的 <strong>Series</strong> 类型也要求其中储存的<strong>数据类型必须一致</strong>，不过它储存的数据是一维的；</li><li>Pandas 里的 <strong>DataFrame</strong> 类型允许各个列 (column) 之间的<strong>数据类型不同</strong>（同列数据得相同）- 它的每个列可以看成一个独立的 <strong>Series</strong>；</li></ol><hr><p>要进一步查询 NumPy 使用方法，除了<a href="https://pandas.pydata.org/pandas-docs/stable/" target="_blank" rel="noopener"> NumPy 官方文档</a>，还可参看 <a href="/2018/09/17/numpy-advanced-features/">Numpy 进阶</a></p><p>要进一步查询 Pandas 使用方法，除了<a href="https://docs.scipy.org/doc/numpy/user/quickstart.html" target="_blank" rel="noopener"> Pandas 官方文档</a>，还可参看 <a href="/2018/09/17/pandas-advanced-features/">Pandas 进阶</a></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter Notebook 简易指南</title>
      <link href="/2018/05/28/introduce-jupyter-notebook/"/>
      <url>/2018/05/28/introduce-jupyter-notebook/</url>
      
        <content type="html"><![CDATA[<h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><p><a href="http://jupyter.org/" target="_blank" rel="noopener">Jupyter notebook</a> 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中，其架构如下：<br><img src="https://jupyter.readthedocs.io/en/latest/_images/notebook_components.png" alt="Jupyter notebook 的架构说明图"></p><p>可看到该架构核心是 Notebook 服务器（Server）。你通过浏览器连接到该服务器，而 Notebook 呈现为 Web 应用。你在 Web 应用中编写的代码通过该服务器发送给内核，内核运行代码，并将结果发送回该服务器。之后，任何输出都会返回到浏览器中。保存 Notebook 时，它将作为 JSON 文件（文件扩展名为 <code>.ipynb</code>）写入到该服务器中。</p><p>因此，你可以在任何地方运行 notebook 服务器，并且可通过互联网访问，或者分享给他人。</p><hr><h3 id="安装-Jupyter-notebook"><a href="#安装-Jupyter-notebook" class="headerlink" title="安装 Jupyter notebook"></a>安装 Jupyter notebook</h3><p>我们一般通过终端里运行 <code>conda install jupyter notebook</code> 命令来安装，至于 conda 是什么？如何隔离开不同项目（Project）的开发环境？请参考<a href="/2018/05/27/set-up-anaconda/">安装和配置 Anaconda</a></p><pre><code class="lang-bash">## 此处假定你已经安装设置好了 anaconda ## 最左边的 (py36) 显示的是目前所处的开发环境名，参考上面的链接中关于 conda 新建虚拟开发环境的说明(py36) $ conda install jupyter notebookSolving environment: done## Package Plan ##  environment location: /anaconda3/envs/py36  added / updated specs:    - jupyter    - notebookThe following NEW packages will be INSTALLED:    ...    ...Proceed ([y]/n)? yPreparing transaction: doneVerifying transaction: doneExecuting transaction: done(py36) $</code></pre><hr><h3 id="启动-Notebook-服务器"><a href="#启动-Notebook-服务器" class="headerlink" title="启动 Notebook 服务器"></a>启动 Notebook 服务器</h3><p>在终端中输入 <code>jupyter notebook</code>，服务器就会在你运行此命令的目录中启动，这意味着任何 notebook 文件都会保存在该目录下</p><pre><code class="lang-bash">## 查看当前所在目录(py36) $ pwd/Users/user1/Documents/Udacity_Class/temp_test## 启动 notebooke 服务器 - 此例子里，服务器运行地址是 http://localhost:8888## 注意当前所处的环境是 py36 ，notebooke 服务器会使用当前所在环境里的 packages(py36) $ jupyter notebook[I 06:07:23.978 NotebookApp] Writing notebook server cookie secret to /Users/user1/Library/Jupyter/runtime/notebook_cookie_secret[I 06:07:24.147 NotebookApp] Serving notebooks from local directory: /Users/user1/Documents/Udacity_Class/temp_test[I 06:07:24.147 NotebookApp] 0 active kernels[I 06:07:24.147 NotebookApp] The Jupyter Notebook is running at:[I 06:07:24.147 NotebookApp] http://localhost:8888/?token=479961dc55f3f37e3885c81bc4de0cfea8c78d51713d7c21[I 06:07:24.147 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).[C 06:07:24.148 NotebookApp]</code></pre><p>打开浏览器，输入服务器地址 <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> 后，进入即可开始使用。若要关掉 Notebook，只需在刚刚的终端里使用 <code>Control + C</code> 组合键终止服务器。</p><hr><h3 id="Jupyter-Notebook-中的数学表达式"><a href="#Jupyter-Notebook-中的数学表达式" class="headerlink" title="Jupyter Notebook 中的数学表达式"></a>Jupyter Notebook 中的数学表达式</h3><p>在 Notebook 的 Markdown 单元格中，可以使用 <a href="https://www.latex-project.org" target="_blank" rel="noopener">LaTeX</a> 符号创建数学表达式。notebook 使用 MathJax 将 LaTeX 符号呈现为数学符号</p><pre><code>## 创建「内联（inline）」性质的数学表达式 - 首尾无换行符号$y = mx + b$## 创建「块（block）」性质的数学表达式 - 首尾添加换行符号$$y = \frac{a}{b+c}$$</code></pre><p>关于 LaTex 的更多常用语法请参考 <a href="http://data-blog.udacity.com/posts/2016/10/latex-primer/" target="_blank" rel="noopener">A Primer on Using LaTeX in Jupyter Notebooks</a>（写得挺好的，所以尽管原文页面已无法访问，还是写出来做个纪念。网上能搜到该文，我的 Dropbox 里也有保存），详细一些的可参看这篇 <a href="https://docs.latexbase.com" target="_blank" rel="noopener">Online LaTeX reference</a> ，更加全面的信息可以参考这个 <a href="http://ctan.math.ca/tex-archive/obsolete/info/math/voss/mathmode/Mathmode.pdf" target="_blank" rel="noopener">PDF 文件</a>（尽管该文件似乎有些久远）</p><hr><h3 id="Magic-关键字"><a href="#Magic-关键字" class="headerlink" title="Magic 关键字"></a>Magic 关键字</h3><p>Magic 关键字是可以在单元格中运行的特殊命令，能让你控制 notebook 本身或执行系统调用（例如更改目录）。例如，在 notebook 中可以使用 <code>%matplotlib</code> 将 matplotlib（python 的一个绘图库） 设置为以交互方式工作。</p><p>Magic 命令的前面带有一个或两个百分号（<code>%</code> 或 <code>%%</code>），分别对应「<strong>行 Magic 命令</strong>」和「<strong>单元格 Magic 命令</strong>」。「<strong>行 Magic 命令</strong>」仅应用于编写 Magic 命令时所在的行，而「<strong>单元格 Magic 命令</strong>」应用于整个单元格。</p><p><strong><em>注意：</em></strong><br><em>这些 Magic 关键字是特定于普通 Python 内核的关键字。如果使用其他内核，这些关键字很有可能无效。</em></p><ul><li><p><strong>示例一：运行计时器</strong><br>有时候，你可能希望让代码运行得更快，可以使用 Magic 命令 <code>%timeit</code> 测算代码的运行时间</p><ol><li><p>使用 <code>%timeit</code> 测算某个命令的运行时间：<img src="/2018/05/28/introduce-jupyter-notebook/inline-timeit.png" title="inline timeit"></p></li><li><p>使用 <code>%%timeit</code> 来测算整个单元格的运行时间：<img src="/2018/05/28/introduce-jupyter-notebook/block-timeit.png" title="block timeit"></p></li></ol></li><li><p><strong>示例二：在 notebook 中嵌入可视化内容</strong><br>notebook 允许你将图像与文本和代码一起嵌入。这在你使用 matplotlib 或其他绘图包创建可视化内容时最为有用。在 notebook 中可以使用 <code>%matplotlib</code> 将 matplotlib 设置为以交互方式工作。默认情况下，图形呈现在各自的窗口中。但是，你可以通过命令传递参数，以选择特定的<a href="http://matplotlib.org/faq/usage_faq.html#what-is-a-backend" target="_blank" rel="noopener">后端</a>（呈现图像的软件）。要直接在 notebook 中呈现图形，应将通过命令 <code>%matplotlib inline</code> 内联后端一起使用 <img src="/2018/05/28/introduce-jupyter-notebook/matplotlib-inline.png" title="matplotlib inline"></p></li></ul><p><strong><em>提示</em></strong>：<br>在分辨率较高的屏幕（例如 Retina 显示屏）上，notebook 中的默认图像可能会显得模糊。可以在 <code>%matplotlib inline</code> 之后使用 <code>%config InlineBackend.figure_format = &#39;retina&#39;</code> 来呈现分辨率较高的图像。</p><hr><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>在 Notebook 里使用库 <a href="https://matplotlib.org" target="_blank" rel="noopener">matplotlib</a> 时：</p><ol><li><p>添加 <code>%matplotlib inline</code> 后可在 Notebook 内容流上显示图表（符号 <code>%</code> 带一串命令在 Notebook 里被称为 <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">magic commands</a>）</p></li><li><p>在代码末尾添加分号 <code>;</code> 可以隐藏输出，参考<a href="https://stackoverflow.com/questions/25790062/how-to-hide-matplotlib-lines-line2d-in-ipython-notebook" target="_blank" rel="noopener">这里</a></p></li><li><p>如果 notebook 中的代码需要和其他网站交互，比如载入 IMDb 网站的数据，但是这些网站由于各种原因无法直接访问，可以尝试在启动 Notebook 服务器的命令前加上一个代理命令，表示该服务器在代理环境下打开，享受上网代理的流量端口：</p><pre><code class="lang-bash">## 注意，代理服务器需要自己进行额外配置，myproxy 这个命令也是自行设置命名的，并不是系统自带命令，比如有些玩家可能用的是 proxychains4  $ myproxy jupyter notebook  ## 在配置好的代理环境中运行 notebook</code></pre></li></ol><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装和配置 Anaconda</title>
      <link href="/2018/05/27/set-up-anaconda/"/>
      <url>/2018/05/27/set-up-anaconda/</url>
      
        <content type="html"><![CDATA[<h3 id="Anaconda-简介"><a href="#Anaconda-简介" class="headerlink" title="Anaconda 简介"></a>Anaconda 简介</h3><p><strong>Anaconda</strong> 是一个软件分发平台（distribution of software），自带了 <strong>conda</strong> 这个管理环境和软件包的工具，是数据分析行业里常用的工具之一（管理各种工具的工具）。</p><p>不过 <strong>Anaconda</strong> 这个平台上的软件都是专门针对数据分析的，通常会结合 Python 更加一般性的 packages 管理工具 <strong>pip</strong> 来使用，以便能接触到（access）更多的软件和工具。</p><p><strong>Anaconda</strong> 的作用：</p><ol><li>每个项目（Project）有其对应的运行环境，人们用其中的 <strong>conda</strong> 隔离开不同项目的环境，以免相互冲突；</li><li>方便人们下载各种数据分析所需要的库（Libraries）和软件包（Packages），类似软件商店；</li></ol><hr><h3 id="安装-Anaconda-Windows"><a href="#安装-Anaconda-Windows" class="headerlink" title="安装 Anaconda - Windows"></a>安装 Anaconda - Windows</h3><p>Windows 下的 Anaconda 只需去官网下载对应的<a href="https://www.anaconda.com/download/#windows" target="_blank" rel="noopener">软件包</a> ，根据提示安装即可。安装完成打开后是可视化的操作界面，「新建环境」和「安装软件包函数库」都可以使用可视化界面操作完成，唯一要注意的是网络方面如果使用代理上网，或者系统防火墙防护级别过高等，会导致 Anaconda 打开之后卡死在 loading application 这一状态。这时只需要取消代理，或者关掉防火墙即可解决，参见<a href="https://github.com/ContinuumIO/anaconda-issues/issues/9864" target="_blank" rel="noopener">这里</a>。</p><hr><h3 id="安装-Anaconda-macOS"><a href="#安装-Anaconda-macOS" class="headerlink" title="安装 Anaconda - macOS"></a>安装 Anaconda - macOS</h3><p>到 <a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">Anaconda 官网</a> 下载 macOS 系统对应的软件包（一般选择 Python 3.x version 的），然后根据提示安装。</p><p>安装好之后，打开终端 Terminal 查看</p><pre><code class="lang-bash">## 查看 conda 的版本$ conda --versionconda 4.5.4## 查看 python 的版本 - 安装 Anaconda 不会影响 Mac 电脑里之前安装的 Python ，不过系统默认使用的 Python 会变成 Anaconda 自带的那个版本$ python --versionPython 3.6.4 :: Anaconda, Inc.</code></pre><p>PS:<br>虽然 Anaconda 的安装默认会设置 Bash Shell 的环境变量，但若系统仍提示找不到 <code>conda</code> 命令（command not found），则要使用命令 <code>echo $PATH</code> 看路径 <code>/anaconda3/bin/</code> 是否在环境变量 $PATH 里，不在就要自行添加，这样才能顺利识别相关命令</p><p>若终端用的是 <a href="https://fishshell.com" target="_blank" rel="noopener">Fish Shell</a> ，添加 Anaconda 路径到环境变量的方式如下：</p><pre><code class="lang-bash">## 以下命令会将 Anaconda 的路径 /anaconda3/bin/ 添加到 $fish_user_paths ，进而添加到 $PATH 这个环境变量里$ set -U fish_user_paths /anaconda3/bin/ $fish_user_paths## 添加路径之后就能正确识别 conda 这个命令了$ conda --versionconda 4.5.4## 如果 Anaconda 和 Homebrew 的软件冲突（比如 Curl），可注销 $fish_user_paths 中的 /anaconda3/bin/ 路径来暂时隔离开 Anaconda## 变量 $fish_user_paths 是一个 list ，第一个元素是 fish_user_paths[1]$ echo $fish_user_paths/anaconda3/bin/$ set --erase --universal fish_user_paths[1]</code></pre><p>此外还需参考 <code>/anaconda3/etc/fish/conf.d/conda.fish</code> 文件的注释设置 <code>~/.config/fish/config.fish</code> 文件，才能够在 Fish Shell 里使用 <code>conda activate [环境名]</code> 激活或切换进入指定环境，使用 <code>conda deactivate</code> 来退出当前环境，进入 <strong>base</strong> 环境（即初始的基本环境）。<br>推荐参考 Github 上的这个 <a href="https://github.com/kalefranz/conda/blob/5dd547f754a52350199dcc975848c1969d6c8931/shell/conda.fish" target="_blank" rel="noopener"><code>conda.fish</code></a> 来调整 Anaconda 自带的 conda.fish 文件，比如设置环境名（env name）显示在左侧。</p><p>PS:<br>Bash Shell 用的是 <code>source activate [环境名]</code> 进入环境，见下文。在 Fish Shell 中，<code>source</code> 这个关键词被占用了，所以只能换别的，默认设置是换成 <code>conda</code></p><hr><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>为了保证下载速度，可考虑设置的是 Anaconda 的软件下载源，即编辑 <code>~/.condarc</code> 文件，添加相应的镜像地址，否则每次下载都会访问默认的国外网站下载软件，速度可能会因此很慢。不过如果设置了国内的镜像地址，软件版本可能会滞后于世界。所以设置与否，看个人情况而定。</p><pre><code class="lang-bash">## 使用 vi 编辑 .condarc 文件 - 你也可以使用其他方式编辑$ vi ~/.condarc## 编辑后的 .condarc 文件内容如下 - 这里添加的是清华大学的软件镜像地址，通常会比世界滞后两个代$ cat ~/.condarcchannels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - defaultsshow_channel_urls: truessl_verify: true</code></pre><hr><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p>一开始我们所处的是 conda 的默认环境（default conda environment），建议经常升级该默认环境，可以避免一些 Bug 和错误</p><pre><code class="lang-bash">## 升级 conda 本身$ conda update conda## 升级 conda 旗下所有可升级的软件（包括 conda 本身）- 虽然此命令包括 conda 本身的升级，但建议先运行上一命令单独升级 conda 之后再运行这个升级全部，因为有用户直接升级全部软件时会报错 $ conda update --all$ conda upgrade --all  # conda upgrade is Alias for conda update</code></pre><p>接着是 Anaconda 基本的工作流程</p><pre><code class="lang-bash">## 新建一个环境，指定该环境中你希望安装的 Packages ，以便之后在此环境中开发某项目$ conda create -n [环境名称] [Package 1] [Package 2] [Package 3] ...## Examples - 一个 hyphen 代表缩写（如例子里的 -n），两个 hyphens 代表全称（如例子里的 --name）$ conda create -n my_env numpy$ conda create --name py3 python=3.6 numpy pandas    ## 还可以指定所用 Python 或者 Package 的版本</code></pre><p>使用 <code>activate</code> 和 <code>deactivate</code> 来进入和切换不同的环境。特别地，在 Windows 系统下，<code>activate</code> 一个新环境之前，最好先 <code>deactivate</code> 当前环境，参见<a href="https://conda.io/docs/user-guide/tasks/manage-environments.html#deactivating-an-environment" target="_blank" rel="noopener">这里</a></p><pre><code class="lang-bash">## 进入（或者说切换到）某个环境里 - 注意 fish shell 参照上面的官方设置后，命令是 conda activate（没有 source）$ source activate [环境名称]## Example - 切换后，提示符钱的括号里的内容会显示当前所在的环境名称$ source activate tea_facts(tea_facts) $## 离开（或者说注销）某个环境里 - 注意 fish shell 里是 conda deactivate（没有 source）(tea_facts) $ source deactivate$## 离开（或者说注销）tea_facts 环境后，进入 py3 环境$ source activate py3(py3) $</code></pre><p>接下来就是在环境中安装各种软件库。此过程中， Conda 会自动安装对应的依赖项。例如 <code>pandas</code> 依赖于 <code>numpy</code>（需要有 numpy 才能使用），则安装 <code>pandas</code> 时会同时安装 <code>numpy</code>（如果它之前没被安装的话），即 <code>conda install pandas</code> 和 <code>conda install numpy pandas</code> 的效果一样</p><pre><code class="lang-bash">## 查看当前所处环境 py3 中安装的所有软件 - 会输出一个目录列表用以查看(py3) $ conda list## 查看是否安装了名字含有 &quot;notebook&quot; 的 pakage(py3) $ conda list | grep -ir &quot;notebook&quot;(standard input):notebook         5.5.0           py3_0## 在当前环境 py3 里安装所需的软件包（Package）- 此安装命令是幂等的，即多次运行相同的安装命令安装相同的 Package，效果和运行一次一样  (py3) $ conda install numpy(py3) $ conda install jupyter notebook  # 注意 jupyter notebook 是两个软件包，而不是一个## 也可以同时安装多个软件包（Packages）- 下面安装的是常用的深度学习软件包组合(py3) $ conda install numpy pandas jupyter notebook matplotlib pillow tqdm scikit-learn ## 还可以指定所装软件包的版本(py3) $ conda install numpy=1.10## 卸载软件(py3) $ conda remove numpy## 更新软件(py3) $ conda update numpy## 搜索名字包含 beautifulsoup 字符串的软件(py3) $ conda search &#39;*beautifulsoup*&#39;</code></pre><p>PS:<br>一些库或者框架除了可以使用 <code>conda search</code> 之外，还可以去 <a href="https://anaconda.org/conda-forge" target="_blank" rel="noopener">conda-forge</a> 查看安装方法，比如 <a href="https://anaconda.org/conda-forge/tensorflow" target="_blank" rel="noopener">TensorFlow</a> 的安装；</p><hr><h3 id="软件重复问题"><a href="#软件重复问题" class="headerlink" title="软件重复问题"></a>软件重复问题</h3><p>有时候，我们会遇到开发环境中有两个不同版本的软件库：<a href="https://stackoverflow.com/questions/43253884/conda-showing-two-versions-of-requests-library" target="_blank" rel="noopener">Conda showing two versions of library</a></p><pre><code class="lang-bash">## 当前环境安装了两个不同版本的 tensorflow ，一个来源是 pip ，另一个则是 conda-forge(py3) $ conda list | grep -ir &quot;tensorflow&quot;(standard input):tensorflow       1.0.0          &lt;pip&gt;(standard input):tensorflow       1.10.0        py35_0    conda-forge</code></pre><p>为了避免问题，我们希望只留其中一个，此处是留使用 conda 安装的那个：</p><pre><code class="lang-bash">## 这里要按顺序移除，然后再重装，如果不按顺序，问题会得不到解决## 第一步，先移除 conda 的 tensorflow(py3) $ conda remove tensorflow## 第二步，移除 pip 的 tensorflow(py3) $ pip uninstall tensorflow## 第三步，重新安装 conda 的 tensorflow(py3) $ conda install -c conda-forge tensorflow## 查看确认(py3) $ conda list | grep -ir &quot;tensorflow&quot;(standard input):tensorflow       1.10.0        py35_0    conda-forge</code></pre><hr><h3 id="导出环境配置"><a href="#导出环境配置" class="headerlink" title="导出环境配置"></a>导出环境配置</h3><p>将配置清单保存成 <code>.yml</code> 文件分享给他人能让对方快速搭建出一模一样的运行环境，以便测试和运行我们的代码</p><pre><code class="lang-bash">## 导出当前环境的配置清单，并储存到当前目录下的 environment.yml 文件里(py3) $ conda env export &gt; environment.yml## 导入 environment.yml 文件，读取里面的配置信息，并依照该配置创建一个环境## 新建的环境名由 .yml 配置文件中的第一行设定（比如文件第一行是 name: aind-dl，则新环境名为 aind-dl）$ conda env create -f environment.yml## 查看所有环境 - 输出一个列表形式的结果，默认环境的名字叫做 root$ conda env list## 删除一个环境$ conda env remove -n env_name</code></pre><p>当我们将代码分享在 Github 上的时候，要同时附上 Anaconda 的环境的配置清单文件 <code>*.yml</code> ，甚至要再加上一个 pip 的配置文件 <code>requirements.txt</code> （用 <a href="https://pip.pypa.io/en/stable/reference/pip_freeze/" target="_blank" rel="noopener"><code>pip freeze</code></a> 命令输出该配置文件），以便他人能快速配置出相应的环境，运行我们的代码。</p><hr><p>有关 Anaconda 的更多操作，还可以参考：</p><ul><li><a href="https://www.jianshu.com/p/d2e15200ee9b" target="_blank" rel="noopener">Anaconda 多环境多版本 Python 配置指导</a></li><li><a href="https://foofish.net/compatible-py2-and-py3.html" target="_blank" rel="noopener">用 Anaconda 完美解决 Python2 和 python3 共存问题</a></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上手 Visual Studio Code</title>
      <link href="/2018/05/25/vscode-intro/"/>
      <url>/2018/05/25/vscode-intro/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a> 是微软开发的一款编辑器，迭代速度很快 ，产品定位是介于 IDE 和纯编辑器（如 vim ）之间，更多八卦可收听 <strong>Teahour.fm</strong> 第 91 期：<a href="http://teahour.fm/2017/12/12/why-vscode-is-better-than-atom.html" target="_blank" rel="noopener"><em>Why VS Code is better than atom ?</em></a> </p><hr><h3 id="VS-Code-安装"><a href="#VS-Code-安装" class="headerlink" title="VS Code 安装"></a>VS Code 安装</h3><p>安装很简单，从<a href="https://code.visualstudio.com" target="_blank" rel="noopener">官网</a>下载安装包到本地正常安装即可。实在不懂就看<a href="https://code.visualstudio.com/docs/setup/mac" target="_blank" rel="noopener">官方教程</a></p><hr><h3 id="立马上手"><a href="#立马上手" class="headerlink" title="立马上手"></a>立马上手</h3><p>打开 VS Code 后，点击右边栏倒数第一个图标或通过快捷键 <code>Cmd + Shift + X</code> 来进入插件搜索界面。推荐安装下面两个插件：</p><ul><li><p>搜索安装 <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a> 插件来运行主流语言的代码。安装完后，用 <code>⌘ + ,</code> 打开设置页面，通过「User」选项卡 -&gt; 「Extensions」-&gt; 「Run Code configuration」可以勾选设置「<em>Whether to clear previous output before each run.</em>」即是否每次运行输出前清除之前的输出内容。</p></li><li><p>搜索安装 <a href="https://marketplace.visualstudio.com/items?itemName=lfs.vscode-emacs-friendly" target="_blank" rel="noopener">Emacs Friendly Keymap</a>。这样就可以使用好用的 Emacs 快捷键（光标移动，Kill 和 Yank 等操作）。</p></li></ul><hr><h3 id="Code-Runner-设置"><a href="#Code-Runner-设置" class="headerlink" title="Code Runner 设置"></a>Code Runner 设置</h3><p><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a> 安装完之后并不能马上可以运行各种代码，因为它其实是调用各种终端命令来运行代码的，也就是终端里得有这个命令。</p><p>比如要运行 JavaScript ，就要确保安装了 <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> ，而运行 Python 则要安装 <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python</a> ，以此类推：</p><pre><code class="lang-bash">## 通过 Homebrew 安装 Node$ brew install node## 或者通过 nvm 安装 Node$ nvm install latest    # 安装并使用最新版本的 Node$ nvm install v13.14.0  # 安装并使用 v13.14.0 版本的 Node## 通过 Homebrew 安装 python$ brew install python3</code></pre><p>安装完成后，<strong>Code Runner</strong> 就会自动调用相应的命令来运行对应的文件。比如对于<code>.js</code> 文件，就会调用 <code>node</code> 命令来运行，而对于<code>.py</code> 文件，则会调用 <code>python3</code> 来运行。</p><p>如果没安装，或者终端里的环境变量 <code>$PATH</code> 没设置对，<strong>Code Runner</strong> 就会因找不到这些命令而运行失败。</p><ul><li><p><strong>进一步设置命令如何运行</strong><br>在 <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a> 的设置页面找到齿轮图标，点击展开，然后：<br><code>Extensions Settings</code> -&gt; <code>Code-runner:</code> <strong><code>Executor Map</code></strong> -&gt; <code>Edit in settings.jason</code><br>可以打开如下设置文件：</p><pre><code class="lang-jason">{&quot;code-runner.clearPreviousOutput&quot;: true,&quot;editor.tabSize&quot;: 2,&quot;editor.detectIndentation&quot;: false,&quot;code-runner.executorMap&quot;: {  &quot;javascript&quot;: &quot;node --trace-uncaught&quot;,  &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,  ...  ...  &quot;python&quot;: &quot;python3 -u&quot;,  &quot;rust&quot;: &quot;cd $dir &amp;&amp; rustc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;,  &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -std=c++11 $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,  ...  ...}}</code></pre><p>可以更具体地看到，当运行<code>.js</code> 文件，会调用 <code>node --trace-uncaught</code> 命令来运行，而 <code>.py</code> 文件，则会调用 <code>python3 -u</code> 来运行。<br>这些命令都是可以更改的。比如你可以去掉参数 <code>--trace-uncaught</code> ，只用 <code>node</code> 来运行。或者根据本地安装的情况，把 <code>python3</code> 改为 <code>python</code> 来运行。</p></li></ul><hr><h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>VS Code 需要以目录（<strong>而不是文件</strong>）为最小单位打开（载入）。打开存放代码的目录就能看到代码文件。<br>选择文件后点击界面右上角的三角形 Run Code 按钮或者使用快捷键 <code>Ctrl + Option + N</code> 来运行的代码。</p><p>下面是 JavaScript 常用语法，可以用来试试上面的操作：</p><pre><code class="lang-javascript">// 函数声明function show(x) {  return console.log(x);}(n) =&gt; { return n + 1; } // 匿名函数：有大括号就需要 return ，没有就不用；只有一个参数时圆括号是可选的；x =&gt; x + 1 ;             // param =&gt; expression; 等于 param =&gt; { return expression; } 或者 param =&gt; { statements }// 条件分支if (n &lt; 0) {  show(&quot;Baroque&quot;);    // 函数调用}else if (n == 0) {  show(&quot;Classical&quot;); }else {  show(&quot;Romantic&quot;); }</code></pre><p>更多 JS 语法参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a></p><hr><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p><strong>终端（Terminal）里打开 VS Code ：</strong><br>打开 <strong>Command Palette</strong>（快捷键 <code>⇧⌘P</code> ），输入 shell command 后搜索安装 <code>code</code> 这个命令即可</p><p><img src="https://code.visualstudio.com/assets/docs/setup/mac/shell-command.png" alt="VS Code Command Palette"></p><p>安装好后，使用以下方式从终端打开</p><pre><code class="lang-bash"># 单纯打开 VS Code$ code# 使用 VS Code 打开指定路径的文件$ code [文件路径]# Example - 使用 VS Code 打开当前文件夹$ code .</code></pre><p><strong>设置按一次 <code>Tab</code> 键相当于输入几个空格键：</strong><br>用 <code>Cmd + ,</code> 打开设置，然后搜索「Tab Size」关键词找到对应的选项，勾选即可。这里要注意观察另一个叫「Detect Indentation」的设置，它如果被勾选会覆盖「Tab Size」的设置。</p><p>这里注意 VS Code 的设置有以下两个不同优先级的设置文件，它们之间是继承关系：</p><ol><li><strong>User Settings</strong> - 用户设置</li><li><strong>Workspace Settings</strong> - 工作站设置（覆盖上者）</li></ol><p><strong>设置格式化代码中的花括号位置：</strong><br>vscode 缺省的格式化方式是「埃及括号」，也就是把花括号放在一行的末尾，而 ian 推荐的样式是把花括号放在新的一行，这样前两行不至于挨得太近。只需要在设置搜索栏搜索「open brace on new line」找到对应的条件分支（Control Blocks）和函数（Functions）两个选项，打上勾就可以了。</p><p>上面两个设置好后，之后的格式化代码操作（右键单击后选择 Format Document）就可以让代码调整为这些格式显示。</p><p><strong>一些更方便的设置：</strong></p><ul><li>右键单击输出窗口（OUTPUT）的顶部，选择 <code>Move Panel Right</code> ，可以将输出窗口移动到右侧；</li><li>右键单击文件的 <strong>Tab</strong> ，选择 <code>Split Right</code> ，可以在右边新开一个面板（Panel）来显示该文件，这样可以同时看多个文件内容；</li></ul><p><strong>VS Code 常用快捷键：</strong></p><ul><li>打开 <strong>Command Palette</strong> 可以搜索各种命令的快捷键：<code>Shift + ⌘ + P</code> ；</li><li>注释 / 取消注释某一行代码（光标位于这一行后再按快捷键组合）：<code>⌘ + /</code> ；</li><li>块注释（选中代码后）：<code>Shift + Option + A</code> ；</li></ul><p>更多有关 VS Code 的操作，可参考<a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener">官方文档</a></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手 Python</title>
      <link href="/2018/05/10/python-basics/"/>
      <url>/2018/05/10/python-basics/</url>
      
        <content type="html"><![CDATA[<p>像 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript#" target="_blank" rel="noopener">JavaScript</a> 这类语言的设计，适合新手学习理解特别简单编程概念。比如<strong>函数</strong>。但如果要理解<strong>面向对象（Object Oriented）</strong>的概念，用 <strong>JavaScript</strong> 会比较绕。因为它设计比较奇怪，你得去理解一些专门针对 <strong>JavaScript</strong> 设计的东西。</p><p>相比之下，用 <a href="https://www.python.org" target="_blank" rel="noopener">Python</a> 来理解面向对象，思路会清晰很多。</p><hr><h3 id="Python-编程环境"><a href="#Python-编程环境" class="headerlink" title="Python 编程环境"></a>Python 编程环境</h3><p>一般推荐两个编辑器，或者说 IDE ，来快速实践各种代码：</p><ul><li><a href="https://code.visualstudio.com" target="_blank" rel="noopener">VS Code</a>：微软开发的一款超轻量 IDE ，<a href="http://teahour.fm/2017/12/12/why-vscode-is-better-than-atom.html" target="_blank" rel="noopener">Teahour 91期</a> 有介绍，使用方法参考 <a href="/2018/05/25/vscode-intro/">快速上手 VS Code</a></li><li><a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a>：JetBrains 团队开发的一款 Python 的 IDE ，安装和使用方法参考这个 <a href="https://www.youtube.com/watch?v=BPC-bGdBSM8" target="_blank" rel="noopener">YouTube 视频</a> </li></ul><p>此外，还可以选择 <a href="/2018/05/27/set-up-anaconda/">安装配置 Anaconda</a> ，以使用 Anaconda 附带的 Python 在终端里运行。</p><pre><code class="lang-bash">## 通过 Homebrew 安装 python$ brew install python3## 查看 Python 的版本$ python3 --versionPython 3.6.5 :: Anaconda custom (64-bit)## 运行 *.py 的 Python 脚本文件$ cat ~/scripts/first_script.py         # 显示 first_script.py 文件里的内容print(&#39;Congratulations on running this script!!&#39;)$ python3 ~/scripts/first_script.py     # 用 python3 运行 first_script.py 文件Congratulations on running this script!!## 直接输入命令 python ，不带任何文件和参数，会进入 interactive interpreter（交互式解释器），可进行各种 Python 的语法测试$ python3[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwinType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;exit()$</code></pre><p>PS:<br>个人推荐新手使用 <a href="https://code.visualstudio.com" target="_blank" rel="noopener"><strong>VS Code</strong></a> ，这东西介于编辑器和 IDE（Integrated Development Environment）之间，既有编辑器的简洁，又有 IDE 的强大功能，关键是安装配置起来特别简单，最适合新手。<br>可以参考这篇<a href="/2018/05/25/vscode-intro/">上手 Visual Studio Code</a> 设置 Python 的运行环境。</p><hr><h3 id="Python-的一些基本规则"><a href="#Python-的一些基本规则" class="headerlink" title="Python 的一些基本规则"></a>Python 的一些基本规则</h3><ol><li>变量区分大小写，即 case sensitive</li><li>空格重要，附带语意，即 spacing matters</li><li>运算符号有优先级（比如乘除法 * / 优先级高于加减法 +-）</li><li>运算的优先级可以使用括号来确定：优先级方向为从里往外</li><li>Python 中名为 <code>_</code> 的特殊变量（underscore variable）通常代表忽略这个值，其他详细参见<a href="https://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc" target="_blank" rel="noopener">这里</a></li><li>Python 变量名的规则不用 listSum 这种大小写混合，而是用下划线分隔多个单词，写成 list_sum 这样</li><li><p>Python 赋值时是「传址（引用）」效果，而不是「传值」效果。见下例：</p><pre><code class="lang-python"># 感受一下「传址」效果def li_round_change_value(li): for i,l in enumerate(li):   li[i] = round(float(l), 3)def li_round_doesnt_change_value(li): # 使用 map(function_to_apply, list_of_inputs) 将 list 里元素的类型变为浮点（float）型 li = list(map(lambda k:round(float(k), 3), li)) return litest_li = [9,13,5,2]print(li_round_doesnt_change_value(test_li)) # 输出 [9.0, 13.0, 5.0, 2.0] print(test_li) # 输出 [9, 13, 5, 2]li_round_change_value(test_li)print(test_li) # 输出 [9.0, 13.0, 5.0, 2.0]</code></pre></li></ol><p>附：<br><a href="https://www.jianshu.com/p/a793c0d960fe" target="_blank" rel="noopener">Python 命名规范</a></p><hr><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li><p>整数 - <strong>int</strong></p><pre><code class="lang-bash">&gt;&gt;&gt; 2 * 36&gt;&gt;&gt; 3 // 2  # 取整1</code></pre></li><li><p>浮点数 - <strong>float</strong><br>整数和浮点数在电脑里是有差别的，整数和浮点数混合计算会被转化为浮点数，结果也是浮点数</p><pre><code class="lang-bash">&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 1.5 * 23.0</code></pre></li><li><p>复数 - <strong>complex</strong><br>这是一种用于数学计算的数据类型，Python 中用 <code>j</code> 来表示虚数</p><pre><code class="lang-bash">&gt;&gt;&gt; (1 + 2j) * (1 + 2j)(-3+4j)</code></pre></li><li><p>字符串 - <strong>string</strong><br>可以用单引号 <code>&#39;hello&#39;</code> ，也可以用双引号 <code>&quot;hello&quot;</code><br>一个常用的字符串方法：<a href="https://docs.python.org/3/library/stdtypes.html#str.split" target="_blank" rel="noopener"><code>str.split()</code></a></p><pre><code class="lang-bash">&gt;&gt;&gt; &#39;1,2,3&#39;.split(&#39;,&#39;)[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]&gt;&gt;&gt; &#39;1,2,3&#39;.split(&#39;,&#39;, maxsplit=1)[&#39;1&#39;, &#39;2,3&#39;]&gt;&gt;&gt; &quot;1,2,,3,&quot;.split(&#39;,&#39;)[&#39;1&#39;, &#39;2&#39;, &#39;&#39;, &#39;3&#39;, &#39;&#39;]</code></pre></li><li><p>布尔类型 - <strong>bool</strong><br>Python 中不用 <code>&amp;&amp;</code> 而是用 <code>and</code> 来代表「<strong>且</strong>」<br>其实 <code>&amp;&amp;</code> 并不是一个好设计，因为这个符号没有 <code>and</code> 直观易懂</p><pre><code class="lang-bash">&gt;&gt;&gt; 1&lt;2 and 3&gt;4False&gt;&gt;&gt; 1&lt;2 or 3&gt;4True&gt;&gt;&gt; not 1&lt;2False&gt;&gt;&gt; 1 == 2False&gt;&gt;&gt; type(1==2)&lt;class &#39;bool&#39;&gt;                # 注意这里返回的类型，不是「字符串」&gt;&gt;&gt; type(type(1==2))&lt;class &#39;type&#39;&gt;                # 它是一个 type 类，即 class &#39;type&#39;&gt;&gt;&gt; type(1==2) == &quot;bool&quot;      # 所以不能用这种方式来判断数据的类型False&gt;&gt;&gt; type(1==2) == type(1&lt;2)   # 对应地，可以用这种方式来判断数据类型True&gt;&gt;&gt; type(1==2) == type(False) # Python 的类型设计是要比 JavaScript 严格很多的True                          # 所以做科学计算或者 AI 用的就是 Python 而不是 JavaScript## 正规判断类型的方法是用 isinstance(object, type)&gt;&gt;&gt; isinstance(2, bool)False&gt;&gt;&gt; isinstance(2 &lt; 3, bool)True</code></pre></li><li><p><strong>None</strong><br>这是 Python 里面的一种专门的数据类型，代表「没有」，类似 JavaScript 里的 Null</p><pre><code class="lang-bash">&gt;&gt;&gt; None         # 注意第一个字母 N 是大写&gt;&gt;&gt; x = None&gt;&gt;&gt; x            # 没输出不显示&gt;&gt;&gt; print(x)     # 用 print 能打印出来None&gt;&gt;&gt; print(None)None</code></pre></li></ul><hr><h3 id="基本的数据结构"><a href="#基本的数据结构" class="headerlink" title="基本的数据结构"></a>基本的数据结构</h3><ul><li><p>列表 - <strong>List</strong><br>在编程中，「<code>链表（Linked List）</code>」和「<code>列表（List）</code>」通常不是同一个概念：<br><strong>链表</strong>是一种数据结构，由一系列节点组成，每个节点包含数据以及指向下一个节点的指针；<br><strong>列表</strong>是一种抽象数据类型（ADT），用来存储一系列元素的有序集合。列表可以有不同的实现方式，包括数组、链表等，甚至可以是其他数据结构的组合。<strong>链表</strong>是<strong>列表</strong>的一种实现方式；<br>在编程中，「<strong>列表</strong>」通常更广泛地指代一种抽象数据类型，而「<strong>链表</strong>」则更具体地指代一种特定的数据结构。<br>因此，它们的主要区别在于抽象性和具体性；</p><pre><code class="lang-bash">&gt;&gt;&gt; li = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]## li 的定义看起来像数组，但其实不是，它的类型是 class &#39;list&#39;## 但你可以认为它就是一个数组&gt;&gt;&gt; type(li)&lt;class &#39;list&#39;&gt;## 所以你可以用下标访问 - 下标从 0 开始&gt;&gt;&gt; li[0]1## slice 操作## 访问 list 中下标从 0 到 2 的部分 - 注意这里不包括 li[2]## 相当于 [0, 2) 的感觉&gt;&gt;&gt; li[0:2][1, 2]## 访问从头到某个下标（不包括 li[1]）&gt;&gt;&gt; li[:1][1]## 访问从某个下标到最后&gt;&gt;&gt; li[1:][2, 3]## 赋值或者定义的时候，传递的是引用，而不是复制一份&gt;&gt;&gt; li[1, 2, 3]&gt;&gt;&gt; li2 = li&gt;&gt;&gt; li2[1] = 9    # 可以看到 li2 改变的同时，li 也被改变了&gt;&gt;&gt; li[1, 9, 3]## 如果要复制一份而不是传递引用，需要用 .copy() 这个方法&gt;&gt;&gt; li2 = li.copy()&gt;&gt;&gt; li[1] = 2&gt;&gt;&gt; li2[1, 9, 3]&gt;&gt;&gt; li[1, 2, 3]     # 所以在使用 python 的时候你要注意它是同一个对象还是不同的## 越界访问会报错 - 这是个好设计## 如果返回 undefined 之类的数据，就有可能被到处传递引发潜在问题而难以被定位纠正&gt;&gt;&gt; li[3]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range## 计算列表长度&gt;&gt;&gt; len(li)3## 使用 dir 可以看到一个类型（对象）里有哪些方法（methods）&gt;&gt;&gt; dir(li)[&#39;__add__&#39;, &#39;__class__&#39;, &#39;__class_getitem__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;]## 按 2 次 Tab 键进行补全，它就会提示你当前可用的所有方法（methods）&gt;&gt;&gt; li.li.append(  li.copy(    li.extend(  li.insert(  li.remove(  li.sort(li.clear(   li.count(   li.index(   li.pop(     li.reverse(## 插入元素 - 这里 insert 元素到开头还是比较费事的，不像 pair 那种 list 时间复杂度只有 O(1)## 为了程序的效率，一般不会把东西插到中间&gt;&gt;&gt; li.insert(0, 9)&gt;&gt;&gt; li[9, 1, 2, 3]## 排序&gt;&gt;&gt; li.sort()&gt;&gt;&gt; li[1, 2, 3, 9]## 取出最后一个元素&gt;&gt;&gt; li.pop()9&gt;&gt;&gt; li[1, 2, 3]## 列表里增加新元素（element）## 效果一&gt;&gt;&gt; li.append([4])&gt;&gt;&gt; li[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4]]  # 可以看到 list 里每个元素的类型不一定要相同 ## 效果二&gt;&gt;&gt; li.extend([4])&gt;&gt;&gt; li[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4]## 效果三&gt;&gt;&gt; li + [5][&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4, 5]&gt;&gt;&gt; li[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, [4], 4]## 使用「列表推导式（List Comprehension）」来生成 List&gt;&gt;&gt; li_c = [x**2 for x in range(10)]&gt;&gt;&gt; li_c[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]# 「列表推导式」中的 if&gt;&gt;&gt; [x for x in li_c if x % 2 == 0][0, 4, 16, 36, 64]## 「列表推导式」中的 if-else## 注意这里用了跟上面单纯的 if 不同的结构，所以 if 和 for 的位置顺序也不一样  ## The expression 「 x if C else y 」 first evaluates the condition, C rather than x. ## If C is true, x is evaluated and its value is returned.## Otherwise, y is evaluated and its value is returned.&gt;&gt;&gt; [x if x % 2 == 0 else 3 for x in li_c][0, 3, 4, 3, 16, 3, 36, 3, 64, 3]## 「列表推导式」中的「列表推导式」- 嵌套&gt;&gt;&gt; [ [x**2 for x in li] for li in [[1,3,5], [2,4,6]] ][[1, 9, 25], [4, 16, 36]]## 对 List 中的元素进行 map 操作&gt;&gt;&gt; list(map(lambda x:x+1, li_c))[1, 2, 5, 10, 17, 26, 37, 50, 65, 82]</code></pre></li><li><p>元组 - <strong>tuple</strong><br><code>tuple</code> 和 <code>list</code> 的区别在于，<code>tuple</code> 是不可更改的</p><pre><code class="lang-bash">## Tuple 用的是括号来表示，区别于 list 的方括号 []&gt;&gt;&gt; t = (1, 2, 3, 4, 5, 5, 5)&gt;&gt;&gt; t[1]2## 无法更改&gt;&gt;&gt; t[1] = 0Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#39;tuple&#39; object does not support item assignment## len 函数可以接收多种数据类型 - 这里是一个面向对象语言好的地方&gt;&gt;&gt; len(t)7</code></pre></li><li><p>字典 - <strong>dict</strong><br>字典本质上就是哈希表，即键值对（key-value pair）。比如对于 <code>{&#39;Ace&#39;: 1, &#39;Queen&#39;: 12}</code> 这一字典来说，<strong>‘Ace’</strong> 和 <strong>‘Queen’</strong> 就是<strong>键</strong>（Key），而对应的 <strong>1</strong> 和 <strong>12</strong> 就是<strong>值</strong>（Value）</p><pre><code class="lang-bash">## dict 用花括号来表示，类型是 class &#39;dict&#39;&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2}&gt;&gt;&gt; d{&#39;a&#39;: 1, &#39;b&#39;: 2}&gt;&gt;&gt; type(d)&lt;class &#39;dict&#39;&gt;## 你需要用下标来访问，而不能当成对象（object）来用## Python 里把 dict 和 object 区分开了 - 这是一个好设计&gt;&gt;&gt; d[&#39;a&#39;]1&gt;&gt;&gt; d.a                                # 用 .a 来访问会报错Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#39;dict&#39; object has no attribute &#39;a&#39;## 修改和添加&gt;&gt;&gt; d[&#39;a&#39;] = 5         # 赋值&gt;&gt;&gt; d[&#39;c&#39;] = 12        # 添加新的 key&gt;&gt;&gt; d{&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;c&#39;: 12}## 判断某个 key 是否存在与某个字典中（注：case sensitive）&gt;&gt;&gt; &quot;ace&quot; in {&#39;ace&#39;: 1}True## 计算字典长度&gt;&gt;&gt; state_value = {(6, 10, False): -1.0, (15, 10, False): -1.0}&gt;&gt;&gt; len(state_value)2## 使用「列表推导式（List Comprehension）」来生成字典（dictionary）&gt;&gt;&gt; vocab_to_int = {word: ii for ii, word in int_to_vocab.items()}## 这里也可以用「列表推导式（List Comprehension）」来实现使用函数 f 来对字典的内容进行 Map{k: f(v) for k, v in my_dictionary.items()}</code></pre><p>模组 <a href="https://docs.python.org/3/library/collections.html" target="_blank" rel="noopener"><strong>collections</strong></a> 中的 <strong>defaultdict</strong> 类能更方便地处理 value 为列表（list）、字典（dictionary）的情况，其用法参见<a href="https://www.accelebrate.com/blog/using-defaultdict-python/" target="_blank" rel="noopener">Using defaultdict in Python</a></p><pre><code class="lang-bash">&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; city_list = [(&#39;TX&#39;,&#39;Austin&#39;), (&#39;TX&#39;,&#39;Houston&#39;), (&#39;NY&#39;,&#39;Albany&#39;), (&#39;NY&#39;, &#39;Syracuse&#39;), (&#39;NY&#39;, &#39;Buffalo&#39;), (&#39;NY&#39;, &#39;Rochester&#39;), (&#39;TX&#39;, &#39;Dallas&#39;), (&#39;CA&#39;,&#39;Sacramento&#39;), (&#39;CA&#39;, &#39;Palo Alto&#39;), (&#39;GA&#39;, &#39;Atlanta&#39;)]&gt;&gt;&gt;&gt;&gt;&gt; cities_by_state = defaultdict(list)&gt;&gt;&gt; for state, city in city_list:...     cities_by_state[state].append(city)...for state, cities in cities_by_state.iteritems():...     print state, &#39;, &#39;.join(cities)...NY Albany, Syracuse, Buffalo, RochesterCA Sacramento, Palo AltoGA AtlantaTX Austin, Houston, Dallas</code></pre></li><li><p>集合 - <strong>set</strong><br>集合也是数学计算中会常用到的数据结构：</p><pre><code class="lang-bash">## Set 也是花括号，可以注意到内部的顺序是乱的&gt;&gt;&gt; s = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;t&#39;, &#39;hello&#39;}&gt;&gt;&gt; s{&#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}## 增加元素&gt;&gt;&gt; s.add(&#39;world&#39;)&gt;&gt;&gt; s{&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}## 判断某个元素是否存在 - 可以认为这是个二元操作（binop）&gt;&gt;&gt; &#39;t&#39; in sTrue&gt;&gt;&gt; &#39;hi&#39; in sFalse## set 的相关运算&gt;&gt;&gt; s2 = {&#39;a&#39;, &#39;t&#39;, &#39;world&#39;, &#39;y&#39;, &#39;i&#39;}&gt;&gt;&gt; s - s2{&#39;b&#39;, &#39;hello&#39;, &#39;c&#39;}&gt;&gt;&gt; s{&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;hello&#39;, &#39;c&#39;, &#39;a&#39;}             # 不会改变原来的集合 s&gt;&gt;&gt; s.intersection(s2){&#39;world&#39;, &#39;t&#39;, &#39;a&#39;}                                # 交集&gt;&gt;&gt; s.union(s2){&#39;world&#39;, &#39;t&#39;, &#39;b&#39;, &#39;c&#39;, &#39;i&#39;, &#39;y&#39;, &#39;hello&#39;, &#39;a&#39;}   # 并集</code></pre></li></ul><hr><h3 id="Python-中的注释"><a href="#Python-中的注释" class="headerlink" title="Python 中的注释"></a>Python 中的注释</h3><ul><li>以 <code>#</code> 开头的行</li><li>以 <code>&quot;&quot;&quot;</code>（三个双引号）包裹的代码块（Code Block）</li></ul><pre><code class="lang-python">## codes by chpwang - 2018-05-17 04:57:56&quot;&quot;&quot;任务3:xxxxxx&quot;&quot;&quot;</code></pre><hr><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>Python 里面定义变量不需要 <code>var</code> 这类关键词，直接写就行，末尾也不用分号。</p><pre><code class="lang-python">## 变量定义x = 2 * 3## 赋值x = 12## 变量定义还可以解析结构l1 = [9, 8][u, v] = l1print(u)  # 9print(v)  # 8</code></pre><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Python 里面经常用「冒号」来分隔语言的各个部分。这里参数后面是冒号。新手要注意，冒号容易忘记写。</p><pre><code class="lang-python">## 匿名函数 x =&gt; x * xlambda x: x * x## 函数调用(lambda x: x * x)(3)## 函数定义square1 = lambda x: x*xdef square2(x): return x*x## 这里「缩进」很重要，python 靠缩进来判断函数体## 如果函数体语句多，注意缩进要对齐，不能有的缩进 2 格，有的只缩进 1 格## 「缩进」是一种危险的糟糕设计，容易出错，比如有时 return 缩进错了，可能就跑到外部去了## 缩进设计似乎只是为了少写一些括号def square3(x):  return x*xresult1 = 10result2 = 10## square4 中的 result 是局部变量，不改变外面的 resultdef square4(x):  result1 = x*x  return result## 加了 global 关键词后，square5 中的 result 就是全局变量了## 调用 square5 会改变外面的 resultdef square5(x):  global result  result = x*x  return resultprint(square4(4))  # 16print(result1)     # 10print(square5(4))  # 16print(result1)     # 16## 函数也可以什么都不做，但要写一个 pass ，不能什么都不写def do_nothing(x):  pass</code></pre><pre><code class="lang-bash">&gt;&gt;&gt; def minus(x, y): return x - y...&gt;&gt;&gt; minus(9, 6)3&gt;&gt;&gt; minus(y=9, x=6)  # python 的函数调用可以指定参数的值，这样可以无视参数的调用顺序-3                   # 好处是如果参数比较多，把各参数名和值写上，代码阅读起来就很直观 - 这是个好设计</code></pre><hr><h3 id="条件分支-if-语句"><a href="#条件分支-if-语句" class="headerlink" title="条件分支 - if 语句"></a>条件分支 - if 语句</h3><p><strong>注意</strong>，<code>else if</code> 分支在这里写作 <code>elif</code></p><pre><code class="lang-python">def fib(n):  if n == 0:    return 0  elif n == 1:    return 1  else:    return fib(n-1) + fib(n-2)if season == &#39;spring&#39;:    print(&#39;plant the garden!&#39;)elif season == &#39;summer&#39;:    print(&#39;water the garden!&#39;)else:    print(&#39;unrecognized season&#39;)## 三元操作符（Ternary Operator）写法x = true_value if condition else false_value## lambda 中的 if - 无法在 lambda 匿名函数中使用 print 打印，或者 raise 报错lambda x: True if x % 2 == 0 else False</code></pre><hr><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code class="lang-bash">## Python 中的循环一般不用下标&gt;&gt;&gt; a = [2, 3, 4, 6]&gt;&gt;&gt; for x in a:...  print(x)...2346## 可以使用这种模式匹配来直接取出 key 和 value 而不用后续访问下标 - 这是好设计&gt;&gt;&gt; for [k, v] in [[&quot;dog&quot;, 1], [&quot;cat&quot;, 2], [&quot;fish&quot;, 3]]:...     print(f&quot;{k}: {v}&quot;)...dog: 1cat: 2fish: 3## 模式匹配（pattern match）还可以用于赋值，比如交换变量的数据&gt;&gt;&gt; [x, y] = [3, 4]&gt;&gt;&gt; x3&gt;&gt;&gt; y4&gt;&gt;&gt; [x, y] = [y, x]&gt;&gt;&gt; x4&gt;&gt;&gt; y3## 和 range(start, stop, step) 函数结合使用&gt;&gt;&gt; for i in range(0, 2, 1):...     print(i)...01## 这里说明一下这个 range## 可以认为 range(5) 的效果就相当于生成了一个 [0, 1, 2, 3, 4] 这样的 list## 然后我们就可以 for i in range(5)## 虽然效果上是一样的，但实际上 range 不会真的生成一个 list## range 多用于循环，如果真生成一个 list ，就会影响计算性能并占用空间## 比如这样一来 range(1000000) 就很吃计算资源了## range 实际上生成的是一种 lazy list（惰性列表）## 惰性列表的意思是，它不会真的给你放到内存里面去## range(5) 会返回一个 range 对象，按需计算元素的值，内存高效（memory efficient）## python 中的 for 循环都要用 for x in ... 这种形式，如果 x 是是数字，就要用这个 range## 有人认为这样的 for 循环表达能力有限，不能表达复杂的逻辑，range 只能表达简单的数字## 比如无法写出类似 for(var i=0, j=array.length; i &lt; j; i++, j--) 的代码## 但其实这是 python 的一个好设计。当表达不了的时候，就不应该使用 for 循环，而要改用 while 循环## 上述复杂的 for 循环需要思考到底是先判断 i &lt; j 还是先计算 i++ 和 j--，不利于代码阅读理解## 用 reversed 配合 range 倒数## 写成 for i in range(4, -1, -1) 虽然是同样的效果，但阅读理解上不直观&gt;&gt;&gt; for i in reversed(range(0, 5)):...     print(i)...43210# 和 zip() 函数结合使用&gt;&gt;&gt; alist = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;]&gt;&gt;&gt; blist = [&#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;]&gt;&gt;&gt; for a, b in zip(alist, blist):...     print(a, b)...a1 b1a2 b2a3 b3## upack 一个 list 也是常用的循环 - 若觉得下行的说明不清楚就开终端试一试## 此例第 1 次循环取出第一个元素 [1, 3]，然后把第一项和第二项分别赋值给 a 和 b&gt;&gt;&gt; for a, b in [[1,3],[2,4]]:...     print(a)...     print(b)...1324## 使用 * （星号 star）和 zip 来操作 list## 下划线符号：_ 在 Python 中代表占位符，相当于吃掉这两个位置的输出 - 下面的代码原本会输出 3 个结果，但只想要其中最后一个结果，所以使用下划线来抛弃前两个结果 &gt;&gt;&gt; _, _, rewards = zip(*[((6, 10, False), 1, 0), ((17, 10, True), 1, 0), ((21, 10, True), 0, 1.0)])&gt;&gt;&gt; rewards(0, 0, 1.0)## while 循环&gt;&gt;&gt; while i &lt; 6:...   print(i)...   if i==3:...     break...   i += 1...123</code></pre><hr><h3 id="类-class"><a href="#类-class" class="headerlink" title="类 - class"></a>类 - class</h3><p>这里以实现查找表为例演示 <code>class</code> 的用法：</p><ul><li>类里面的函数的第一个参数都是 <code>self</code> ，也就是自己</li><li>类里面默认要有 <code>__init__</code> 函数作为「构造函数」，如果没写 Python 也会给一个默认的</li></ul><pre><code class="lang-python">## Map 没有定义 __init__ ，但还是程序还是会给它一个默认的 __init__class Map:  def print_data(self):    print(&quot;data: &quot; + str(self.data))class Table:  def __init__(self):    self.data = []  def add(self, key, value):    self.data.insert(0, [key, value])  def lookup(self, key):    for [k, v] in self.data:      if k == key:        return v    return Noneclass Hash:  def __init__(self):    self.data = {}  def add(self, key, value):    self.data[key] = value  def lookup(self, key):    return self.data[key]</code></pre><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>这里介绍的是常用的输出语法，更详细的介绍可以参考这篇 <a href="https://www.digitalocean.com/community/tutorials/how-to-use-string-formatters-in-python-3" target="_blank" rel="noopener">How to use <strong><em>str.format()</em></strong></a></p><pre><code class="lang-bash">## 普通输出 - 使用 {} 占位，.format() 填充占位符&gt;&gt;&gt; print(&quot;{} ~ {}% dog wins.&quot;.format(3, 9))3 ~ 9% dog wins.## 保留 5 位小数&gt;&gt;&gt; print(&quot;{} - {:.5f}&quot;.format(3,9.0/3.5))3 - 2.57143## 保留 1 位小数&gt;&gt;&gt; print(&quot;{} - {:.1f}&quot;.format(3,9.0/3.5))3 - 2.6</code></pre><p>在 Python 中，还可以使用 <code>f-string</code> 这种种字符串格式化的方法来输出。只需在<strong>字符串</strong>前加上字母 <code>f</code> 或 <code>F</code> ，然后在字符串中使用花括号 <code>{}</code> 包裹要插入的变量或表达式：</p><pre><code class="lang-python">name = &quot;Alice&quot;age = 30height = 1.75print(f&quot;My name is {name}, I am {age} years old.&quot;)    # 使用 f-string 插入变量值# My name is Alice, I am 30 years old.print(f&quot;Next year, I will be {age + 1} years old.&quot;)   # 可以在 f-string 中进行简单的表达式计算# Next year, I will be 31 years old.print(f&quot;My height is {height:.2f} meters.&quot;)           # 使用 f-string 格式化浮点数# My height is 1.75 meters.</code></pre><hr><h3 id="自解释器"><a href="#自解释器" class="headerlink" title="自解释器"></a>自解释器</h3><p>Python 中的内置函数 <code>eval</code> 可以将字符串解析成 Python 的代码</p><pre><code class="lang-python">## test.pynum = 30x = eval(&quot;num + 29&quot;)print(x)</code></pre><pre><code class="lang-bash">$ python test.py59</code></pre><hr><h3 id="创建与导入脚本"><a href="#创建与导入脚本" class="headerlink" title="创建与导入脚本"></a>创建与导入脚本</h3><p>处理大型项目时，可以将代码分割，整理成多个 <code>*.py</code> 文件以便重复利用这些文件中的代码。这些 <code>*.py</code> 文件称为脚本（script）。如果你要导入的 Python 脚本与当前脚本位于同一个目录下，只需输入 import，然后是文件名，无需扩展名 <code>.py</code></p><pre><code class="lang-python">## demo.pyimport useful_functions as ufscores = [88, 92, 79, 93, 85]mean = uf.mean(scores)print(&quot;Demo Mean:&quot;, mean)print(&quot;__name__ value:&quot;, __name__)print(&quot;uf.__name__ value:&quot;, uf.__name__)</code></pre><pre><code class="lang-python">## useful_functions.pydef mean(num_list):    return sum(num_list) / len(num_list)def main():    n_list = [34, 44, 23, 46, 12, 24]    print(&quot;Useful Functions&#39; Mean:&quot;, mean(n_list))# 检测当前脚本（即 useful_functions.py）是否做为主模块被运行# 当前脚本若是被其他脚本的 import 语句导入，则下面的 if main 块代码不运行if __name__ == &#39;__main__&#39;:    main()</code></pre><p>运行结果如下：</p><pre><code class="lang-bash">$ lsdemo.py             useful_functions.py$ python demo.pyDemo Mean: 87.4__name__ value: __main__uf.__name__ value: useful_functions</code></pre><p>人们通常只希望重复使用被导入脚本里的「函数」或「类」，而不是其他可执行代码（如 <code>print()</code>），所以为避免「<strong>脚本A</strong>」被导入后，其中的可执行语句被运行，应该要将这些语句包含在 <code>if __name__ == &quot;__main__&quot;</code>块中，或者，将它们包含在函数 <code>main()</code> 中并在上述 <code>if main</code> 块中调用该函数。</p><p>每当运行脚本时（<code>*.py</code> 文件），Python 会为所有模块（module）设置一个特殊的内置变量 <code>__name__</code>。这些模块包含导入模块（用 <code>import</code> 语句导入的），还有主模块（即当前脚本）。主模块的 <code>__name__</code> 变量值会被设为字符串 <code>&quot;__main__&quot;</code>，而对于被导入的模块，<code>__name__</code> 变量会设为该模块的名称。因此 <code>if main</code> 代码块常用来判断是否为主模块。</p><p>PS：<br>从输出结果可看到，上述例子中，被导入模块的 <code>__name__</code> 值为 <code>&quot;useful_functions&quot;</code></p><hr><h3 id="自定义一个类-复杂例子"><a href="#自定义一个类-复杂例子" class="headerlink" title="自定义一个类 - 复杂例子"></a>自定义一个类 - 复杂例子</h3><pre><code class="lang-python">import mathfrom decimal import Decimal, getcontext## 设置 Decimal 数据类型的小数点后保留的位数getcontext().prec = 19## 用来辅助判断一个数是否为零（小于此值则为零）TOLERANCE = 1e-10class Vector(object):  ## 设置报错信息  ALL_ELEMENT_MUST_BE_NUM_MSG = &quot;Element must be number!&quot;  ## 实例（instance）的创建  def __init__(self, coordinates):    try:      if not coordinates:          raise ValueError      self.coordinates = tuple([Decimal(x) for x in coordinates])      self.dimension = len(coordinates)    except ValueError:      raise ValueError(&#39;The coordinates must be nonempty&#39;)    except TypeError:      raise TypeError(&#39;The coordinates must be an iterable&#39;)  ## print 输出内容  def __str__(self):    return &#39;Vector: {}&#39;.format(self.coordinates)  ## 定义相等  def __eq__(self, v):    return self.coordinates == v.coordinates  def __len__(self):    return len(self.planes)  ## __getitem__ 这个函数使得对于 v = Vector([5, 3, -2]) ，可使用索引方式 v[1] 得到数字 3  def __getitem__(self, i):    return self.coordinates[i]  ## __setitem__ 这个函数使得对于 v = Vector([5, 3, -2]) ，可使用索引方式 v[1] = 9 将 v[1] 的值设置为 9  def __setitem__(self, i, x):    try:      assert x.dimension == self.dimension  # 如果设置的 x 不是数字，则报错      self.coordinates[i] = x    except AssertionError:      raise Exception(self.ALL_ELEMENT_MUST_BE_NUM_MSG)  ## 计算向量的加法  def plus(self, v):    new_coordinates = [x+y for x,y in zip(self.coordinates, v.coordinates)]    return Vector(new_coordinates)  ## 计算向量的减法  def minus(self, v):    return self.plus(v.times_scalar(-1))  ## 计算向量的数乘  def times_scalar(self, c):    new_coordinates = [x*c for x in self.coordinates]    return Vector(new_coordinates)  ## 计算向量与另一向量的点积（内积）  def dot_product_with(self, v):    new_coordinates = [x*y for x,y in zip(self.coordinates, v.coordinates)]    return sum(new_coordinates)  ## 计算向量的模  def magnitude(self):    return Decimal(math.sqrt(self.dot_product_with(self)))  ## 计算向量标准化后的向量（同方向上的单位向量）  def normalization(self):    try:      mag = self.magnitude()      return self.times_scalar(Decimal(1)/mag)    except ZeroDivisionError:      #print(&quot;You can&#39;t normalize Zero Vector!&quot;)      raise Exception(&quot;You can&#39;t normalize Zero Vector!&quot;)  ## 计算向量与另一向量的夹角  def angle_with(self, v, in_degrees=False):    try:      mag_1 = self.magnitude()      mag_2 = v.magnitude()      if in_degrees:        return math.degrees(math.acos(self.dot_product_with(v)/(mag_1*mag_2)))      else:        return math.acos(self.dot_product_with(v)/(mag_1*mag_2))    except ZeroDivisionError:      #print(&quot;At least one of the vector is Zero Vector! No angle defined.&quot;)      raise Exception(&quot;One of the vector is Zero Vector! No angle defined.&quot;)  ## 私有函数（private function）和变量，以两个下划线开头来命名  def __is_zero_vector(self):    return self.magnitude() &lt; TOLERANCE  def is_parallel_to(self, v):    if v.__is_zero_vector() or self.__is_zero_vector():      return True    else:      s_m = self.normalization()      v_m = v.normalization()      return s_m.minus(v_m).__is_zero_vector() or s_m.plus(v_m).__is_zero_vector()   def is_orthogonal_to(self, v):    return abs(self.dot_product_with(v)) &lt; TOLERANCE  ## 向量的分解 - 计算向量水平方向的分量  def component_parallel_to(self, base_vactor):    u_b = base_vactor.normalization()    mag = self.dot_product_with(u_b)    return u_b.times_scalar(mag)  ## 向量的分解 - 计算向量竖直方向的分量  def component_orthogonal_to(self, base_vactor):    c_p = self.component_parallel_to(base_vactor)    return self.minus(c_p)  ## 计算向量与另一向量的叉乘  def cross_product_with(self, v):    if self.dimension != 3 or v.dimension != 3:      raise Exception(&quot;Both cross product vectors must be three dimensional&quot;)    if self.is_parallel_to(v):      return Vector([0 for i in range(self.dimension)])    else:      x = self.coordinates[1]*v.coordinates[2] - self.coordinates[2]*v.coordinates[1]      y = self.coordinates[2]*v.coordinates[0] - self.coordinates[0]*v.coordinates[2]      z = self.coordinates[0]*v.coordinates[1] - self.coordinates[1]*v.coordinates[0]      return Vector([x, y, z])  ## 计算向量与另一向量的所围成的四边形的面积  def area_of_parallelogram_spanned_with(self, v):    new_self = self    new_v = v    if self.dimension == 2:      new_self = Vector(self.coordinates + (0,))    if v.dimension == 2:      new_v = Vector(v.coordinates + (0,))    return new_self.cross_product_with(new_v).magnitude()  ## 计算向量与另一向量的所围成的三角形的面积  def area_of_triangle_spanned_with(self, v):    return self.area_of_parallelogram_spanned_with(v) / Decimal(2)</code></pre><hr><h3 id="常用模组-Module"><a href="#常用模组-Module" class="headerlink" title="常用模组 - Module"></a>常用模组 - Module</h3><p><a href="https://docs.python.org/3/library/" target="_blank" rel="noopener">Python 的标准库</a>里包含了常用的 Module ，使用 <code>import</code> 语句可导入</p><p>以下是一些实用的模组（Module）：</p><ul><li><p><a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener">sys</a>：内建了很多好用的工具</p><pre><code class="lang-python">import sys## 工具一：sys.stdout.flush() ## 不断更新输出内容，而不是叠加输出（即每次删除上次的「显示结果」，然后显示当次的「显示结果」）for i_episode in range(1, num_episodes+1):        # monitor progress        if i_episode % 1000 == 0:            print(&quot;\rEpisode {}/{}.&quot;.format(i_episode, num_episodes), end=&quot;&quot;)            sys.stdout.flush()</code></pre></li><li><p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">re</a> ：通过正则表达式在字符串中进行模式匹配</p></li><li><p><a href="https://docs.python.org/3/library/math.html" target="_blank" rel="noopener">math</a> ：一些标准数学函数</p></li><li><p><a href="https://docs.python.org/3.6/library/fractions.html" target="_blank" rel="noopener">fractions</a>：此库最常用的是里面的 <code>Fraction</code>，分数（有理数）计算超方便</p><pre><code class="lang-python">from fractions import Fraction</code></pre></li><li><p><a href="https://docs.python.org/3/library/random.html" target="_blank" rel="noopener">random</a> ：生成假随机数字，随机打乱序列并选择随机项 </p></li><li><p><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">json</a> ：适用于读写 json 文件（面向网络开发）</p></li><li><p><a href="https://docs.python.org/3/library/datetime.html" target="_blank" rel="noopener">datime</a> ：读取当前时间和日期</p></li><li><p><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">os</a> ：与操作系统交互的操作</p><pre><code class="lang-python">import osos.chdir(path)  # 更改当前的工作目录（working directory）</code></pre></li><li><p><a href="https://docs.python.org/3/library/csv.html" target="_blank" rel="noopener">csv</a> ：处理 <code>.csv</code> 类型的文件</p></li><li><p><a href="https://docs.python.org/3/library/zipfile.html" target="_blank" rel="noopener">zipfile</a> ：处理 <code>.zip</code> 压缩文件</p></li><li><p><a href="https://docs.python.org/3/library/collections.html" target="_blank" rel="noopener">collections</a> ：常见数据类型的实用扩展，包括 OrderedDict、defaultdict 和 namedtuple</p></li><li><p><a href="https://docs.python.org/3/library/timeit.html" target="_blank" rel="noopener">timeit</a> ：显示<strong>简短的代码</strong>运行所花费的时间</p></li><li><p><a href="https://docs.python.org/3/library/profile.html" target="_blank" rel="noopener">cProfile 或 profile</a> ：显示<strong>大型项目</strong>运行所花费的时间</p></li></ul><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Programming Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rails 常用指令</title>
      <link href="/2018/01/31/rails-cheat-sheet/"/>
      <url>/2018/01/31/rails-cheat-sheet/</url>
      
        <content type="html"><![CDATA[<p>Rails 的开发环境的搭建参考<a href="/2017/03/14/setup-new-mac/">入手新 Mac 后的环境搭建</a><br>Rails 的关键知识学习请前往 <a href="https://fullstack.qzy.camp/dashboard" target="_blank" rel="noopener">Xdite 的全栈营</a></p><p>PS：<br>人们使用 Ruby 这门语言的原因仅仅是因为要用 Rails ，离开了 Rails , Ruby 这门语言就……所以你知道为啥说到 Ruby 就一定要说 Rails ，或者人们在谈论 Ruby 时，其实说的是 Rails 了吧</p><hr><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><pre><code class="lang-bash">## 在当前目录下新建 Rails app$ rails new [app名]## Example$ rails new first_app## 打开服务器（网址通常是 http://localhost:3000）$ cd first_app$ rails s$ rails server## 查看路径$ rails routes## 数据库管理 Migration$ rails db:migrate      ## runs (single) migrations that have not run yet. - update schema.rb with all migrations$ rails db:create       ## creates the database$ rails db:drop         ## deletes the database$ rails db:schema:load  ## creates tables and columns within the (existing) database following schema.rb$ rails db:seed         ## load seed.rb - 按照 seed.rb 文件里的指令，创造数据并添加到数据库里$ rails db:setup        ## does db:create, db:schema:load, db:seed$ rails db:reset        ## does db:drop, db:setup$ rails db:rollback     ## 取消最近一次 migration 的加载 - 通常不用，改数据库强烈建议新增 Migration 来改，而不是执行 rollback ，rollback 建议最多只运行一次（退后一步）## 先 drop（删除）掉原先的数据库，再建立新的数据库，最后 migrate 加载所有 migrations$ rails db:drop db:create db:migrate## Example$ rails g controller groups$ rails g controller account/groups$ rails g controller account::groups</code></pre><hr><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>可以直接用一行代码新建 <strong>Model</strong>，适合 column 较少的情况</p><pre><code class="lang-bash">## 新建 Model$ rails g model [model 的名字] [参数名:参数类型] [参数名:参数类型] ...## Example$ rails g model job title:string description:text wage_upper_bound:decimal wage_lower_bound:decimal contact:text is_hidden:boolean</code></pre><p>也可以先生成 <strong>migration</strong> 文件，然后编辑该文件来生成</p><pre><code class="lang-bash">以下命令会生成一个 migration 文件 - db/migrate/20180423162706_create_[model 的名字].rb$ rails g model [model 的名字]# Example$ rails g model caseRunning via Spring preloader in process 44069      invoke  active_record      create    db/migrate/20180423162706_create_cases.rb      create    app/models/case.rb      invoke    test_unit      create      test/models/case_test.rb      create      test/fixtures/cases.yml</code></pre><p>找到并打开编辑 <code>db/migrate/20180423162706_create_[model 的名字].rb</code> 文件</p><pre><code class="lang-ruby">class CreateCases &lt; ActiveRecord::Migration[5.1]  def change    create_table :cases do |t|      t.string :nickname      t.text :summary      t.timestamps    end  endend</code></pre><p>无论采用上述哪种方式，最终都需要执行 <code>rails db:migrate</code> 来完成 <strong>Model</strong> 的建立</p><p>下面是如何给已有的 <strong>Model</strong> 添加 column</p><pre><code class="lang-bash">$ rails g migration [要添加的 migration 的名字]## Example$ rails g migration add_user_id_to_job</code></pre><pre><code class="lang-ruby">class AddUserIdToJob &lt; ActiveRecord::Migration[5.0]  def change    add_column :jobs, :user_id, :integer  endend</code></pre><p>重命名 Column - 注意 job 要复数（之前新建 model 时 Job 用的是单数 - <code>rails g model job title:string</code>）</p><pre><code class="lang-ruby">class ChangeWagesColumnNameInJob &lt; ActiveRecord::Migration[5.1]  def change    rename_column :jobs, :upper_wage, :wage_upper_bound    rename_column :jobs, :lower_wage, :wage_lower_bound  endend</code></pre><hr><h3 id="CRUD-模板"><a href="#CRUD-模板" class="headerlink" title="CRUD 模板"></a>CRUD 模板</h3><pre><code class="lang-ruby">class GroupsController &lt; ApplicationController  def index    @groups = Group.all  end  def new    @group = Group.new  end  def show    @group = Group.find(params[:id])  end  def edit    @group = Group.find(params[:id])  end  def create    @group = Group.new(group_params)    if @group.save      redirect_to groups_path    else      render :new    end  end  def update    @group = Group.find(params[:id])    if @group.update(group_params)      redirect_to groups_path, notice: &#39;Update Success&#39;    else      render :edit    end  end  def destroy    @group = Group.find(params[:id])    @group.destroy    redirect_to groups_path, alert: &#39;Group deleted&#39;  end  private  def group_params    params.require(:group).permit(:title, :description)  endend</code></pre><hr><h3 id="新手常用-Gem"><a href="#新手常用-Gem" class="headerlink" title="新手常用 Gem"></a>新手常用 Gem</h3><p><a href="https://github.com/plataformatec/devise" target="_blank" rel="noopener">Devise</a></p><pre><code class="lang-bash">$ rails g devise:install$ rails g devise user$ rake db:migrate</code></pre><p><a href="https://github.com/plataformatec/simple_form" target="_blank" rel="noopener">Simple Form</a></p><pre><code class="lang-bash">$ rails generate simple_form:install --bootstrap</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby &amp; Rails </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ruby 基本知识</title>
      <link href="/2018/01/22/Ruby-Basics/"/>
      <url>/2018/01/22/Ruby-Basics/</url>
      
        <content type="html"><![CDATA[<h3 id="Ruby-安装"><a href="#Ruby-安装" class="headerlink" title="Ruby 安装"></a>Ruby 安装</h3><p>在 Mac 电脑上，虽然安装好 Xcode 会自带 Ruby ，不过人们通常还是使用 <a href="https://rvm.io" target="_blank" rel="noopener">RVM</a> - Ruby Version Manager 来管理 Ruby 的各种版本</p><pre><code class="lang-bash">## 安装 RVM - Ruby Version Manager 用来管理 Ruby 的版本$ \curl -sSL https://get.rvm.io | bash -s stable$ source ~/.rvm/scripts/rvm    ## 安装完 rvm 会提示使用该命令来让 rvm 生效 ## 安装所需版本的 Ruby - 以 2.3.1 版本为例$ rvm install 2.3.1$ rvm list                ## 该命令可查看本地存在的所有 Ruby 的版本$ rvm use 2.3.1 --default ## 该命令用于设置默认的 Ruby 版本$ gem update --system     ## 用于救回安装 rvm 过程中网络等原因造成的中断失败$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/  #设置新的 gem 的来源网站</code></pre><hr><h3 id="IRB-Interactive-Ruby-Shell"><a href="#IRB-Interactive-Ruby-Shell" class="headerlink" title="IRB - Interactive Ruby Shell"></a>IRB - Interactive Ruby Shell</h3><p>IRB 一般用于测试 Ruby 的语法<br>安装完某个版本的 Ruby 后，打开 Mac 电脑上的 Terminal.app（终端）输入指令 <code>irb</code> 就可以体验 Ruby 了，有兴趣可到 <a href="http://tryruby.org" target="_blank" rel="noopener">Try Ruby</a> 感受更多操作</p><pre><code class="lang-bash">## 进入 Interactive Ruby$ irb 2.3.1 :001 &gt;</code></pre><hr><h3 id="计算和赋值"><a href="#计算和赋值" class="headerlink" title="计算和赋值"></a>计算和赋值</h3><pre><code class="lang-bash">## 在 irb 使用 Ruby 编程 - 计算和赋值$ irb 2.3.1 :001 &gt; 3+9 =&gt; 12 2.3.1 :002 &gt; 1024/8 =&gt; 128 2.3.1 :003 &gt; my_var=29 =&gt; 29 2.3.1 :004 &gt; my_var=my_var+2 =&gt; 31 2.3.1 :005 &gt; my_var=my_var/2 =&gt; 15 2.3.1 :006 &gt; my_var=my_var/2.0 =&gt; 7.5</code></pre><hr><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 - Array"></a>数组 - Array</h3><pre><code class="lang-bash">2.3.1 :007 &gt; fruits = [&quot;kiwi&quot;, &quot;strawberry&quot;, &quot;plum&quot;] =&gt; [&quot;kiwi&quot;, &quot;strawberry&quot;, &quot;plum&quot;] 2.3.1 :008 &gt; fruits = fruits + [&quot;orange&quot;] =&gt; [&quot;kiwi&quot;, &quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;] 2.3.1 :009 &gt; fruits = fruits + [&quot;kiwi&quot;] =&gt; [&quot;kiwi&quot;, &quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;, &quot;kiwi&quot;] 2.3.1 :010 &gt; fruits = fruits - [&quot;kiwi&quot;] =&gt; [&quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;]</code></pre><p>PS：可以观察到 Ruby 里数组的特点：后进的排后面；一删删全部等等</p><pre><code class="lang-ruby">## 数组的一些常用操作&gt; [1,2,3] &amp; [2,3,4] &amp; [0,2,6]   ## 多个数组求并集（intersection） =&gt; [2]</code></pre><hr><h3 id="类-Class"><a href="#类-Class" class="headerlink" title="类 - Class"></a>类 - Class</h3><p>Ruby 里常见的类有：<strong>Fixnum</strong>、<strong>String</strong> 和 <strong>Array</strong> 等等，可以通过使用 <code>.class</code> 的方式查看某种数据的类</p><pre><code class="lang-bash">2.3.1 :011 &gt; 29.class =&gt; Fixnum 2.3.1 :012 &gt; &quot;Twentynight&quot;.class =&gt; String 2.3.1 :013 &gt; fruits.class =&gt; Array</code></pre><hr><h3 id="方法-Methods"><a href="#方法-Methods" class="headerlink" title="方法 - Methods"></a>方法 - Methods</h3><p>Ruby 里每个<strong>类</strong>（Class）都包含多种<strong>方法</strong>（Methods），可用 <code>.[方法]</code> 的方式调用</p><pre><code class="lang-bash">2.3.1 :014 &gt; fruits =&gt; [&quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;]2.3.1 :015 &gt; fruits.length =&gt; 3 2.3.1 :016 &gt; fruits.first =&gt; &quot;strawberry&quot;</code></pre><p>还可以使用 <code>.methods</code> 的方式查看该<strong>类</strong>所包含的方法，而由于输出结果的类型属于<strong>数组</strong>（Array），所以可以进一步使用 <code>.methods.sort</code> 对结果排序</p><pre><code class="lang-bash">2.3.1 :017 &gt; fruits.methods =&gt; [:fill, :assoc, :rassoc, ... , :instance_exec, :__id__]2.3.1 :018 &gt; fruits.methods.sort =&gt; [:!, :!=, :!~, :&amp;, ... , :values_at, :zip, :|]</code></pre><p>此外，也可以自行定义<strong>方法</strong>（Methods）</p><pre><code class="lang-bash">2.3.1 :019 &gt; def pluralize(word)2.3.1 :020?&gt;   word + &quot;s&quot;2.3.1 :021?&gt;   end =&gt; :pluralize 2.3.1 :022 &gt; pluralize(&quot;apple&quot;) =&gt; &quot;apples&quot;</code></pre><p>注：<br>面向对象的语言里所谓的<strong>方法</strong>（Methods）其实就是函数式语言里的<strong>函数</strong>（Function）</p><hr><h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环 - Loops"></a>循环 - Loops</h3><pre><code class="lang-bash">2.3.1 :023 &gt; fruits.each do |fruit|2.3.1 :024 &gt;     puts fruit2.3.1 :025?&gt;   endstrawberryplumorange =&gt; [&quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;]</code></pre><pre><code class="lang-ruby">## 带索引（index）的循环&gt; fruits.each_with_index do |fruit, index|&gt;   puts fruit&gt;   puts index&gt; endstrawberry0plum1orange2 =&gt; [&quot;strawberry&quot;, &quot;plum&quot;, &quot;orange&quot;]</code></pre><hr><h3 id="条件-Conditional"><a href="#条件-Conditional" class="headerlink" title="条件 - Conditional"></a>条件 - Conditional</h3><pre><code class="lang-bash">2.3.1 :027 &gt; if my_var &gt; 1.02.3.1 :028?&gt;   puts &quot;BigOne&quot;2.3.1 :029?&gt;   endBigOne =&gt; nil 2.3.1 :030 &gt; if my_var &lt; 1.02.3.1 :031?&gt;   puts &quot;OTCBTC&quot;2.3.1 :032?&gt;   end =&gt; nil</code></pre><hr><h3 id="退出-IRB"><a href="#退出-IRB" class="headerlink" title="退出 IRB"></a>退出 IRB</h3><pre><code class="lang-bash">2.3.1 :033 &gt; exit$</code></pre><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ruby &amp; Rails </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用操作</title>
      <link href="/2018/01/02/Git-Basics/"/>
      <url>/2018/01/02/Git-Basics/</url>
      
        <content type="html"><![CDATA[<p>这里记录了常用的 Git 命令和知识，主要用于检索</p><hr><h3 id="关于-Git-的一些概念"><a href="#关于-Git-的一些概念" class="headerlink" title="关于 Git 的一些概念"></a>关于 Git 的一些概念</h3><img src="/2018/01/02/Git-Basics/git_concepts_framework.png" title="git concepts framework"><ul><li>Repository</li><li>Remote</li><li>Index / Stage</li><li>Workspace</li></ul><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通常 Mac 已经自带 Git ，但若要追求最新版，可使用 <a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a> 来安装</p><pre><code class="lang-bash">$ brew install git</code></pre><hr><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="lang-bash">## 进入需要用 Git 进行追踪以保存各个时间点进度的文件夹$ cd ~/rails101## 初始化当前所在文件夹$ git init</code></pre><hr><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><pre><code class="lang-bash">$ git config --global user.name &quot;xxx xxx&quot;        # Git 用户名$ git config --global user.email &quot;xxx@xxx.com&quot;   # Git 邮箱$ git config --global color.ui true              # Git 命令的输出文字色彩化# 显示当前的 Git 配置$ git config --list# Example$ git config --global user.name &quot;chpwang&quot;        $ git config --global user.email &quot;chpwang@gmail.com&quot;</code></pre><hr><h3 id="本地代码提交"><a href="#本地代码提交" class="headerlink" title="本地代码提交"></a>本地代码提交</h3><pre><code class="lang-bash">## 常用基本指令$ git status            ## 查看当前文件更改状态      $ git add [文件名]       ## 添加更改文件到 staging area（顶图中的 index 区）$ git commit -m &quot;该 commit 的注释内容&quot;    ## 保存 staging area 的文件（顶图中的 Repository 区）$ git log --oneline | head -n 5         ## 查看前 5 个 commit 的信息（一行一个）## 撤销$ git checkout [文件名]            ## 恢复暂存区的指定文件到工作区（working area）$ git checkout [commit] [文件名]   ## 恢复指定 commit 的指定文件到工作区$ git checkout .                  ## 恢复上一个commit的所有文件到工作区$ git checkout -- [文件名]         ## 清空工作区（working area）的指定文件的改动（不影响 Staging area）## 查看某个文件修改了什么$ git diff [文件名]                ## 查看指定文件对比最后一次 commit 的状态修改了那些内容</code></pre><hr><h3 id="拉取远程代码"><a href="#拉取远程代码" class="headerlink" title="拉取远程代码"></a>拉取远程代码</h3><pre><code class="lang-bash">## 从远程主机克隆一个版本库到本地，并在本地当前目录下生成一个文件夹，文件夹与远程主机的版本库同名$ pwd ~/Documents                 # 当前所在目录为 ~/Documents$ git clone [版本库的网址]## Example$ git clone git@github.com:webyrd/miniKanren.git## 若要指定不同的目录名，可以用以下命令$ git clone [版本库的网址] [本地目录名]</code></pre><hr><h3 id="临时缓存"><a href="#临时缓存" class="headerlink" title="临时缓存"></a>临时缓存</h3><pre><code class="lang-bash">## 缓存当前进度（只能缓存 tracked files，不能缓存 untracked files）- 以下两条命令效果一样$ git stash$ git stash save## 缓存包括 untracked files 在内的所有文件$ git stash save --include-untracked## 只缓存 Unstaged Area 的文件改动，保留 Staging Area$ git stash save --keep-index## 只缓存 Unstaged Area（包含 untracked files 在内）的文件改动，保留 Staging Area$ git stash save --keep-index --include-untracked## 缓存当前进度的同时增加对该缓存的描述，以便之后恢复时查看$ git stash save &quot;just add twentynight.html&quot;## 查看临时缓存里的各种存档$ git stash liststash@{0}: WIP on ch02: 5d65fd4 add flash messages at index## 在当前分支上恢复存档，默认是恢复 stash@{0} 的存档$ git stash apply [存档ID名]## Example - 恢复 stash@{1} 的存档$ git stash apply 1## 默认删除临时缓存里所保存的最新一条内容，即删除 stash@{0} - stash apply 之后不会自动删除已被 apply 内容，所以需要手动 drop 来删除$ git stash dropDropped refs/stash@{0} (bceb5b826e75881c82f83827605fc81938d49a49)## 如果不小心 drop 掉了代码，可以用被 drop 掉的 stash 所对应的 ID 重新找回$ git stash apply bceb5b826e75881c82f83827605fc81938d49a49## 删除缓存里的所有内容$ git stash clear## 以下命令相当于先运行 git stash apply ，再运行 git stash drop$ git stash pop</code></pre><hr><h3 id="重置和读档"><a href="#重置和读档" class="headerlink" title="重置和读档"></a>重置和读档</h3><p>参考 git real level 2</p><pre><code class="lang-bash">## 已经 add 的如何撤销（unstage files）？$ git reset HEAD &lt;file&gt;...</code></pre><p><code>HEAD</code> 作为指针指向最新的那个 commit，而 <code>HEAD^</code> 指向倒数第二新的 commit，<code>HEAD^^</code> 指向倒数第三新的 commit，以此类推，<code>HEAD^^^^^</code> 有 5 个 <code>^</code>（caret），所以它指向倒数第六新的 commit</p><pre><code class="lang-bash">## 已经 commit 的如何撤销？$ git reset --soft HEAD^   ## 把最新的 commit 里的修改撤销到 Stage ，文件成为 Staging files，HEAD 指针进而指向倒数第二新的 commit$ git reset --hard HEAD^   ## 慎用该命令！它会把最新的 commit 里的修改完全撤销，所有修改完全消失，HEAD 指针进而指向倒数第二新的 commit## 如何清除 Working Area（工作台）里所有已改动的文件，恢复到 HEAD （最新一个 commit）的状态## 可以先 Stash 缓存，然后再清空缓存$ git stash save --include-untracked$ git stash drop</code></pre><hr><h3 id="更改已有-Commit-Interactive-Rebase"><a href="#更改已有-Commit-Interactive-Rebase" class="headerlink" title="更改已有 Commit - Interactive Rebase"></a>更改已有 Commit - Interactive Rebase</h3><p>下面展示了最新的 3 条 Commit 信息:</p><pre><code class="lang-bash">$ git log --oneline | head -n 3a58f305 arrange folders for next Udacity Class - Deep Learningcf56d01 fix bugs, misunderstandings and mistakes in P5 Boston Housing - Udacity MLforNBseacff8b complete P5 Boston Housing - Udacity MLforNBs</code></pre><p>使用命令 <code>git rebase -i HEAD~3</code> 进入一个使用 vi 编辑器打开的文件，编辑这个文件（更改文件中顶部的 Commit 的关键词 - 例如 <code>pick</code> 改成 <code>r</code> 表示要重命名 Commit 的信息 - 然后用 <code>:wq</code> 保存文件退出），可以实现对已有倒数 3 条 Commit 进行编辑更改（<code>HEAD~3</code> 代表倒数 3 条 Commit）:</p><pre><code class="lang-bash">  pick eacff8b complete P5 Boston Housing - Udacity MLforNBs  pick cf56d01 fix bugs, misunderstandings and mistakes in P5 Boston Housing - Udacity MLforNBs  pick a58f305 arrange folders for next Udacity Class - Deep Learning  # Rebase 3e6e796..a58f305 onto 3e6e796 (3 commands)  #  # Commands:  # p, pick = use commit  # r, reword = use commit, but edit the commit message  # e, edit = use commit, but stop for amending  # s, squash = use commit, but meld into previous commit  # f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message  # x, exec = run command (the rest of the line) using shell  # d, drop = remove commit  #  # These lines can be re-ordered; they are executed from top to bottom.  #  # If you remove a line here THAT COMMIT WILL BE LOST.  #  # However, if you remove everything, the rebase will be aborted.  #  # Note that empty commits are commented out</code></pre><p>例子 - 重命名最新一条 Commit 的信息（message）:</p><ol><li><p>将目标 Commit 前的关键词 <code>pick</code> 改成 <code>r</code> :</p><pre><code class="lang-bash">pick eacff8b complete P5 Boston Housing - Udacity MLforNBspick cf56d01 fix bugs, misunderstandings and mistakes in P5 Boston Housing - Udacity MLforNBsr a58f305 arrange folders for next Udacity Class - Deep Learning# Rebase 3e6e796..a58f305 onto 3e6e796 (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit</code></pre></li><li><p>用 <code>:wq</code> 保存文件退出（这是 vi 编辑器的保存退出方式）；</p></li><li><p>在弹出的又一个使用 vi 编辑器打开的文件中，修改 Commit 信息（commit message）；</p><pre><code class="lang-bash">arrange folders for next Udacity Class - Deep Learning    # &lt;- 修改这行信息# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.## Date:      Wed Jul 4 15:59:36 2018 +0800## interactive rebase in progress; onto 929522f# Last commands done (10 commands done):#    pick cf56d01 fix bugs, misunderstandings and mistakes in P5 Boston Housing - Udacity MLforNBs#    reword a58f305 arrange folders for next Udacity Class - Deep Learning# Next commands to do (5 remaining commands):#    pick b02f9b2 add new version of P5 with Python 3+#    pick e2e1a5f add data visualized codes in Question 1st# You are currently editing a commit while rebasing branch &#39;master&#39; on &#39;929522f&#39;.</code></pre></li><li><p>用 <code>:wq</code> 保存文件退出；</p></li><li><p>再次查看最新的 3 条 Commit 信息，可以发现刚刚的 Commit 被更改了（Commit 的 Hash 值也变了）:</p><pre><code class="lang-bash">$ git log --oneline | head -n 3670afa6 I changed this commit - arrange folders for next Udacity Class - Deep Learningcf56d01 fix bugs, misunderstandings and mistakes in P5 Boston Housing - Udacity MLforNBseacff8b complete P5 Boston Housing - Udacity MLforNBs</code></pre></li></ol><p>Interactive Rebase 还可以实现「改变 Commit 的顺序」，「把两个 Commit 合并」还有「删除某个 Commit 」等操作，具体可以参考使用 <code>git rebase -i HEAD~3</code> 命令后，vi 编辑器打开的文件中注释部分的说明（上面的例子中也展示了注释部分）</p><hr><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><pre><code class="lang-bash">## 切换分支$ git checkout [分支名]## 新建分支$ git checkout -b [分支名]## 查看所有分支$ git branch -a [分支名]## 删除分支（删除 A 分支需要切换到 A 之外的分支上）$ git branch -d [分支名]   ## 删除已经 merge 过了的分支，通常已经是 merge 到 master 分支上了$ git branch -D [分支名]   ## 强制删除该分支，无论该分支是否 merge 到其他分支过</code></pre><p><code>git checkout</code> 的另一种操作（实现从之前的 commit 处新发展一条分支）：</p><pre><code class="lang-bash">## 切换到某一个 commit$ git checkout [Commit ID]## Example$ git branch  master* chpw-dev## 查看 Commit ID$ git logcommit 86d2b225d27f3ba7fc06164c9961a98a08e3f525 (HEAD -&gt; chpw-dev)Author: abc &lt;abc@gmail.com&gt;Date:   Tue Aug 7 15:40:29 2018 +0800    add senario that location info is unauthorizedcommit c9e39a3975dcd2d380a7436bd8e3c4bba34cb0b0Author: abc &lt;abc@gmail.com&gt;Date:   Tue Aug 7 13:57:28 2018 +0800    get and show current location on all pages## 根据上面的 ID 信息，切换到前一个 Commit$ git checkout c9e39a3975dcd2d380a7436bd8e3c4bba34cb0b0Note: checking out &#39;c9e39a3975dcd2d380a7436bd8e3c4bba34cb0b0&#39;.You are in &#39;detached HEAD&#39; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example:  git checkout -b &lt;new-branch-name&gt;HEAD is now at c9e39a3... get and show current location on all pages## 切换后处于一个 detached HEAD$ git branch* (HEAD detached at c9e39a3)  master  chpw-dev## 以当前的 detached HEAD 为起点，新建分支$ git checkout -b newBranchFromPreCommitSwitched to a new branch &#39;newBranchFromPreCommit&#39;$ git branch  master  chpw-dev* newBranchFromPreCommit</code></pre><h4 id="恢复被删除的-Git-分支"><a href="#恢复被删除的-Git-分支" class="headerlink" title="恢复被删除的 Git 分支"></a>恢复被删除的 Git 分支</h4><p>参考 <a href="https://stackoverflow.com/questions/3640764/can-i-recover-a-branch-after-its-deletion-in-git" target="_blank" rel="noopener">Can I recover a branch after its deletion in Git?</a></p><hr><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><p>生成 SSH 验证：<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">Generating a new SSH key</a></p><pre><code class="lang-bash">$ cd ~   ## 切换到 home 目录下## 这个命令会在当前文件夹下生成一个 .ssh 目录，里面包含 id_rsa 和 id_rsa.pub 两个文件## 要用的是 id_rsa.pub 里的内容，这个是公钥 ## id_rsa 则是私钥，里面的内容则不能泄露$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;   # 这里的 your_email@example.com 指的是你的邮箱名字## 上面用的是 rsa 加密算法，如果用的是 Ed25519 算法，则命令如下## 这个命令生成的就是 id_ed25519 和 id_ed25519.pub 这两个文件$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;## 上述命令运行后，一路回车，使用默认值即可，完成后会在当前目录下创建完毕## 有些古老的系统不支持 ed25519 加密算法，所以就只能用 rsa 算法加密。GitHub 官方推荐 Ed25519</code></pre><p>设置 SSH 验证，以 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 为例</p><pre><code class="lang-bash">## cat 这个命令可以查看 id_ed25519.pub 里的内容$ cat id_ed25519.pub## 复制这段以 ssh-ed25519 开头的内容## 在 Github 的「Setting」-&gt;「SSH and GPG keys」中输入，完成添加</code></pre><p>设置远程主机</p><pre><code class="lang-bash">$ git remote add [远程主机名] [地址]## 显示所有远程仓库$ git remote -v## 移除本地记录的远程主机$ git remote rm [远程主机名]</code></pre><p>将本地最新代码推送到远程主机完成更新</p><pre><code class="lang-bash"># push 基本指令$ git push [远程主机名] [本地分支名]:[远程分支名]# Example$ git push heroku ch08:master# 第一次推送 master 分支时，加上 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令 - git push 和 git pull$ git push -u origin master# 推送本地的 chpw-dev 分支到远程主机的 chpw-dev 分支上，并将本地的 chpw-dev 分支设置为追踪（track）远程分支 chpw-dev# Branch &#39;chpw-dev&#39; set up to track remote branch &#39;chpw-dev&#39; from &#39;origin&#39;# 下次在本地的 chpw-dev 分支上就可以直接用简单命令 git push 来推送 chpw-dev 分支了$ git push -u origin chpw-dev:chpw-dev# 推送本地所有分支$ git push --all</code></pre><hr><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>关于文件 .gitignore 的用法，参考<a href="https://help.github.com/articles/ignoring-files/" target="_blank" rel="noopener">这里</a></p><hr><h3 id="Git-Submodule"><a href="#Git-Submodule" class="headerlink" title="Git Submodule"></a>Git Submodule</h3><p>新建，更新和同步 Submodule 参考<a href="/2016/10/08/sync-blog-between-multiple-Macs/">多台电脑间的 Hexo 博客同步</a>中 Submodule 功能部分的说明</p><hr><h3 id="更新从别人那-Fork-来的-Repository"><a href="#更新从别人那-Fork-来的-Repository" class="headerlink" title="更新从别人那 Fork 来的 Repository"></a>更新从别人那 Fork 来的 Repository</h3><p>假设我们 Fork 了 Repo <a href="https://github.com/cisco/ChezScheme" target="_blank" rel="noopener">cisco/ChezScheme</a>，接下来可以使用下面的步骤获取最新更新，进而更新我们 Fork：</p><ol><li><p>从自己的账号上下载 Fork 过来的 Repo:</p><pre><code class="lang-bash">$ git clone git@github.com:chpwang/ChezScheme.git</code></pre></li><li><p>设置 Repo 的 remote:</p><pre><code class="lang-bash">$ pwd~/ChezScheme   ## 当前处于了刚 Clone 下来的 Repo 目录## 目前存在一个名为 origin 的 remote ，指向自己账号旗下的项目 Fork$ git remote -vorigin  git@github.com:chpwang/ChezScheme.git (fetch)origin  git@github.com:chpwang/ChezScheme.git (push)## 添加原始 Repo 的 remote 地址（下面的代码将其命名为 upstream）## 命令为 git remote add [upstream_name] [path_to_repo]$ git remote add upstream git@github.com:cisco/ChezScheme.git## 添加新 remote 之后，一共存在两个 remote ，一个名为 origin 指向自己的 Repo ，一个名为 upstream 指向原始 Repo$ git remote -vorigin  git@github.com:chpwang/ChezScheme.git (fetch)origin  git@github.com:chpwang/ChezScheme.git (push)upstream  git@github.com:cisco/ChezScheme.git (fetch)upstream  git@github.com:cisco/ChezScheme.git (push)</code></pre></li><li><p>从原始 Repo 下载更新（新的 Commit）然后合并在本地的 Repo 对应分支上（下面例子是 master 分支）:</p><pre><code class="lang-bash">$ git pull upstream master</code></pre></li><li><p>上传本地更新后的代码到自己账户下 Fork 过来的 Repo ，进而实现更新:</p><pre><code class="lang-bash">$ git push origin master</code></pre></li></ol><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入手新 Mac 后的环境搭建</title>
      <link href="/2017/03/14/setup-new-mac/"/>
      <url>/2017/03/14/setup-new-mac/</url>
      
        <content type="html"><![CDATA[<p>搬家都是耗时的，为了尽可能节省时间，在这里记录下个人基本环境搭建。</p><hr><h3 id="Command-Line-Tools"><a href="#Command-Line-Tools" class="headerlink" title="Command Line Tools"></a>Command Line Tools</h3><p>虽然通过完整安装 Xcode 就能获得 Command Line Tools ，但 Xcode 太大，太费时间，推荐使用以下方法：</p><p>打开 Mac 自带的终端 Terminal.app 输入以下指令</p><pre><code class="lang-bash">$ git</code></pre><p>Mac 会提示你 <code>git</code> 这一命令不存在，需要安装 Command Line Tools ，接着就根据提示联网安装即可</p><p>下面这个是正式的安装命令，<strong>幂等</strong>的哦</p><pre><code class="lang-bash">$ xcode-select --install</code></pre><p>Command Line Tools 里包含很多 Linux 默认安装里有的实用工具软件（命令）。</p><p>可在 <code>/Library/Developer/CommandLineTools/usr/bin/</code> 里查看这些软件。</p><hr><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p><a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a> 是一款软件管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能，很方便。</p><pre><code class="lang-bash">$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></pre><p>Homebrew 常用指令</p><pre><code class="lang-bash">## 安装（软件），更新，检查可更新的软件$ brew search [formulae]   # 查询包含关键词的软件 formulae$ brew install [formulae]  # 安装指定的软件 formulae$ brew update              # brew 自我更新$ brew upgrade [formulae]  # 更新指定的软件 formulae$ brew outdated            # 查询本地版本低于当前最新版本的软件$ brew cleanup [formulae]  # 清除本地安装包，释放硬盘空间 - 加关键词就清除指定安装包，不加就全部清除</code></pre><p>更多信息可以参考官网<a href="https://docs.brew.sh/FAQ" target="_blank" rel="noopener">这里</a>，包括重新安装 Homebrew</p><hr><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>安装好 Command Line Tools 之后，就已经有 Git 了，但并非最新版，追求最新版 Git 需要使用 Homebrew 来安装</p><pre><code class="lang-bash">$ brew install git# 查看 Git 的版本号$ git -vgit version 2.44.0</code></pre><p>安装好之后要记得设置一下 Git 的一些参数</p><pre><code class="lang-bash">$ git config --global user.name &quot;xxxxx&quot;         ## Git 用户名$ git config --global user.email &quot;xxx@xxx.com&quot;  ## Git 邮箱$ git config --global color.ui true             ## Git 命令的输出文字色彩化# 显示当前的 Git 配置$ git config --list</code></pre><p>Git 的一些常用命令整理见<a href="/2018/01/02/Git-Basics/">这里</a></p><hr><h3 id="安装-Fish-Shell"><a href="#安装-Fish-Shell" class="headerlink" title="安装 Fish Shell"></a>安装 Fish Shell</h3><p><a href="https://fishshell.com" target="_blank" rel="noopener">Fish</a> 是一款更好用的 shell ，各种操作都比较符合直觉，在 MacOS 上安装也方便</p><pre><code class="lang-bash">## 成功安装 fish 后会提示如何设置才能开始正常使用 fish shell$ brew install fish==&gt; Installing fish==&gt; Downloading https://homebrew.bintray.com/bottles/fish-2.7.1.high_sierra.bottle.tar.gz######################################################################## 100.0%==&gt; Pouring fish-2.7.1.high_sierra.bottle.tar.gz==&gt; CaveatsYou will need to add:  /opt/homebrew/bin/fishto /etc/shells.Then run:  chsh -s /opt/homebrew/bin/fishto make fish your default shell.## 如果已经安装过 fish shell , 可以使用以下方式来升级 fish$ brew upgrade fish</code></pre><p>根据上面的提示，fish 安装在 <code>/opt/homebrew/bin/fish</code> 目录下（目录可能会变，以实际为准），所以还需要将其添加到 <code>/etc/shells</code><br>因为只有在 <code>/etc/shells</code> 文档里记录的 shell 才能正常访问电脑（正常登陆）</p><pre><code class="lang-bash">## 此操作会更改 /etc/shells 内容，需要输入管理员密码$ echo &quot;/opt/homebrew/bin/fish&quot; | sudo tee -a /etc/shells## 查看当前所有可用的 shell$ cat /etc/shells## 查看当前正在使用的 shell$ echo $SHELL</code></pre><p>接着将 fish 设置成终端默认的 shell</p><pre><code class="lang-bash">$ chsh -s /opt/homebrew/bin/fish</code></pre><p>最后是一些常用的自定义设置，更多教程可参看<a href="https://fishshell.com/docs/current/tutorial.html" target="_blank" rel="noopener">官网</a>或者这篇<a href="https://hackercodex.com/guide/install-fish-shell-mac-ubuntu/" target="_blank" rel="noopener">博客</a></p><pre><code class="lang-bash">## 建立 config.fish 文件，该文件相当于 ~/.bashrc 或者 ~/.zshrc 文件，用于 shell 的初始化设置$ mkdir -p ~/.config/fish$ vi ~/.config/fish/config.fish## 设置一个名为 CPPFLAGS 的环境变量，并将它的值设定为 &quot;-I/opt/homebrew/opt/openjdk/include&quot;## -gx 是两个选项的组合## -g 表示这个变量是全局的，意味着它在当前会话及其之后启动的任何子进程中都可用## -x 表示这个变量将被导出到环境变量，这样其他程序也能访问它。$ set -gx CPPFLAGS &quot;-I/opt/homebrew/opt/openjdk/include&quot;## 在 fish 中注销变量$ set -e [变量名]## Example$ set -e https_proxy## 环境变量 $PATH 包含了各种命令（软件）的路径，各个 shell 们运行命令时都会从里面找## 在 fish shell 中，环境变量 $PATH 的数据类型是一个链表（List），而不是一个包含分号（;）的字符串（String）## 登陆 Terminal 时，fish 预载入的环境变量其实是  $fish_user_paths + $PATH ，所以常用以下方式来初始化当前用户的环境变量## 以下命令会将 /opt/homebrew/bin 永久添加到 $fish_user_paths ，进而每次登陆 Terminal 都会自动载入该路径$ fish_add_path /opt/homebrew/bin## 查看当前 fish_user_paths 的内容$ echo $fish_user_paths/opt/homebrew/bin## 查看当前 PATH 的内容$ echo $PATH/opt/homebrew/bin /usr/local/bin /usr/bin /bin /usr/sbin /sbin</code></pre><p>自定义 fish shell 的提示符内容（Customize Prompt）可以通过更改配置文件 <code>fish_prompt.fish</code> 中的函数 <strong>fish_prompt</strong> 来实现：</p><pre><code class="lang-bash">## ~/.config/fish/functions/fish_prompt.fish### Example ###function fish_prompt --description &#39;Write out the prompt&#39;        set -l home_escaped (echo -n $HOME | sed &#39;s/\//\\\\\//g&#39;)   set -l pwd (echo -n $PWD | sed &quot;s/^$home_escaped/~/&quot; | sed &#39;s/ /%20/g&#39;)   set -l prompt_symbol &#39;&#39;   switch $USER       case root toor; set prompt_symbol &#39;#&#39;       case &#39;*&#39;;  set prompt_symbol &#39;$&#39;   end   printf &quot;%s@%s: %s%s%s %s &quot; $USER (hostname -s) (set_color $fish_color_cwd) $pwd (set_color normal) $prompt_symbolend############################# 上述配置下提示符的输出格式为：## username@hostname: ~ $</code></pre><hr><h3 id="安装-Fisher"><a href="#安装-Fisher" class="headerlink" title="安装 Fisher"></a>安装 Fisher</h3><p><a href="https://github.com/jorgebucaran/fisher" target="_blank" rel="noopener">Fisher</a> 也是一款软件管理工具，专门配合 <a href="https://fishshell.com" target="_blank" rel="noopener">Fish Shell</a>  使用。这里主要是为了后续安装 <a href="https://github.com/jorgebucaran/nvm.fish" target="_blank" rel="noopener">nvm.fish</a> 方便。</p><pre><code class="lang-bash">## 可以直接通过 Hombrew 来安装$ brew install fisher## 这个是官方的安装方式curl -sL https://raw.githubusercontent.com/jorgebucaran/fisher/main/functions/fisher.fish | source &amp;&amp; fisher install jorgebucaran/fisher## 查看当前已安装的插件$ fisher list## 更新指定软件$ fisher update jorgebucaran/fisher## 卸载 fisher 和所有通过 fisher 安装的软件$ fisher list | fisher remove</code></pre><hr><h3 id="安装-NVM-Node-Version-Manager"><a href="#安装-NVM-Node-Version-Manager" class="headerlink" title="安装 NVM - Node Version Manager"></a>安装 NVM - Node Version Manager</h3><p><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">NVM</a> 是用来管理 <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> 的，让我们可以在不同版本的 <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> 之间切换。<br>后续搭建博客用的 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 依赖于老版本的 <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> 。所以用 NVM 来安装和切换新老版本是最明智的。<br>由于用的是 <a href="https://fishshell.com" target="_blank" rel="noopener">Fish Shell</a> ，所以这里安装的是更方便的 <a href="https://github.com/jorgebucaran/nvm.fish" target="_blank" rel="noopener">nvm.fish</a>。</p><pre><code class="lang-bash">## 通过 fisher 安装 nvm.fish$ fisher install jorgebucaran/nvm.fish## 安装并使用最新版本的 Node.js$ nvm install latest## 查看远程有哪些 Node.js 版本可以下载$ nvm list-remote    ...    ...    v13.14.0      v14.0.0     v14.1.0    ...    ...## 安装 v13.14.0 版本的 Node.js$ nvm install v13.14.0## 切换到 v13 版本的 Node.js 来使用## 由于只安装了 v13.14.0 版本，本地的 v13 只有它，所以会切换到这个版本$ nvm use v13## 显示本地有哪些版本的 Node.js 以及当前正在使用的版本$ nvm list     system ▶ v13.14.0</code></pre><hr><h3 id="安装并设置-iTerm2"><a href="#安装并设置-iTerm2" class="headerlink" title="安装并设置 iTerm2"></a>安装并设置 iTerm2</h3><p>如果觉得 MacOS 自带的 Terminal 还不够好用和个性化，可以考虑使用 iTerm2 。</p><p>从<a href="https://www.iterm2.com" target="_blank" rel="noopener">官网</a>下载 iTerm2 安装完后，再下载主题样式（Theme）<a href="http://ethanschoonover.com/solarized/files/solarized.zip" target="_blank" rel="noopener">Solarized</a> (你也可去找其他的 Theme，安装同理)</p><p>解压刚刚下载的 <code>solarized.zip</code> 文件之后，打开 <strong>iTerm2</strong> 做以下操作：</p><ul><li><code>Preferences</code> -&gt; <code>Profiles</code> -&gt; <code>Colors</code> -&gt; <code>Color Presets</code> -&gt; <code>Import</code>，载入 iterm2-colors-solarized 目录下的两个 itermcolors 文件</li><li><code>Preferences</code> -&gt; <code>Profiles</code> -&gt; <code>Colors</code> -&gt; <code>Color Presets</code> ，选择 Solarized Dark</li><li><code>Preferences</code> -&gt; <code>Profiles</code> -&gt; <code>Text</code> -&gt; <code>Change Font</code>，可选择字体和字号（建议 Menlo 字体）</li></ul><p>将 Mac 键盘上的左 <strong>option</strong> 键映射为 <strong>Esc+</strong> ，以便在 iTerm2 里就可以使用 <strong>option</strong> + <strong>delete</strong> 组合来删除一个单词，设置方法如下：</p><ul><li><code>Preferences</code> -&gt; <code>Profiles</code> -&gt; <code>Keys</code></li></ul><hr><h3 id="Hexo-博客环境搭建"><a href="#Hexo-博客环境搭建" class="headerlink" title="Hexo 博客环境搭建"></a>Hexo 博客环境搭建</h3><p>按以下方法搭建 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 博客的环境，更多参见<a href="/2016/10/08/sync-blog-between-multiple-Macs/">多电脑间同步 Hexo 博客</a></p><pre><code class="lang-bash">## 上面安装 nvm.fish 的环节已经安装了 Node.js ，所以这里就有 npm 命令了## 使用 Node.js 自带的 npm 安装 Hexo$ npm install hexo-cli -g## 安装 SASS - 将 .scss 文件编译成 .css 文件的工具$ brew install node-sass   ## 还有以下两个常用命令来更新和查看 package.json 里所记录的套件$ npm update    #更新套件$ npm outdated  #查看哪些套件过期（即有新版本）</code></pre><hr><h3 id="安装-Sublime"><a href="#安装-Sublime" class="headerlink" title="安装 Sublime"></a>安装 Sublime</h3><p>Sublime 是一款常用的编辑器，可以去其<a href="https://www.sublimetext.com" target="_blank" rel="noopener">官网</a>下载，如果不付费使用，则<strong>每</strong>数个保存操作后会跳出未注册的提示</p><p>安装完成后打开 Sublime ，使用快捷键 <code>Command</code> + <code>,</code> 打开设置界面<br>在右侧 <strong>Preferences.sublime-settings - User</strong> 页的<code>{}</code>内添加以下两行</p><ul><li><code>&quot;translate_tabs_to_spaces&quot;: true,</code></li><li><code>&quot;tab_size&quot;: 2</code></li></ul><p>注：<br>第一行末尾有英文输入法的逗号“<code>,</code>”；<br>第二行是最后一行，可以没有逗号；<br>这两行是设置 <strong>Tap 键</strong>和 <strong>Space 键</strong>的缩进（indentation）效果：第一行将所有 <strong>Tab</strong> 转换成 <strong>Space</strong>，第二行指定每个 <strong>Tab</strong> 换成 2 个 <strong>Space</strong>；</p><p>接着建立快捷方式以便在 Terminal 里快速打开</p><pre><code class="lang-bash">## 以下命令可以在 /usr/local/bin/ 目录下建立 Sublime 的快捷方式，用于快速调用$ sudo ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl ## 建好快捷方式后的使用例子$ subl .   #打开当前目录</code></pre><h4 id="Sublime-的常用操作："><a href="#Sublime-的常用操作：" class="headerlink" title="Sublime 的常用操作："></a>Sublime 的常用操作：</h4><ul><li><p><strong>注释代码</strong>：选中目标内容后，使用快捷键 <code>Command + /</code> 。 sublime 会自动识别当前文件的语言（也可以在 sublime 窗口右下角手动选择语言类型），并使用当前语言的注释方法注释选中内容。如果当前文件包含多语言，那注释的时候就要<strong>右下角手动选择语言</strong>，注释完后再改回来；</p></li><li><p><strong>文件夹里全文件搜索和替换</strong>：鼠标右键 Sublime 左侧导航窗口中的某个文件夹 -&gt; <code>Find in Folder...</code> ，在弹出的窗口里，Find 一栏输入关键词即可搜索该文件夹中<strong>所有</strong>包含关键词的文件。如果要同时替换，就在 Replace 一栏输入用于替换关键词的内容即可；</p></li><li><p><strong>保存所有已打开文件</strong>：可通过 <code>File</code> -&gt; <code>Save All</code> 保存，Mac 也可用快捷键：<code>Option + Command + S</code>；</p></li><li><p><strong>关闭所有已打开文件</strong>：可通过 <code>File</code> -&gt; <code>Close All Files</code> 关闭；</p></li></ul><hr><h3 id="Rails-开发环境搭建（可选）"><a href="#Rails-开发环境搭建（可选）" class="headerlink" title="Rails 开发环境搭建（可选）"></a>Rails 开发环境搭建（可选）</h3><p>安装 <code>ImageMagick</code> 函数库 - 用于今后 Rails 开发中处理图片</p><pre><code class="lang-bash">$ brew install imagemagick</code></pre><p>安装 <code>PostgreSQL</code> - Rails 网站开发常用数据库</p><pre><code class="lang-bash">$ brew install postgresql$ brew services start postgresql  ## 启动数据库服务</code></pre><p>安装 <code>RVM</code> - Ruby Version Manager 用来管理 Ruby 的版本</p><pre><code class="lang-bash">$ \curl -sSL https://get.rvm.io | bash -s stable$ source ~/.rvm/scripts/rvm    ## 安装完 rvm 会提示使用该命令来让 rvm 生效</code></pre><p>如果用的是 <strong>Fish</strong> Shell 而不是 <strong>Bash</strong> Shell, 则 <code>RVM</code> 需要用以下方法安装，参考<a href="https://rvm.io/integration/fish" target="_blank" rel="noopener">RVM 官网说明</a>，因为 Fish 不兼容 Bash (not bash-compatible)<br>此外，如果是从 <strong>Bash</strong> Shell 切换到 <strong>Fish</strong> Shell ，发现各种 RVM 等开发的相关种命令都找不到了，也可通过以下设置来使得 RVM 和原来的 Rails 正常运行</p><pre><code class="lang-bash">## 这串命令本质上是从 Github 上下载一套指令集放在 Fish Shell 的初始化设置文件夹里，让 Fish Shell 每次启动的时候都运行一次，设置好各种环境变量$ curl -L --create-dirs -o ~/.config/fish/functions/rvm.fish https://raw.github.com/lunks/fish-nuggets/master/functions/rvm.fish# activate the default Ruby manually in your config.fish file:$ echo &quot;rvm default&quot; &gt;&gt; ~/.config/fish/config.fish</code></pre><p>安装好 <code>RVM</code> 后再安装一个套件 <code>libxml</code>（后面开发会用到）</p><pre><code class="lang-bash">$ brew install libxml2</code></pre><p>安装所需版本的 <code>Ruby</code> - 以 2.3.1 版本为例</p><pre><code class="lang-bash">$ rvm install 2.3.1$ rvm list                ## 该命令可查看本地存在的所有 Ruby 的版本$ rvm use 2.3.1 --default ## 该命令用于设置默认的 Ruby 版本$ gem update --system     ## 用于救回安装 rvm 过程中网络等原因造成的中断失败$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/  ## 设置新的 gem 的来源网站</code></pre><p>搞定了 Ruby 之后我们就有了 <code>gem</code> 这个命令，接下来用它安装 <strong>Rails</strong></p><pre><code class="lang-bash">$ gem install rails## 也可以指定 Rails 的版本来安装$ gem install rails -v 5.0.0## 看情况可尝试管理员模式安装$ sudo gem install rails</code></pre><p><strong>注意</strong>：2017 年以后的 MacOS 抛弃了 <code>OpenSSL</code>，导致需要安装 <code>OpenSSL</code> 才能运行 <code>gem</code> 这个命令。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识 Ethereum - 以太坊</title>
      <link href="/2016/11/20/ethereum-for-newbies/"/>
      <url>/2016/11/20/ethereum-for-newbies/</url>
      
        <content type="html"><![CDATA[<p>以太坊（ <a href="https://ethereum.org" target="_blank" rel="noopener">Ethereum</a> ）是区块链世界里举足轻重的项目之一。事实上，对很多刚进入区块链行业的人来说，了解了以太坊，几乎就具备了在区块链世界里生存所必须的所有技术性的知识。</p><p>希望这些知识有助于大家对区块链世界里五花八门的项目进行理解和价值判断。</p><hr><h3 id="计算的本质"><a href="#计算的本质" class="headerlink" title="计算的本质"></a>计算的本质</h3><p>以太坊的起源和比特币（ <a href="https://bitcoin.org" target="_blank" rel="noopener">Bitcoin</a> ）有很大的关系，为此我们需要重新了解一下比特币的交易（ Transaction ）过程，也就是说，比特币网络中产生一笔交易的时候，到底发生了什么？而为了简单且精准地解释这个问题，让我们抛开比特币、以太坊还有区块链，先来看看计算的本质是什么，然后从本质出发，一步步类比下去。</p><p>以下三个例子都是生活中常见的计算，而每一种计算的过程都可以用下图中所展示的<strong><code>「 输入输出模型 」</code></strong>来描绘：</p><ul><li>「 1 + 1 」   <code>-&gt;</code> 「 计算器 」   <code>-&gt;</code> 「 2 」</li><li>「 手指纹 」   <code>-&gt;</code> 「 Touch ID 」<code>-&gt;</code> 「 软件解锁行为 」</li><li>「 上升的温度 」 <code>-&gt;</code> 「 水银温度计 」<code>-&gt;</code> 「 温度计示数 」<img src="/2016/11/20/ethereum-for-newbies/inout.gif" title="IO model"></li></ul><p>可以看到，作为<strong>「 输入 」</strong>和<strong>「 输出 」</strong>的东西不限于数字和符号，而作为处理这些「 输入 」并给出「 输出 」的<strong>「 设备 」</strong>也不一定是电脑。它们甚至可以是更加奇妙的东西，比如真空，比如暗物质，比如你的梦境。</p><p>比特币的交易也是这样一个<strong>「 输入输出 」</strong>的过程，它的输入输出如下：</p><ul><li>「 发币地址，收币地址，币的数量 」<code>-&gt;</code>「 比特币的区块链 」<code>-&gt;</code>「 发币地址币的数量，收币地址币的数量」</li></ul><p>对于这些<strong>「 输入输出 」</strong>的过程，我们不必去关心其中的计算是如何实现的，只需知道<strong>「 设备 」</strong>所要求的「 输入 」是怎样的，以及对应的预期「 输出 」即可。比如，我们只需要知道「 比特币的区块链 」这一<strong>设备</strong>能在接收了特定的「 输入 」后，给出特定的「 输出 」就行了。</p><p><code>PS:</code><br><code>注意，区块链世界里，你必须拥有「 密钥 」才能发起「 输入 」行为</code></p><hr><h3 id="以太坊的诞生"><a href="#以太坊的诞生" class="headerlink" title="以太坊的诞生"></a>以太坊的诞生</h3><p>通过以上<strong><code>「 输入输出模型 」</code></strong>的介绍，你不难发现，其中的<strong>「 设备 」</strong>扮演了一个很重要的角色，正是<code>它</code>，决定了人们到底能给什么样的「 输入 」并得到什么样的「 输出 」。</p><p>举个例子来说，「 水银温度计 」这一设备就无法接收「 1 + 1 」这种数据，它只能接收「 温度 」这一类型的数据。</p><p>同样的，「 比特币的区块链 」也只能接收 <code>「 发币地址，收币地址，币的数量，手续费 」</code>这类数据，因为「 比特币的区块链 」作为<strong>「 设备 」</strong>，只有记账这个单一的功能。</p><p>那么「 区块链 」能否有记账以外的其他功能呢？能否接收更多种类的「 输入 」并给出更多种类的「 输出 」？或者再进一步，「 区块链 」这一设备能不能成为电脑，具有无限可能性，而不仅仅是记账呢？</p><p>以太坊（ Ethereum ）正是在这一背景下诞生的，它的目标是：</p><blockquote><p><code>在「 区块链 」上实现一台世界性的电脑，一台全世界共用的电脑。</code></p></blockquote><hr><h3 id="以太坊的特点"><a href="#以太坊的特点" class="headerlink" title="以太坊的特点"></a>以太坊的特点</h3><p>由于区块链技术的特征，即通过挖矿行为来维护整条链的数据和运作，以太坊这台电脑与生俱来地具有以下特点：</p><ul><li><p>和作为账簿记录每个钱包里有多少钱的「 比特币区块链 」不同，以太坊区块链（简称以太坊，和<strong>比特币的区块链</strong>是两条不同的链）作为一台电脑，记录的是所有在它上面运行的软件的数据和代码；</p></li><li><p>在以太坊这台电脑上运行软件是需要付钱的，通过以太币（ ETH ）这一代币支付。以太币可以在各大交易所买到；</p></li><li><p>「 比特币的区块链 」这本账簿是由整个网络一起维护的，即每个结点（ Node ）都有一本完整账簿。这些众多相互独立的结点各自记账相互制约，保证了账簿的安全性，正确性和可信度（数据不可更改）；同样，以太坊这台电脑也是由整个网络一起维护的，每个结点（ Node ）都运行着一整台电脑，并存储了这台电脑上的所有数据。这些众多相互独立的结点各自运行着的电脑所组成的网络，也保证了以太坊这台电脑的可靠性（永不关机不掉线）和可信度（数据不可更改）；</p></li><li><p>由于处于区块链上，软件的某个操作最终会在成千上万台电脑上都进行一遍，上万台电脑只相当于一台电脑的性能。尽管这个问题今后会慢慢改进，但在未来相当长的时间里，会一直这样；</p></li><li><p>以太坊这台电脑升级起来非常麻烦，它要求以太坊社区里的所有人一起升级，即硬分叉；</p></li><li><p>对电脑来说，定期的升级是必要的，所以会经常看到以太坊进行硬分叉；</p></li><li><p>以太坊目前的出块时间是 15 秒，也就是说，以太坊这台电脑上的程序运行起来会有 15 秒的卡顿。当然，这个时间将来会继续减少。顺便说一句，每次以太坊遭遇 DDOS 攻击也会造成卡顿，其原理是丢给以太坊一个极其消耗性能的程序，让电脑卡机。不过在以太坊这台电脑上运行程序需要支付以太币，昨天的硬分叉后发动 DDOS 攻击已经非常昂贵，基本只有土豪或以太一生黑才玩得起；</p></li><li><p>区块链现在计算能力和存储能力都不强，还只能处理数字这种简单的东西，所以以太坊这台电脑的性能目前还只有八九十年代的水平；</p></li><li><p>以太坊这台世界性电脑适用于需要解决大规模信用问题的场景，还适用于对账过程中的冲突问题以及类似问题——比如银行的对账，再就是适用于有「 永不<code>被</code>关机 」需求的领域；</p></li></ul><p><code>PS:</code><br><a href="https://firstblood.io" target="_blank" rel="noopener">Firstblood</a> <code>是即将在以太坊上运行的 App 之一，有兴趣可以点击了解</code></p><hr><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><p>问：哪里可以查看以太坊的出块信息和以太坊上的应用代币信息？</p><p><strong>答：</strong>可以前往以太坊的<a href="https://etherscan.io" target="_blank" rel="noopener">区块链浏览器</a>查看。</p><p>问：如何知道以太坊的最新进展？</p><p><strong>答：</strong>前往以太坊的<a href="https://blog.ethereum.org" target="_blank" rel="noopener">官方博客</a>查看。</p><p>问：如果即将出现硬分叉，哪里可以查看以太坊的分叉时间？</p><p><strong>答：</strong><a href="https://fork.codetract.io" target="_blank" rel="noopener">这里</a>。</p><p>问：有没有靠谱的以太坊中文社区？</p><p><strong>答：</strong>有，<a href="http://ethfans.org" target="_blank" rel="noopener">ETHFANS</a> 。</p><p>问：以太坊主网频繁出问题对上面的应用的影响程度有多大？</p><p><strong>答：</strong>要看是什么问题，分叉还是被 DDOS 攻击。分叉通常没问题，因为分叉意味着以太坊的升级。DDOS 攻击则会造成网络拥堵，让以太坊上的软件无法正常执行，可以通过硬分叉修复以太网的 Bug ，进而恢复网络。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用闲置电脑进行 Zcash 挖矿</title>
      <link href="/2016/10/29/zcash-mining-for-newbies/"/>
      <url>/2016/10/29/zcash-mining-for-newbies/</url>
      
        <content type="html"><![CDATA[<p>这是一篇面向新手的指南，旨在让新手能迅速开始挖矿，感受挖矿的“乐趣”。<br>以下挖矿的原理是：共享出个人电脑闲置的性能，通过 <a href="https://www.nicehash.com" target="_blank" rel="noopener">Nicehash</a> 矿池提供的挖矿软件接入矿池挖矿。收益通过钱包地址发送，极其简单无需注册。</p><hr><h3 id="马上开始"><a href="#马上开始" class="headerlink" title="马上开始"></a>马上开始</h3><ol><li><p>第一步：下载 Windows 64位 挖矿程序 <a href="https://github.com/nicehash/nheqminer/releases/download/0.3a/nheqminer_v0.3a.zip" target="_blank" rel="noopener">nheqminer_v0.3a.zip</a></p></li><li><p>第二步：解压缩刚刚下载好的 nheqminer_v0.3a.zip，得到如下文件 <img src="/2016/10/29/zcash-mining-for-newbies/nheqminer_folder.jpg" title="nheqminer folder"></p></li><li><p>第三步：在刚刚解压缩出 nheqminer_v0.3a.zip 的目录下新建 .txt 文件 <img src="/2016/10/29/zcash-mining-for-newbies/new_txt.jpg" title="create new txt file"></p></li><li><p>第四步：在新建的 .txt 文件里输入以下内容并保存（<strong>记得换成你的 Zcash taddr 地址，不然就帮我挖矿了</strong>）：<img src="/2016/10/29/zcash-mining-for-newbies/edit_txt.jpg" title="edit txt file"><br>该指令格式说明（提示：Zcash taddr 可使用<a href="https://yunbi.com" target="_blank" rel="noopener">云币网</a>的 ZEC 充值地址）：<br>```<br>nheqminer_zcash.exe -l [服务器] -u [你的 Zcash 透明地址 taddr ] -t [CPU 线程数]</p></li></ol><p>例一（美国服务器：usa ；CPU 使用 4 线程）:<br>nheqminer_zcash.exe -l usa -u t1Zhfs3eQ1WKwGopqrRPU3HwoHoqDeRCAMu -t 4</p><p>例二（香港服务器：hk ；CPU 使用所有能用的线程 - 不指定线程数就是默认使用所有线程）:<br>nheqminer_zcash.exe -l hk -u t1Zhfs3eQ1WKwGopqrRPU3HwoHoqDeRCAMu</p><pre><code>5. 第五步：将新建 .txt 文件，改名为 start.bat（注意，.txt 的后缀扩展名要改成 .bat，如果你看不到文件的后缀名查看[这里](https://www.baidu.com/s?wd=windows%20显示扩展名&amp;rsv_spt=1&amp;rsv_iqid=0xd30749d3000510ab&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;oq=windows%20显示后缀&amp;rsv_t=0ce2JpopNnbqqamM3bFDWHkst3rJ9nrHTYNAa%2F5LF366Tkjpuf4bl0CcP2S8t5dk8DNe&amp;rsv_pq=a43ff0f500053033&amp;rsv_sug3=29&amp;rsv_sug1=29&amp;rsv_sug7=100&amp;bs=windows%20显示后缀)） {% asset_img change_to_bat_file.jpg change to bat file %}6. 第六步：双击 `start.bat` 运行，开始挖矿：{% asset_img start_mining.jpg start mining %}7. 第七步：到[这里](http://zcash.nicehash.com/workers)输入 **第四步** 里你使用的 Zcash taddr 地址可查看你的挖矿状态和收益情况 {% asset_img mining_status.jpg mining status %}---### 用比特币结算挖矿收益上一节中介绍的挖矿方式是使用 Zcash 进行收益结算的，如果你希望使用**比特币**来结算你的收益，只需将**第四步**中输入 .txt 文件里的指令改成下面这行即可（**注意**，后面的比特币地址要换成你自己的哦，不然就是帮我挖矿啦）：</code></pre><p>nheqminer.exe -l usa -u 1G4gexikM2b3xbUpy9G5yUKtKEqTwNhGwX</p><pre><code>更改保存后，双击运行 `start.bat` 开始挖矿，然后在[这里](https://www.nicehash.com/?p=miners&amp;a=24)可以通过你使用的比特币地址查看挖矿状态和收益---### 让显卡也加入挖矿上面采用的是 CPU 来挖矿，现在我们让 GPU 也一起吧。还是只需更改**第四步**的指令即可：* 对于 Nvidia 显卡的 Windows 电脑</code></pre><p>只有一张 Nvidia 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -cd 0</p><p>有两张 Nvidia 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -cd 0 1</p><p>有两张以上 Nvidia 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -cd 0 1 2 …</p><pre><code>* 对于 AMD 显卡的 Windows 电脑</code></pre><p>只有一张 AMD 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -od 0</p><p>有两张 AMD 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -od 0 1</p><p>有两张以上 AMD 显卡：<br>nheqminer_zcash.exe -l usa -u [Zcash taddr 地址] -t [CPU 线程] -od 0 1 2 …</p><pre><code>PS:如果要用比特币结算，只需将 `nheqminer_zcash.exe` 改成 `nheqminer.exe` ，并把 `Zcash taddr 地址` 改成 `比特币钱包地址` 即可。---### 还有一些有用的如果你查看矿池发现拒绝率比较高，很可能你所连接的服务器速度慢，需要更换**第四步**中的服务器地址，比如从 `usa` 变成 `hk`。你可以通过以下测试查看各个服务器的延迟：1. 打开 cmd.exe 软件 {% asset_img cmd.jpg cmd exe %}2. 输入 `ping -n 50 -l 128 [服务器地址]` 回车查看延迟，例如</code></pre><p>C:\Users\Twentynight&gt;ping -n 50 -l 128 speedtest.eu.nicehash.com</p><p>正在 Ping speedtest.ams01.softlayer.com [159.253.132.18] 具有 128 字节的数据:<br>来自 159.253.132.18 的回复: 字节=128 时间=345ms TTL=128<br>来自 159.253.132.18 的回复: 字节=128 时间=358ms TTL=128<br>来自 159.253.132.18 的回复: 字节=128 时间=347ms TTL=128<br>…</p><p>所有可选服务器地址如下：<br>欧洲： speedtest.eu.nicehash.com<br>美国： speedtest.usa.nicehash.com<br>香港： speedtest.hk.nicehash.com<br>日本： speedtest.jp.nicehash.com<br>```</p><ol><li>时间越少，速度越快。选择时间最少的服务器</li></ol><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老猫的区块链新手分享会</title>
      <link href="/2016/10/24/blockchain-for-newbies/"/>
      <url>/2016/10/24/blockchain-for-newbies/</url>
      
        <content type="html"><![CDATA[<p>2016年10月22日下午，<a href="http://weibo.com/fngm" target="_blank" rel="noopener">老猫</a>在北京组织了针对新人的线下「区块链分享会」，本文是该分享会的内容整理，主要包括以下几个部分：</p><ul><li><a href="http://weibo.com/fngm" target="_blank" rel="noopener">老猫</a>的自我介绍</li><li>区块链行业</li><li>BCA俱乐部的价值取向</li><li>云币网</li><li>比特币扩容之争</li><li>新手如何少踩坑</li></ul><hr><h3 id="老猫"><a href="#老猫" class="headerlink" title="老猫"></a>老猫</h3><p>「老猫」这个 ID 最早的诞生和他喜欢养猫有关，伴随他行走江湖已超过六年；</p><p>猫叔最早是做淘宝的，后来做了用比特币交易商品的网站叫「菠萝集市」；</p><p>和云币的交集始于<a href="http://weibo.com/hpyhck" target="_blank" rel="noopener">邱亮</a>关于「貔貅交易所」的客户调查，两人一见如故。「貔貅交易所」是「云币网」的前身，是<a href="http://weibo.com/bylixiaolai" target="_blank" rel="noopener">李笑来</a>创建的，邱亮是 CEO + CTO。一次接触后，猫叔被招致麾下，负责起了交易所的运营，还有后来「比特币生存指南」即现在「BCA 俱乐部」的运营。</p><hr><h3 id="区块链的世界"><a href="#区块链的世界" class="headerlink" title="区块链的世界"></a>区块链的世界</h3><p>区块链行业现状可用一个字来形容：乱。其中不靠谱的项目极多；</p><p>当前（2016年10月22日）行业主要分为两大群体，一是“比特币派”，其观点是「唯比特币独尊，看衰其他区块链应用」，二是“区块链派”，观点是「持续观察和分析各种区块链应用，不排斥比特币以外的区块链应用」。两种观点都有其背后的逻辑，老猫属于“区块链派”；</p><p>老猫将原支付宝群「比特币生存指南」更名为「BCA 俱乐部」的原因之一就是为了呼吁抛弃「唯比特币独尊」的观念；</p><p>区块链作为一项技术有很多方面的应用，<a href="https://bitcoin.org/" target="_blank" rel="noopener">比特币</a>是其中的一种应用，即作为数字货币的应用，<a href="https://www.ethereum.org/" target="_blank" rel="noopener">以太坊</a>又是另一种应用，即作为平台的应用。比特币由于是最早的应用，经历了时间考验，所以在很长一段时间里几乎是区块链世界里的唯一经济形态。老猫认为，区块链技术在其他领域的应用所带来的机会已经远超比特币；</p><p>区块链技术适合用于「需要解决大规模信任问题」的领域，所以可以通过这一点来判断某个区块链项目是否靠谱（该项目是否有必要解决大规模信任问题）。</p><hr><h3 id="BCA俱乐部"><a href="#BCA俱乐部" class="headerlink" title="BCA俱乐部"></a>BCA俱乐部</h3><p>BCA 俱乐部两大价值：</p><ul><li>培养合格的区块链资产投资者</li><li>成为区块链行业红利的分享者</li></ul><p>BCA 俱乐部不是炒币群，重视项目的真正价值，而不是短期波动。</p><hr><h3 id="云币网"><a href="#云币网" class="headerlink" title="云币网"></a>云币网</h3><p>2014年10月1日，「貔貅交易所」正式更名为「云币」；</p><p>云币网是一家以为国内投资者提供全球优秀区块链资产为目标的交易平台，目前成长速度飞快！</p><p>老猫介绍了历史运营数据和准备推出的新产品「众托」，但为防泄密，这里不详细展开。</p><p>老猫还重点介绍了以下区块链资产品种：</p><ul><li><p>比特币（BitCoin）- 当前（2016年10月24日）市值最高的数字货币；</p></li><li><p>以太坊 (Ethereum) - 开发平台，专门用于开发「去中心化应用」，比如 DGD 和 1SŦ。基于该平台的应用之间可以很容易进行经济互动；</p></li><li><p>DGD (DigixDAO) - DGX 的分红权。DGX 是第一个和黄金锚定的数字货币。使用 DGX 的过程中收取的各种费用依据持有的 DGD 的比例分红。DGD 的总量固定为 200 万个；</p></li><li><p>SC (SiaCoin) - 去中心化云存储的代币。一个真正可用的商业化区块链项目。下载<a href="https://sia.tech/" target="_blank" rel="noopener">客户端</a>后，可以使用代币储存文件。Sia 的储存原理是：将你上传的文件拆成 10 块，储存在分布于世界各地的电脑上。这些电脑属于不同的人，他们提供了自己闲置的硬盘空间来储存你的文件，你的 SiaCoin 代币将支付给他们。由于是分布式，其安全性高到甚至可以放心将比特币密钥存在上面。</p></li><li><p>1SŦ (FirstBlood) - 竞技游戏的代币。玩竞技游戏的双方使用该代币对赌，比赛结束后谁胜利谁就赢取代币。比赛的裁判也会从中抽取一部分代币作为手续费。裁判是系统随机选取的，且有信用评级机制，保证比赛的公正性和赌金的安全性；</p></li><li><p>ZEC (Zcash) - 匿名货币。和比特币的货币功能一样，只不过增加了「零知识证明」来保证交易的匿名性。交易的匿名很重要，因为能够把自己隐藏起来是一种终极的自由。目前只有 Zcash 的「零知识证明」保证了 100% 的匿名，其他的数字货币都无法做到 100%。</p></li></ul><hr><h3 id="比特币扩容之争"><a href="#比特币扩容之争" class="headerlink" title="比特币扩容之争"></a>比特币扩容之争</h3><p>区块链是记录所有交易的一个总账目，每一个块都记录了一定数目的交易，然后所有区块首尾相连形成一条链，保证总账目不可被更改。当前（2016年10月24日）每个区块能记录的交易大约在 1800 笔，即每秒钟只能处理 3 笔交易。扩容是为了能在一定的时间内处理更多的数目交易。根据 Visa 在 2015 年的<a href="http://investor.visa.com/news/news-details/2016/Visa-Inc-Reports-Fiscal-First-Quarter-2016-Results/default.aspx" target="_blank" rel="noopener">记录</a>，全球 2015 年全年一共进行了 920 亿笔交易，相比之下，当前的比特币每年只能进行 9460 万笔交易。从量级来看，如果不扩容，比特币是完全无法作为全球性的货币的。</p><p>实现「交易数增加」的这一目标已经是所有人的共识，但是如何实现却一直无法统一。所以，扩容的争论关键在于扩容的方案。每个方案背后都有各自的逻辑，还牵扯到很多商业和政治的利益，所以争了一年多都没有结论。</p><p>比特币的扩容之争可能会影响比特币的未来，尽管比特币当前（2016年10月24日）还是最好的数字货币。</p><hr><h3 id="如何少踩坑"><a href="#如何少踩坑" class="headerlink" title="如何少踩坑"></a>如何少踩坑</h3><p>不玩杠杆 - 交易所在后台都能看到你的交易数据，所以会被爆仓；</p><p>不玩理财 - 区块链资产价值波动太大，理财方很难兑现承诺以比特币兑付的利息；</p><p>时间长，额度足 - 资本的力量来自于「时间」和「额度」，所以投资要用闲钱，而且要淡定，不要被短期波动影响。不用闲钱无法做到淡定，容易陷入低卖高买的困境；</p><p>谨慎选择品种 - 当前区块链项目很多都是不靠谱的，尤其国内的项目。一定要通过看该项目解决了什么问题来判断价值；</p><p>注意保护密钥 - 不能所有账号都用同一个密码，比如邮箱的密码和银行的密码不能一样。推荐购买 1Password 来管理密码。</p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写 Alfred Workflow</title>
      <link href="/2016/10/14/alfred-workflow/"/>
      <url>/2016/10/14/alfred-workflow/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.alfredapp.com" target="_blank" rel="noopener">Alfred</a> 是 Mac 上重要的生产力工具，可自定义的工作流（<a href="https://www.alfredapp.com/help/workflows/" target="_blank" rel="noopener">Workflow</a>）是它的招牌功能，其作用相当于轻量级的 App，将日常重复繁琐的操作简化成一条简单的命令，进而提高效率。本文将教你如何创造 Workflow 。</p><p>你需要购买 Alfred 的 <a href="https://www.alfredapp.com/powerpack/buy/" target="_blank" rel="noopener">Powerpack</a> 才能使用 Workflow 功能。</p><p>Tips:<br>自从 <a href="https://www.dropbox.com/" target="_blank" rel="noopener">Dropbox</a> 把它的默认文件夹移动到 <code>~/Library/CloudStorage/Dropbox</code> 之后，<strong>Alfred</strong> 就无法搜索该文件夹里面的文件和内容了。解决方法是：</p><p>「<code>Alfred Preferences</code>」-&gt;「<code>Default Results</code>」-&gt;「<code>Search Scope</code>」-&gt;「<code>Reset</code>」-&gt;「<code>Reset to Applications and Home</code>」</p><p>参考资料：<a href="https://www.alfredforum.com/topic/20042-alfred-cant-find-files-stored-on-dropbox/" target="_blank" rel="noopener">Alfred can’t find files stored on Dropbox</a></p><hr><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>每当看到程序员准备造物时，班长总会情不自禁地分享他的庸俗境界：</p><blockquote><p>身为程序员，没事不要写程序。</p><footer><strong>班长</strong></footer></blockquote><p>事实上，社区里已经存在近 1000 个别人写好的 Workflow，你可以在 Alfred 的官方网站看到推荐的常用 <a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">Workflow</a>，你也可以到 <a href="http://www.packal.org" target="_blank" rel="noopener">Packal</a> 这个社区里，搜索更多适合你的 Workflow。</p><p>通过双击下载下来的 <code>.workflow</code> 文件，就可以导入 Alfred 里了。下载的页面会说明使用方法，一般都是关键词命令，后接参数。比如这个叫做 <a href="http://www.packal.org/workflow/simple-timer" target="_blank" rel="noopener">Simple Timer</a> 的 Workflow，用的是这样的语法：<code>timer [时间] [信息]</code> （设定一段时间后弹出对应的信息内容进行提醒）<br></p><p>不过在很多情况下，每个人的生产方式是高度差异化的，所以最终，我们很可能还是不得不自己动手。</p><p>根据「行动先于思考」的学习原则，我们先不管为什么和是什么，而是马上动手实现一个简单的 Workflow 再吐槽。</p><p>PS：<br>注意哦，一定要不加思索地跟着往下做，不要管为什么哈……^_^</p><hr><h3 id="Wi-Fi-Toggle"><a href="#Wi-Fi-Toggle" class="headerlink" title="Wi-Fi Toggle"></a>Wi-Fi Toggle</h3><p>这一小节，我们将创建一个打开和关闭 Wi-Fi 的 Workflow</p><ul><li><p>第一步，打开 Alfred 的 Preferences，点击 <code>+</code> 新建一个空白的 Workflow </p></li><li><p>第二步，填入下图的数据（你可以把 Create By 这栏的作者名换成你自己） </p></li><li><p>第三步，黑区域右键新建 Workflow 对象：「 Inputs 」-&gt;「 Keyword 」 </p></li><li><p>第四步，如下图设置 Keyword 对象的各个参数，并保存： </p></li><li><p>第五步，右键新建第二个 Workflow 对象：「 Actions 」-&gt;「 Run Script 」 </p></li><li><p>第六步，如图所示设置 Run Script 对象，并保存：<br>其中，填入 Script 一栏的代码如下</p><pre><code class="lang-bash">networksetup -setairportpower en0 $1## 如果你在终端(terminal)中直接输入这段代码可以开关 Wifi## 不过在终端(terminal)里，上面的 $1 要替换成「 on 」或者「 off 」</code></pre></li><li><p>第七步，选中 Keyword 对象，拖拽边缘的凸起，连接 Run Script 对象： </p></li></ul><p>小功告成！现在可以通过 Alfred 使用 <code>wifi [on/off]</code> 指令快速开关 Wifi 了<br></p><p><code>快速解说:</code><br>上述实现 Wi-Fi Toggle 的 Workflow 本质上是实现终端中的一段命令：</p><pre><code class="lang-bash">$ networksetup -setairportpower en0 on## 在终端(terminal)中直接输入这段代码可以打开 Wifi## 注意到，在终端(terminal)里，「 第六步 」中的 $1 要替换成「 on 」或者「 off 」##「 第六步 」中的 $1 其实代表的是 Keyword 对象中传过来的参数，即「 on 」或者「 off 」##「 第七步 」的连接操作指明了参数的传递方向：「 Keyword 」-&gt;「 Run Script 」</code></pre><hr><h3 id="按需学习"><a href="#按需学习" class="headerlink" title="按需学习"></a>按需学习</h3><p>从上面的例子里我们不难发现，创建 Alfred 的 Workflow 大体只有三个环节：</p><ul><li><p>建立各种功能对象（Object）</p></li><li><p>设计各参数（Argument）在这些对象（Object）之间的传递方向</p></li><li><p>按照所设计的参数（Argument）传递方向连接这些对象（Object）</p></li></ul><p>短时间掌握所有对象的用法是非常反人类的，我们采用「 <strong>需要时再说</strong> 」的哲学，所以这里只需要学会以下关于搜索的两招就行了：</p><ol><li><p>第一招，通过左下角的「 + 」-&gt;「 Getting Started 」建立出 Workflow ，这些 Workflow 介绍了常用的对象（Object）和 常用的 Worflow 套路 </p></li><li><p>第二招，双击对象（Object）可以调出该对象的设置面板，单击左下角的问号可以调出该对象的使用文档，里面有例子教你如何使用</p></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上，如果你做完了本教程 WiFi 的 Workflow ，你就已经入门。</p><p>如果你花半小时把上面第一招中提到的「 Getting Started 」里的十个 Workflow 看过一遍，你就已经具备所有关于 Workflow 的知识，能看懂并修改别人的 Workflow 了。</p><p>然而，实现复杂功能（所谓 <em>Simplicity is hidden complexity</em>，让生产力提高好几个量级的超实用型 Workflow 通常是复杂的）需要的是 Workflow 之外的技能，比如要会使用网站的 API，比如会使用 Ruby 、Python 之类的编程语言等等，而这些技能已经超出了本教程的篇幅，需要大家自行修炼。</p><p>了解了 Alfred 的 Workflow 功能仅仅只是让我们的技能池里又多了一块积木，这块积木需要搭配其他积木才能正常使用。上述教程让大家学会了 Workflow 如何搭配其他积木进行使用，至于如何获得其他积木，则是另一个话题了。通常班长会建议优先修改别人已经写好的 <a href="http://www.packal.org" target="_blank" rel="noopener">Workflow</a> ，正像他庸俗境界描述的那样：</p><blockquote><p>身为程序员，没什么事的话……不要写程序。</p><footer><strong>班长</strong></footer></blockquote><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为 Github 上的 Hexo 博客绑定个性域名</title>
      <link href="/2016/10/09/customize-your-blog-domain/"/>
      <url>/2016/10/09/customize-your-blog-domain/</url>
      
        <content type="html"><![CDATA[<p>使用 Hexo 部署博客之后，尽管可以通过 <a href="https://你的用户名.github.io" target="_blank" rel="noopener">https://你的用户名.github.io</a> 来访问，但由于各种各样的原因，博主们通常倾向于更换这个教条式的域名，使用属于自己的个性域名。以下就是一个简单的教程。</p><hr><h3 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h3><p>推荐到 <a href="https://www.namesilo.com" target="_blank" rel="noopener">namesilo</a> 上注册账号购买，不仅比 <a href="https://www.godaddy.com" target="_blank" rel="noopener">Godaddy</a> 便宜，本身还免费提供隐私服务（即不公开域名持有者的信息）。对了， <a href="https://www.namesilo.com" target="_blank" rel="noopener">namesilo</a> 支持支付宝付款。</p><hr><h3 id="创建-CNAME-文件"><a href="#创建-CNAME-文件" class="headerlink" title="创建 CNAME 文件"></a>创建 CNAME 文件</h3><p>使用 <code>hexo d</code> 命令部署时，实际上是将 <code>~/Documents/blog/public</code> 文件夹的内容 push 到 [username].github.io 上，这样会把 <code>CNAME</code> 文件覆盖掉，而把 <code>CNAME</code> 文件添加到 <code>source</code> 文件夹里，可以避免这种情况。</p><p>在 <code>~/Documents/blog/source</code> 目录下新建 <code>CNAME</code> 文件</p><pre><code class="lang-bash">$ cd ~/Documents/blog/source$ touch CNAME</code></pre><p>编辑 <code>CNAME</code> 文件，输入你购买的域名，比如 <code>cps.ninja</code>（没错，整个 <code>CNAME</code> 文件只有一个顶级域名，没有别的内容）</p><p>然后把 <code>CNAME</code> 文件部署到 Github 上</p><pre><code class="lang-bash">$ hexo clean$ hexo g$ hexo d</code></pre><hr><h3 id="设置域名"><a href="#设置域名" class="headerlink" title="设置域名"></a>设置域名</h3><p>访问 <a href="https://www.namesilo.com" target="_blank" rel="noopener">namesilo</a>（或是你购买域名的网站），登陆你的账户，进入设置域名的控制台，做如下设置</p><pre><code>@          A             192.30.252.153@          A             192.30.252.154www      CNAME           chpwang.github.io</code></pre><p>效果如图：<br><img src="/2016/10/09/customize-your-blog-domain/domain_settings.jpg" title="domain settings"></p><p>其中 <code>192.30.252.153</code> 和 <code>192.30.252.154</code> 都是 Github 的地址（该地址现已改变，Github 最新的 IP 地址参见<a href="https://help.github.com/en/articles/troubleshooting-custom-domains#dns-configuration-errors" target="_blank" rel="noopener">这里</a>），而最后一行的 <code>chpwang.github.io</code> 你要换成 <code>你的用户名.github.io</code>（更多详细内容参见 Github <a href="https://help.github.com/en/articles/troubleshooting-custom-domains#dns-configuration-errors" target="_blank" rel="noopener">官方文档</a>）。</p><p>至此，个性域名设置完毕，只需等待生效即可。</p><pre><code>上图 Type 一栏说明    A：  用来指定域名为 IPv4 的地址（如：8.8.8.8），如果需要将域名指向一个IP地址，就需要添加 A 记录 AAAA：  与上述 A 记录的区别是，AAAA 记录用来指定域名为 IPv6 的地址（如：2001:DB8:2de:0:0:0:0:e13）CNAME：  如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录</code></pre><p>解释：</p><ul><li>总的来说，设置 A 记录的意思是，当我输入 <code>cps.ninja</code> 这个域名的时候，访问的是 <code>192.30.252.153</code> 这个地址；</li><li>而设置 <code>CNAME</code> 的意思是说，当我访问 <code>chpwang.github.io</code> 这个地址的时候，会跳转到 <code>cps.ninja</code>，之后的过程就和 A 记录相同了，即访问 <code>192.30.252.153</code></li></ul><hr><p>P.S.<br>1、如果你希望将博客部署在国内，可以考虑使用 <a href="http://coding.net" target="_blank" rel="noopener">Coding</a>；<br>2、部署在国内的博客，要注意 CSS 里的字体调用可能因网络问题加载失败；<br>3、可以用 <a href="https://www.dnspod.cn" target="_blank" rel="noopener">DNSPod</a> 而不是自带的域名解析服务，参考<a href="http://shaojunxiao.com/2017/04/01/Hexo-blog-域名解析/" target="_blank" rel="noopener">这里</a>；<br>4、知乎上的<a href="https://www.zhihu.com/question/31377141/answer/103056861" target="_blank" rel="noopener">这个回答</a>也描述了绑定域名的事，也可以看看；</p><p>关于这里域名设置的更多知识和详情，还可参考以下链接：</p><ul><li><a href="http://winterttr.me/2015/10/23/from-dns-to-github-custom-domain/" target="_blank" rel="noopener">从 DNS 到 github pages 自定义域名 — 漫谈域名那些事</a></li><li><a href="http://stackoverflow.com/questions/23375422/how-to-setup-github-pages-to-redirect-dns-requests-from-subdomain-e-g-www-to" target="_blank" rel="noopener">How to setup Github Pages to redirect DNS requests</a></li><li><a href="https://coolcao.com/2016/10/19/从搭建hexo个人博客过程中理解学习DNS解析/" target="_blank" rel="noopener">从搭建hexo个人博客过程中理解学习DNS解析</a></li><li><a href="https://jums.club/config-ssh-for-github/" target="_blank" rel="noopener">hexo绑定个人域名之后，不能访问，已经解决</a></li></ul><hr><h2 id="后续可能遇到的问题"><a href="#后续可能遇到的问题" class="headerlink" title="后续可能遇到的问题"></a>后续可能遇到的问题</h2><p>有时候使用 <code>hexo d</code> 部署更新博客之后，会出现绑定的域名指向 github 404 的情况。使用 <code>username.github.io</code> 能正常访问博客页面，但使用自定义域名（比如 <code>cps.ninja</code>）则会出现 github 404 页面。</p><p>如果不是上面提到的 <code>CNAME</code> 文件被覆盖掉的问题，那原因可能是 Github Pages 的 Settings 下 Custom domain 清空了，需要重新设置。</p><p>到博客的 repository 页面的 <code>Settings -&gt; Pages -&gt; Custom domain</code> 输入域名，应该就解决了。如果失败提示 <strong>“the CNAME is already taken”</strong>，那就需要去 <a href="https://support.github.com/request/pages" target="_blank" rel="noopener">GitHub Support</a> ，选择 <strong>Help with a custom domain</strong> 发 ticket（工单）求助。</p><p>求助前最好要先认证你的域名，确定这个域名的所有权确实在你那。具体操作是： <code>头像 -&gt; Settings -&gt; Pages -&gt; Add a domain</code> ，然后根据提示，去域名服务商那里新增一个 TXT 的 DNS 解析记录进行验证。<br>更详细的操作请查看 <a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages" target="_blank" rel="noopener">Verifying your custom domain for GitHub Pages</a>。</p><p>参考链接：<br><a href="https://preblog.wangqy.top/2018/05/26/CNAME/" target="_blank" rel="noopener">github pages 出现 “the CNAME is already taken” 的解决办法</a><br><a href="https://cloud.tencent.com/developer/article/1452987" target="_blank" rel="noopener">GitHub Pages 对自定义域名支持 HTTPS</a><br><a href="https://senzyo.net/2022-5/" target="_blank" rel="noopener">GitHub Pages使用问题 - 自定义域名已被占用</a></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多台电脑间的 Hexo 博客同步</title>
      <link href="/2016/10/08/sync-blog-between-multiple-Macs/"/>
      <url>/2016/10/08/sync-blog-between-multiple-Macs/</url>
      
        <content type="html"><![CDATA[<p>由于文化程度低，所以只能靠使用多台电脑来满足随时写文章的需要。这里记录一下多电脑间同步博客的方法。</p><hr><h3 id="配置第一台电脑"><a href="#配置第一台电脑" class="headerlink" title="配置第一台电脑"></a>配置第一台电脑</h3><p>确保你在 <code>~/Documents/blog</code> 文件夹里</p><pre><code class="lang-bash">$ pwd~/Documents/blog    ## 确保在正确的目录下</code></pre><p>使用 Mac 自带的 Git 对 <code>~/Documents/blog</code> 文件夹进行追踪</p><pre><code class="lang-bash">$ pwd~/Documents/blog    ## 确保在正确的目录下$ git init$ git add .$ git commit -m &quot;initial commit&quot;</code></pre><p>到 Github 上新建一个 <code>repository</code>，命名为 <code>blog</code>（可以选自己喜欢的名字），然后把本地的 <code>blog</code> 文件夹推送到 Github 上</p><pre><code class="lang-bash">$ pwd~/Documents/blog    ## 确保在正确的目录下$ git remote add origin git@github.com:你的用户名/blog.git$ git push -u origin master</code></pre><p>找到自己喜欢的 Theme（主题），然后 fork 一份 Theme 的代码到自己的 Github 账户下面<br><img src="/2016/10/08/sync-blog-between-multiple-Macs/how_to_fork.jpg" title="fork a theme project"></p><p>之所以要 fork 一份，是因为你很可能要进一步开发这个 Theme，把它改成你想要的样子。比如我的博客的主题选择的是 <a href="https://github.com/gaoryrt" target="_blank" rel="noopener">Gaoryrt</a> 老师开发出来的主题 <a href="https://github.com/gaoryrt/hexo-theme-pln" target="_blank" rel="noopener">pln</a>，但该主题只有 60% 的部分是我喜欢的，要改的地方非常多。</p><p>有些玩家是主题（Themes）和文章（Posts）混在一起进行版本控制的，我则喜欢将两者分开维护，即<strong>「内容」和「样式」分离</strong>。所以接下来的操作就是要把 Theme 独立成为一个模块，在 Git 的版本控制下进行维护和修改。</p><p>这里使用 Git 的 Submodule 功能，将博客的 Theme（主题样式）模块化出去</p><pre><code class="lang-bash">$ cd ~/Documents/blog/themes$ git submodule add git@github.com:你的用户名/hexo-theme-pln.git</code></pre><p>上面的两条命令会把你 fork 过来的主题下载到 <code>~/Documents/blog/themes</code> 目录下，由于主题名为 <code>pln</code>，所以我们会看到 <code>~/Documents/blog/themes</code> 目录下多了一个文件夹 <code>pln</code>，主题就存在这个文件夹里。</p><p>此外 <code>git@github.com:你的用户名/hexo-theme-pln.git</code> 这串地址可以在你的 Github 账户下对应的 <code>repository</code> 中找到（当 fork 某个 project 之后，会在你的 Github 账户下生成一个  <code>repository</code> ）<br><img src="/2016/10/08/sync-blog-between-multiple-Macs/find_submodule_address.jpg" title="find submodule address"></p><p>仔细的你可能已经注意到 <code>~/Documents/blog/themes/pln</code> 目录下有个 <code>.git</code> 文件，因为 <code>pln</code> 文件夹在被生成之后就被 Git 追踪了，这也意味着无需再在 <code>pln</code> 文件夹里使用 <code>git init</code> 来对它开启追踪。</p><p><strong>注意！</strong>这时我们面对的是一个普通玩家从未遇到的情况：</p><blockquote><p><code>一个被 Git 追踪的文件夹里（blog 文件夹）存在着另一个同样被 Git 追踪的文件夹（pln 文件夹），这两个文件夹的根目录下都有一个 .git 文件</code></p></blockquote><p>Don’t panic! 这正是 Git 的 Submodule 功能的效果，目前一切正常。现在我们暂时先不管细节，带着这些看起来很重要的不自在继续前行。</p><p>好，我们接着进入 <code>pln</code> 文件夹，并使用 <code>git checkout master</code>切换到 Git 的主分支 Master（之所以需要切换，是因为新生成的 Submodule 文件夹，即 <code>pln</code> 下，默认不在任何分支上，不像平时我们对某个文件夹 <code>git init</code> 之后就默认在主分支 Master）</p><pre><code class="lang-bash">$ cd ~/Documents/blog/themes/pln$ git checkout master</code></pre><p>然后修改 <code>pln</code> 文件夹里的内容得到满意的风格（如果已经满意可以不修改）</p><pre><code class="lang-bash">$ pwd~/Documents/blog/themes/pln  ## 当前在 pln 目录，注意下面 sass 命里涉及到的相关路径$ git branch* master                     ## 确保在 master 分支上，不然 commit 就跑到 detached HEAD 上了## 对主题的样式做各种改动（和平时的 Git 操作一样）## 注意若是修改了 CSS 样式，要压缩生成 m.min.css 才能生效，网站因为最终采用的 CSS 是 m.min.css## main.scss 和 m.min.css 文件都在 blog/themes/pln/source/css 目录下$ sass --style compressed source/css/main.scss:source/css/m.min.css$ git add .$ git commit -m &quot;change pln theme to meet my taste&quot;</code></pre><p>每次修改 <code>pln</code> 文件夹里的 <strong>css</strong> 代码后，只要运行上述 <code>sass</code> 命令，刷新<strong>本地</strong>网站就能看到修改后的 CSS Style 样式效果。还可以借助 <a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Chrome</a> 等浏览器的<strong>开发者模式</strong>来辅助探索 CSS 的效果。如此反复修改、运行、观察，直到满意为止。</p><p>在 <code>pln</code> 里各种 <code>commit</code> 之后，我们终于感觉可以 <code>push</code> 了，于是</p><pre><code class="lang-bash">$ pwd~/Documents/blog/themes/pln     ## 确保在正确的目录下$ git push</code></pre><p>这样一来，Github 上我们之前 fork 过来的主题 <code>pln</code> 就成功同步更新了。</p><p>这时我们切换到 <code>blog</code> 文件夹，运行 <code>git status</code>，可以看到 Terminal 提示 <code>pln</code> 文件夹有新的改动需要 commit</p><pre><code class="lang-bash">$ cd ~/Documents/blog$ git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)  (commit or discard the untracked or modified content in submodules)  modified:   themes/pln (modified content)no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>于是我们</p><pre><code class="lang-bash">$ pwd~/Documents/blog     ## 注意当前目录是 blog$ git add themes/pln$ git commit -m &quot;change submodule pln theme to meet my taste&quot;$ git push</code></pre><p>完成后，我们 Github 上 <code>blog</code> 所对应的 <code>repository</code> 也就成功和同步更新了。</p><hr><h3 id="中场解说"><a href="#中场解说" class="headerlink" title="中场解说"></a>中场解说</h3><p>感谢各位玩家勇敢地保持疑惑直到现在，对于已经迷路的各位我准备用一个简单的总结把大家拉回来：</p><ul><li><p>以上对<strong>第一台电脑</strong>的各种操作一共涉及 <code>3</code> 个 Github 上的 <strong><code>Repository</code></strong>：</p><ul><li><code>你的用户名.github.io</code>（如 chpwang.github.io）</li><li><code>blog</code></li><li><code>pln</code></li></ul></li><li><p>Hexo 会把 <code>blog</code> 文件夹里的各种内容转化成 html 文件部署到 <code>你的用户名.github.io</code> 这个 <code>repository</code> 上，所以互联网上通过 <code>http://你的用户名.github.io</code>这个网址看你的博客的人实际上看到的是 <code>你的用户名.github.io</code> 这个 <code>repository</code> 里的内容</p></li><li><p><code>blog</code> 这个 <code>repository</code> 是用来在别的电脑上同步博客内容的。Hexo 每次部署博客都要使用 <code>blog</code> 文件夹里的内容来生成相应的 html 文件。如果我们选择通过 <code>你的用户名.github.io</code> 这个 <code>repo</code> 而不是 <code>blog</code> 来同步博客的话，这意味着我们需要直接编辑 html（<code>你的用户名.github.io</code> 这个 <code>repo</code> 里全是 html 文件），进而无法享受 Markdown 格式排版带来的便利。</p></li><li><p>作为 Submodule 的文件夹（也就是 <code>pln</code>）如果改动了，则需要 commit 两次来保存（<code>pln</code> 文件夹里 commit 一次，<code>blog</code> 文件夹里也要 commit 一次），相应的也要通过两次 <code>git push</code> 来同步远程的两个 <code>repo</code></p></li><li><p><code>blog</code> 文件夹里的改动仅需要 commit 一次保存</p></li></ul><hr><h3 id="配置第二台电脑和之后的电脑"><a href="#配置第二台电脑和之后的电脑" class="headerlink" title="配置第二台电脑和之后的电脑"></a>配置第二台电脑和之后的电脑</h3><p>搞定了第一台电脑的配置，之后就简单多了。</p><p>首先必须确保第二台电脑安装了 <a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a> , Node.js, <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 和 <a href="http://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS</a></p><pre><code class="lang-bash">## 这条命令安装 Homebrew$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;## 上条命令完成后，就可以通过 Homebrew 安装 Node.js$ brew install node## Node.js 安装后，会附带 npm（node package manager）工具，可用它来搜索、下载、管理 Node.js 套件## 接下来使用 npm 安装 Hexo$ npm install hexo-cli -g## 安装 SASS - 将 .scss 文件编译成 .css 文件的工具，后面会用于压缩整合 main.scss 文件## 压缩命令为: sass --style compressed main.scss:m.min.css    $ brew install node-sass</code></pre><p>然后在第二台电脑上 <code>git clone</code>，先拉 parent repository，也就是 <code>blog</code></p><pre><code class="lang-bash">$ pwd~/Documents    ## 选择一个目录准备 git clone$ git clone git@github.com:你的用户名/blog.git## 这条命令会在当前目录下生成一个 blog 文件夹</code></pre><p><strong>注意</strong>，<code>git clone</code> 之后，虽然 <code>~/Documents/blog/themes/pln</code> 文件夹存在，但里面是空的，因为这是我们第一次在这台电脑上建立 <code>blog</code> 这个文件夹。这第一次，需要我们使用以下两条命令同步作为 Submodule 的文件夹，也就是 <code>pln</code></p><pre><code class="lang-bash">$ pwd~/Documents/blog## 注意此时的目录是 blog，我们要在这个 Parent Directory 下运行下两条命令$ git submodule init       ## 这条命令会读取所有 submodule 的远端地址，这里是 pln 这个 repo 的地址$ git submodule update     ## 这条命令会把 pln 这个 repo 的内容从远端拉下来</code></pre><p>第一次建立之后，如果远端的 <code>pln</code> 文件夹有更新，只需使用 <code>git submodule update</code> 来同步即可，不必再运行 <code>git submodule init</code> 了</p><pre><code class="lang-bash">## 如果不是第一次建立属于 Submodule 文件夹，只需要运行 git submodule update 命令即可（文件夹已存在，例如本例子中的 pln 文件夹就属于 Submodule 文件夹）$ pwd~/Documents/blog## 注意此时的目录是 blog，我们要在这个 Parent Directory 下运行 git submodule update$ git submodule update</code></pre><p><strong>接下来这步很重要</strong>，因为非常反直觉。<br>第一，第一次使用 <code>git submodule update</code> 同步后，我们需要手动切回 master 分支。</p><p>之所以要运行 <code>git checkout master</code> 手动切分支，是因为<strong>每当</strong>我们运行 <code>git submodule update</code> 后，submodule 文件夹（即文件夹 <code>pln</code>）的 Git 默认会指向一个 detached HEAD，也就是说，我们当前并没有处于任何分支上，所以我们需要 <code>git checkout</code> 切换回 master 分支，否则我们的在 <code>pln</code> 文件夹下的所有 commit 都不在任何分支上。</p><p>如果不是第一次使用 <code>git submodule update</code>，当远端有更新内容被拉下来时，所更新的内容会在一个 detached HEAD 上，我们要通过下面的操作将它合并到 master 分支上。</p><pre><code class="lang-bash">$ cd ~/Documents/blog/themes/pln     ## 注意 pln 是作为 submodule 的文件夹$ git status                         ## 查看状态可看到当前处在一个 detached 的 commit 上* (HEAD detached at e522ed6)  master$ git checkout master         ## 手动切回 master 分支Previous HEAD position was e522ed6... change logo againSwitched to branch &#39;master&#39;$ git merge e522ed6           ## 将 detached 的 commit 合并到 master 分支上</code></pre><p>假设你忘了切回 master 分支就改动 <code>pln</code>，那怎么办？别怕，先 commit 保存你的改动，然后像上面一样切回 master 分支，再把 commit 合并到分支上</p><pre><code class="lang-bash">$ git add .$ git commit -m &quot;make some changes but forget to change to branch master&quot;$ git checkout master         ## 手动切回 master 分支Warning: you are leaving 1 commit behind, not connected toany of your branches:  bcfc7fb make some changes but forget to change to branch masterIf you want to keep it by creating a new branch, this may be a good timeto do so with: git branch &lt;new-branch-name&gt; bcfc7fbSwitched to branch &#39;master&#39;Your branch is up-to-date with &#39;origin/master&#39;.$ git merge bcfc7fb           ## 使用 hash 值 bcfc7fb，将其对应的 commit 合并到 master 分支上</code></pre><p>这样，就可以救回你对 <code>pln</code> 文件夹的改动了。</p><p>大致对以上有印象后，现在切换回 <code>blog</code> 文件夹运行 <code>npm install</code> 。这里需要注意的是，如果使用代理运行 npm install 可能会报错乃至失败（例如 proxychains4 npm install），如果失败请不要使用代理。一些其他报错可参考<a href="https://zhangangs.github.io/2018/07/10/解决npm警告：WARN%20registry%20Unexpected%20warning%20for%20httpsregistry.npmjs.org%20Miscellaneous%20Warning%20EINTEGRITY/" target="_blank" rel="noopener">这里</a>或<a href="https://blog.csdn.net/genius_yym/article/details/84645915" target="_blank" rel="noopener">这里</a>。</p><pre><code class="lang-bash">$ cd ~/Documents/blog$ npm install         ## 执行这条命令，npm 会根据 package.json 文件安装所有需要的套件## 刚才 git clone 把云端的文件拉下来之后，blog 文件夹下一个叫 package.json 的文件也被拉了下来，npm install 命令会通过它得知需要安装的套件# 可以使用以下两个命令来更新和查看 package.json 里所记录的套件$ npm update    ## 更新套件$ npm outdated  ## 查看哪些套件过期（即有新版本）</code></pre><p><code>这里要提示一下，npm 这种东西，安全性其实很可疑，个人博客将就着用就行了，但不建议用在敏感产品上，参见</code><a href="https://ruby-china.org/topics/38345" target="_blank" rel="noopener"><code>这篇帖子</code></a></p><p>至此，第二台电脑就同步配置完成，可以继续写文章发布了。总结一下：</p><ol><li><p>使用以下命令写文章和发布</p><pre><code class="lang-bash">$ hexo new &quot;文章标题&quot;## 编辑文章......$ hexo clean   ## 清空缓存$ hexo g       ## 生成静态页面至 public 目录$ hexo server  ## 开启 Server（默认网址 http://localhost:4000/，&#39;ctrl + c&#39; 退出）$ hexo d       ## 部署到 GitHub</code></pre></li><li><p>更改 Submodule 文件夹后（比如 <code>pln</code> 文件夹）需要 commit 两次，里外各一次。同样地，此时需要两次 <code>git push</code> 来同步远程的两个 <code>repo</code></p></li><li><p>更改 parent 文件夹 <code>blog</code> 后只需要 <code>git commit</code> 一次，<code>git push</code> 一次</p></li><li><p>更新本地文件时，先在外层文件夹 <code>blog</code> 中运行 <code>git pull</code> 来更新 <code>blog</code>，然后运行 <code>git submodule update</code> 来更新 submodule 文件夹</p></li><li><p>每次运行 <code>git submodule update</code> 后，submodule 文件夹里的 Git 默认会指向一个 <strong>detached HEAD</strong>，要记得切回 master 分支合并一下从远程更新过来的 commits 再继续。确实不小心忘记了可以回到上面的教程看一下怎么救回来。</p></li><li><p>有时运行 <code>git submodule update</code> 同步子模块时会出现以下报错。这是因为前一台设备在改动 submodule 文件夹之后（本例中为 <code>themes/pln</code> ），忘记使用 <code>git push</code> 推送到远程服务器了，所以命令在请求远程 Server 时，就找不到 <code>commit e8e0dc...</code>（总之，更新 submodule 文件夹需要两次 <code>git push</code>，别忘了哈）</p><pre><code class="lang-bash">## 由于只在 blog 文件夹里 git push，忘记在 blog/themes/pln 里 git push，所以 Git 知道 commit e8e0dc... 的存在，但是却找不到它$ git submodule updateerror: Server does not allow request for unadvertised object e8e0dc399b38f6ba01720c65bd64a1bdb9b68755Fetched in submodule path &#39;themes/pln&#39;, but it did not contain e8e0dc399b38f6ba01720c65bd64a1bdb9b68755. Direct fetching of that commit failed.</code></pre></li><li><p>如果 Node.js 的套件在前一台设备上有更新，则意味着 Git 记录了新的 <code>package.json</code> 文件，此时从 submodule 文件夹里切换回 <code>blog</code> 文件夹运行 <code>npm install</code> 更新即可（命令参考上面的代码）</p></li></ol><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Hexo 搭建自定义博客</title>
      <link href="/2016/10/08/how-to-blog-with-hexo/"/>
      <url>/2016/10/08/how-to-blog-with-hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个基于 <a href="https://nodejs.org/en/about" target="_blank" rel="noopener">Node.js</a> 的静态网站生成器。它可以将 Markdown、Jade 或者其他模板语言的文件转换成静态网页，并且支持丰富的主题和插件。配合 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 就可以搭建自己的博客。</p><p>如果不是闲，或无法忍受其他商业博客方案，不建议用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>，因为自由意味着繁琐。</p><p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 博客的步骤思路大同小异，但每一步都有多种实现方法，接下来的操作都是在 Mac 电脑上的 Terminal（终端）里进行的。</p><hr><h3 id="使用-Hexo-前的环境准备"><a href="#使用-Hexo-前的环境准备" class="headerlink" title="使用 Hexo 前的环境准备"></a>使用 Hexo 前的环境准备</h3><p>安装 <a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a></p><pre><code class="lang-bash">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>使用 <a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a> 安装 Node.js</p><pre><code class="lang-bash">## $ brew install node  # 新版 node 和 hexo 不再兼容，需通过 nvm 来安装老版本的 node</code></pre><p>Node.js 安装后，会附带 npm（node package manager）工具，可用它来搜索、下载、管理 Node.js 套件。</p><p>使用 <a href="http://brew.sh" target="_blank" rel="noopener">Hombrew</a> 安装 <a href="https://formulae.brew.sh/formula/node-sass" target="_blank" rel="noopener">node-sass</a></p><pre><code class="lang-bash">## 安装 SASS - 将 .scss 文件编译成 .css 文件的工具，后面会用于压缩编译 hexo 博客的 main.scss 文件## 压缩命令为: sass --style compressed main.scss:m.min.css    $ brew install node-sass</code></pre><p>接下来使用 npm 安装 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p><pre><code class="lang-bash">$ npm install hexo-cli -g</code></pre><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 套件，其用于之后一键部署 blog 到 Github 上</p><pre><code class="lang-bash">$ npm install hexo-deployer-git --save</code></pre><p>安装 <a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">hexo-generator-index</a> ，其用于单独设置主页（index）的文章（posts）数量——分页（pagination）功能会用到</p><pre><code class="lang-bash">$ npm install hexo-generator-index --save</code></pre><p>安装 <a href="https://github.com/hexojs/hexo-generator-archive" target="_blank" rel="noopener">hexo-generator-archive</a> ，其用于单独设置归档页面（archives）的文章数量——分页功能会用到</p><pre><code class="lang-bash">$ npm install hexo-generator-archive --save</code></pre><p><strong>其它补充说明</strong>：</p><ul><li><p>这里的 <code>--save</code> 参数会让 npm 在安装 hexo-deployer-git 之后自动将它写入 package.json 文件里，这样之后我们<a href="/2016/10/08/sync-blog-between-multiple-Macs/">多电脑间同步博客</a>就不需要再单独运行这条命令了，只需要 npm install ，当然了，这条命令是<code>幂等</code>的（即该命令运行若干次和运行一次的效果一样），所以再运行一次问题也不大。该参数的具体描述可参考<a href="http://stackoverflow.com/questions/19578796/what-is-the-save-option-for-npm-install" target="_blank" rel="noopener">这里</a>。</p></li><li><p>目前使用 <code>npm install xxx</code> 命令安装模块时，似乎不再需要 <code>--save</code> 参数了<a href="http://blog.csdn.net/aaa333qwe/article/details/78021704" target="_blank" rel="noopener">。</a></p></li><li><p>最新版本的 Node 有 Bug（Node 14 之后），和 hexo 不兼容：后续使用 <code>hexo d</code> 命令部署到 Github 的过程会报错。此时等不了更新修复可以先安装旧版（比如 <a href="https://formulae.brew.sh/formula/node@12#default" target="_blank" rel="noopener">Node 12</a> ）来确保 Hexo 能用。具体来说就是，先卸载<strong>当前</strong>版本的 node ，然后安装<strong>旧版本</strong>的 Node ：</p><pre><code class="lang-bash"># Node 和 hexo 不兼容后的报错信息$ hexo d...FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be of type number. Received an instance of Object......</code></pre><p><code>最新说明：当前 node 12 已经 EOL（End Of Life），不能用 homebrew 来安装老版本的 Node.js 了，要用 nvm</code><br><code>此外，兼容 hexo 的最后一版 Node 是 v13.14 ，所以今后就用 v13.14 版的 Node</code></p><pre><code class="lang-bash"># 重新安装 Node 要先删除。从 npm 开始删# 若此前 npm 是通过 brew 安装的，就用 brew uninstall npm 指令删除$ brew uninstall npm# 若此前 npm 是单独安装的（比如官网下载安装包），则用 npm uninstall npm -g 指令删除$ npm uninstall npm -g# 删除当前的 Nodejs - 若此前是通过 brew 安装的 node$ brew uninstall node# 删除当前的 Nodejs - 若是自行独立安装（如官网下载）的 node$ sudo rm -rf /usr/local/lib/node_modules# 重新安装指定版本的 Node 来确保兼容性 - 下面是安装 Node 12 的版本# $ brew install node@12    # 这行指令已经不能安装 node@12</code></pre><p><code>通过 fish 来安装 nvm ，然后再通过 nvm 安装和选用 v13.14 版的 Node</code></p><pre><code class="lang-bash">## 通过 fisher 安装 nvm.fish$ fisher install jorgebucaran/nvm.fish## 安装并使用最新版本的 Node.js$ nvm install latest## 查看远程有哪些 Node.js 版本可以下载$ nvm list-remote    ...    ...    v13.14.0      v14.0.0     v14.1.0    ...    ...## 安装 v13.14.0 版本的 Node.js$ nvm install v13.14.0## 切换到 v13 版本的 Node.js 来使用## 由于只安装了 v13.14.0 版本，本地的 v13 只有它，所以会切换到这个版本$ nvm use v13## 显示本地有哪些版本的 Node.js 以及当前正在使用的版本$ nvm list     system ▶ v13.14.0</code></pre><p>参考链接：<br><a href="https://ammomercy.cn/2021/03/08/2021-03-08-解决hexo-d-The-modeargument-must-be-integer.-问题/" target="_blank" rel="noopener">解决 node.js@14+ 与 hexo 不兼容：作者选择安装 Node 13.14</a><br><a href="https://stackoverflow.com/questions/12607155/error-the-brew-link-step-did-not-complete-successfully/12751548" target="_blank" rel="noopener">先用 <code>npm uninstall npm -g</code> 卸载 <strong>npm</strong> 。再 <code>brew install node@12</code> 安装旧版 <strong>node</strong>，最后再 <code>brew link node@12</code></a>【主要看来自 <a href="https://stackoverflow.com/users/3085/jim-geurts" target="_blank" rel="noopener">@Jim Geurts</a> 和 <a href="https://stackoverflow.com/users/179583/natevw" target="_blank" rel="noopener">@natevw</a> 网友的回复】</p></li></ul><hr><h3 id="开始使用-Hexo"><a href="#开始使用-Hexo" class="headerlink" title="开始使用 Hexo"></a>开始使用 Hexo</h3><p>使用 Hexo 新建一个文件夹命名为 blog ，该文件夹将作为你的博客网站</p><pre><code class="lang-bash">$ hexo init ~/Documents/blog      # 在 ~/Document 这个目录下会出现一个新的文件夹叫 blog，里面包含一些关于 hexo 的基础文件</code></pre><p>进入新建的文件夹</p><pre><code class="lang-bash">$ cd ~/Documents/blog</code></pre><p>刚才 hexo init 命令已经在 blog 文件夹下生成了一个叫 <code>package.json</code> 的文件，npm 会通过它得知需要安装的套件<br>所以接下来使用 npm 安装相关套件</p><pre><code class="lang-bash">$ npm install</code></pre><p>使用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 开启服务器</p><pre><code class="lang-bash">$ hexo s</code></pre><p>打开浏览器，输入网址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能查看刚刚建好的博客页面。目前博客只有一篇名为 <code>Hello World</code> 的文章。</p><p>在刚才的 Terminla（终端）中使用 <code>control + C</code> 的组合键即可关闭服务器。</p><hr><h3 id="开始写文章"><a href="#开始写文章" class="headerlink" title="开始写文章"></a>开始写文章</h3><pre><code class="lang-bash">$ pwd~/Documents/blog</code></pre><p>确保你在 <code>~/Documents/blog</code> 文件夹里之后，便可用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 新建文章</p><pre><code class="lang-bash"># 这个命令会建立一个文件：~/Documents/blog/source/_posts/java-basics.md# 之后就在这个文件里写这篇博客的内容$ hexo new &quot;java basics&quot;</code></pre><p>之后，在 <code>~/Documents/blog/source</code> 这个文件夹里就能看到刚刚新建的，以文章标题命名的文件。点开编辑即可。</p><p>文件内容会包含自动生成的信息头（front matter），直接在下面的位置编辑博客内容就好：</p><pre><code class="lang-plaintext">---title: java basicsdate: 2024-03-23 11:07:28tags:---[... 博客内容（支持 Markdown 和 html 进行排版） ...]</code></pre><p>这里有两点要注意：</p><ul><li>需要使用 Markdown 格式来排版文章</li><li>我写文章用的编辑器是 <a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a></li></ul><hr><h3 id="预览你的文章"><a href="#预览你的文章" class="headerlink" title="预览你的文章"></a>预览你的文章</h3><p>写好文章之后，使用 <code>hexo s</code> 开启服务器，然后打开浏览器，输入网址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 便可以预览写好的文章。</p><p>修改文章内容之后，只需要刷新浏览器页面就可以立刻看到效果。</p><hr><h3 id="更改文章标签"><a href="#更改文章标签" class="headerlink" title="更改文章标签"></a>更改文章标签</h3><p>你也许会给你的文章打上标签（tags）进行分类，但是后期如果想更改，会发现用 <code>hexo clean</code> 命令无法更新网页上博客的标签。尤其是当你删除某个标签之后，发现旧标签始终存在。</p><p>这时可以手动删除 <code>/blog/public</code> 文件夹，然后再用 <code>hexo clean</code> 和 <code>hexo g</code> 两个命令就可以了。你过去的各种标签被保存（缓存）在 <code>public/tags</code> 文件夹中，只要这个文件夹不更新，你网页上的旧标签也会继续存在。<br><strong>注意</strong>，更改完后本地也许要 <code>hexo s</code> 重开 server 才能看到改动。</p><pre><code class="lang-plaintext">---title: 用 Hexo 搭建自定义博客date: 2016-10-08 14:45:13tags: 旧标签1 旧标签2 旧标签3---[... 博客内容 ...]</code></pre><hr><h3 id="给文章加密"><a href="#给文章加密" class="headerlink" title="给文章加密"></a>给文章加密</h3><p>这里我们使用的是 <a href="https://github.com/D0n9X1n/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt</a> 这个插件。</p><p><strong>第一步</strong>，使用 npm 来安装 hexo-blog-encrypt：</p><pre><code class="lang-bash"># --save 是确保插件记录在 package.jason 文件中，方便之后多终端同步npm install --save hexo-blog-encrypt</code></pre><p><strong>第二步</strong>，更改根目录下的文件 <code>~/Documents/blog/_config.yml</code> ，增加 <strong>encrypt</strong> 字段：</p><pre><code class="lang-yml"># Security## Docs: https://github.com/D0n9X1n/hexo-blog-encryptencrypt: # hexo-blog-encrypt  abstract: 有东西被加密了, 请输入密码查看  message: 您好, 这里需要密码  wrong_pass_message: 抱歉, 密码不对</code></pre><p><strong>第三步</strong>，将 <strong>password</strong> 字段添加到要加密的文章的信息头，就像这样：</p><pre><code class="lang-plaintext">---title: Hello Worlddate: 2016-03-30 21:18:02password: hello---[... 博客内容 ...]</code></pre><p><strong>第四步</strong>，重启以激活新插件 <a href="https://github.com/D0n9X1n/hexo-blog-encrypt" target="_blank" rel="noopener">hexo-blog-encrypt</a>：</p><pre><code class="lang-bash">$ hexo clean   ## 清空缓存$ hexo g       ## 生成静态页面至 public 目录$ hexo s       ## 打开本地服务器预览效果</code></pre><p>PS:<br>按照上方文章的信息头添加 <strong>password</strong> 字段后，内容中的代码高亮效果会消失<br>输入密码解密文章之后，可以通过页面最底部的按钮来重新加密文章<br>更多设置请参考 <code>hexo-blog-encrypt</code> 的 Github</p><hr><h3 id="把博客部署到-Github-上"><a href="#把博客部署到-Github-上" class="headerlink" title="把博客部署到 Github 上"></a>把博客部署到 Github 上</h3><p>先到 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 上申请一个账号，然后新建一个 <code>repository</code>，命名为：</p><pre><code>你的用户名.github.io</code></pre><p><code>注意！</code>这里需要严格按照这种格式命名，比如我的 Github 用户名是 <code>chpwang</code>，新建的 <code>repository</code> 就要叫：</p><pre><code class="lang-plaintext">chpwang.github.io</code></pre><p>然后在 <code>~/Documents/blog</code> 文件夹里找到 <code>_config.yml</code> 文件进行编辑，加入以下设置：</p><pre><code class="lang-yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo:     github: git@github.com:你的用户名/你的用户名.github.io.git</code></pre><p>接下来，每次更新自己的文章之后，使用这三条命令进行部署</p><pre><code class="lang-bash">$ hexo clean   ## 清空缓存$ hexo g       ## 生成静态页面至 public 目录$ hexo d       ## 部署到 GitHub## 如果部署的时候卡住没反应（no response），可以加上 debug 参数查看输出日志（log）$ hexo d -debug</code></pre><p>部署完毕之后，打开浏览器输入网址 <a href="https://你的用户名.github.io" target="_blank" rel="noopener">https://你的用户名.github.io</a> 就能看到部署上去的博客网页了。</p><p>如果想进阶使用 Hexo 的博客方案，请继续阅读<a href="/2016/10/08/sync-blog-between-multiple-Macs/">多台电脑间的 Hexo 博客同步</a></p><hr><h3 id="后续可能的问题"><a href="#后续可能的问题" class="headerlink" title="后续可能的问题:"></a>后续可能的问题:</h3><p>有时部署会遇到卡住没反应的问题，当使用 <code>hexo d -debug</code> 命令后，发现日志循环输出 <code>0 files generated in 81 ms</code>， 这可能是开启了 Github 的二次验证（2FA）导致的。解决方案要不就是重新绑定 Github 上的 <strong>SSH Key</strong>，或者根据<a href="http://fezl.me/2017/05/20/GitHub二次验证带来的问题/" target="_blank" rel="noopener">这里</a>设置 Personal access tokens 后用 <strong>https</strong> 地址来部署</p><p>如果还没解决，可以参考以下案例：</p><ul><li><a href="https://github.com/hexojs/hexo/issues/3182" target="_blank" rel="noopener">hexo d 部署卡住</a></li><li><a href="http://duanyifu.com/2016/08/23/hexo-deploy-problem/" target="_blank" rel="noopener">hexo deploy 命令卡住的奇怪问题</a></li><li><a href="https://blog.csdn.net/jingbin_/article/details/80617210" target="_blank" rel="noopener">用 hexo d 命令部署的时候总是会卡住很久，查看日志发现信息一直在循环</a></li><li><a href="https://github.com/hexojs/hexo/issues/1478" target="_blank" rel="noopener">hexo deploy 时不断 Error</a></li></ul><hr><p>另一种常见的报错如下，这是网络连接问题导致的，需要换个网络环境。要注意各种终端（Terminal）的流量默认不走代理。要使用增强模式之类的设置。更多内容参考<a href="https://www.alankeene.com/2019/0702/Connection-reset-by-peer.html" target="_blank" rel="noopener">解决 hexo d 提示：ssh_exchange_identification：read：Connection reset by peer 的问题</a></p><pre><code class="lang-bash">$ hexo d......kex_exchange_identification: read: Connection reset by peer......</code></pre><hr><p>第三种报错可能是许久不更新博客导致的。具体表现是，久不更新而再次 <code>hexo d</code> 部署推送更新，本来正常的博客页面会因此推送无法正常显示。<br>有可能会看到 <strong>Github</strong> 的报错：<code>There isn&#39;t a GitHub Pages site here.</code><br>此时，去到博客所在的 <strong>Repository</strong>（通常是<code>用户名.github.io</code>）页面，然后 <code>Settings</code> -&gt; <code>Pages</code> -&gt; <code>Custom domain</code> 重新设置一下自定义的网址。然后等个十几分钟的 <code>DNS check</code> 就好了。等待期间，博客页面可能会显示一片空白（前面的报错没有了，但还看不到任何网页内容）。<br>当然，你的自定义域名需要通过 Github 认证：<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages" target="_blank" rel="noopener">Verifying your custom domain for GitHub Pages</a></p><hr><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a><code>打赏</code></h3><p><img id="donate_QR_Code" src="/images/donate.jpg" alt="QR Code for donation"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从商业版的 Logdown 到自定义的 Hexo</title>
      <link href="/2016/09/19/From-Logdown-to-Hexo/"/>
      <url>/2016/09/19/From-Logdown-to-Hexo/</url>
      
        <content type="html"><![CDATA[<h3 id="再见，Logdown"><a href="#再见，Logdown" class="headerlink" title="再见，Logdown"></a>再见，Logdown</h3><p>这是一个追求效率的时代。上个世纪的人是无法想象21世纪“竟然”会有人愿意花钱买时间的，更别说花 5、6 万元去上个培训班了。</p><p>从这个角度看，长篇的文字虽然仍然有大量的需求，但「 博客 」这类形式的载体其实已经严重过时，它无法满足这个时代对于知识的快节奏要求。</p><p>可是，博客在另一方面却<strong>始终</strong>悄然影响着另一种群体，那就是写博客的人（没错，不是看的人，而是写的人）。关于这一点，可以先记住一个结论：<strong>写着写着，就成长了</strong>。</p><p><a href="http://logdown.com" target="_blank" rel="noopener">Logdown</a> 这一商业博客平台在最近一段时期扮演了我成长过程里的重要推进角色，它以上手快并搭配有强大的 Markdown 编辑器著称。当然，它也以排版差，长得丑而令人纠结。所以，既然现在高强度的编程训练已经告一段落，也就是时候搬家了。</p><blockquote><p>这个时代的博客对于我们这种人来说，已经变得更多的是写给自己而不是别人看的了，所以自己舒服最重要。舒适的排版也有利于激发写作的欲望。</p><footer><strong>杨一工</strong></footer></blockquote><p>写作有一个<strong>意义深远</strong>的好处，即它能锻炼玩家「从混沌的信息中识别出精华」的能力。当你写得越多，写得越好，你也就更容易识别出哪些是好文章，哪些是好东西，甚至识别出哪些玩家是真正的高手。</p><p>举例来说：</p><blockquote><p>@吃我一记面目全非腿：不懂就问，一体盆很难打理吗？我还以为搞卫生很方便<br>@大喵一号M：非要一体盆就用可丽耐</p><p>根据以上对话，可以得出结论：</p><p>1、<strong>就用</strong>：大喵认为可丽耐是一体盆这个类别中最好用的产品；<br>2、<strong>非要</strong>：可丽耐也不好，有比一体盆更好用的——非要吃屎，就吃巧克力味的；</p><footer><strong>杨一工</strong></footer></blockquote><p>还有另外一个有趣的案例：</p><blockquote><p>小米官方：「小米关注元宇宙周边相关机会，已经进行了不少相关技术储备。」</p><p>翻译如下：</p><p>1、<strong>关注</strong>：旁观；<br>2、<strong>已经</strong>：不准备做多余的动作和投入；<br>3、<strong>不少相关技术</strong>：「元宇宙」就是个大杂烩；<br>4、<strong>储备</strong>：技术早已有了，所谓元宇宙无非是新瓶装旧酒。</p><p>总结一下，小米说的是：「我们不追这个烂热点，我们就袖手旁观。」</p><footer><strong>Stephen Chu</strong></footer></blockquote><p>怎么样？能稍微体会到提取文字背后宝贵信息的威力了吗？</p><p>PS：<br>王大喵对可丽耐的真正观点：“比岩板好打理一万倍，感觉比陶瓷盆还光滑好擦一些，正常使用不会渗色，唯一缺点就是软，最怕保洁阿姨的钢丝球。浴室硬物磕碰概率更低，可丽耐台面可以用厨房，盆不太行。”</p><hr><h3 id="一些怀旧、惶恐和奇遇"><a href="#一些怀旧、惶恐和奇遇" class="headerlink" title="一些怀旧、惶恐和奇遇"></a>一些怀旧、惶恐和奇遇</h3><p>我的博客生涯始于初中。在实力强劲的<strong>心如止水</strong>同学的带领下，于<a href="http://blog.cersp.com" target="_blank" rel="noopener">成长博客::CERSP BLOG</a><strong>一区</strong>建立了人生中的第一个<a href="http://blog.cersp.com/22635.aspx" target="_blank" rel="noopener">“专栏”</a>。说是专栏，实际我应该是当成某种「朋友圈」来维护的，发的都是各种「装X」的东西，现在看来令人赧颜而伤感。</p><p><strong>哼</strong>！还好这网站<strong>主动</strong>把博客里所有让我害羞的内容都清空了（也许是因为网站易主，为了缩减运营成本）。</p><p>……还好在它清空前我已经完成备份。奶奶的，差一点就<strong>痛失</strong>自己当年的“无敌”文字。</p><p>当初这网站可能是跟<strong>止水</strong>关系较好的人运营的，线索来自她的账户名（其文也常上首页，令人眼红）：</p><ul><li><a href="http://blog.cersp.com/index/1000033.jspx" target="_blank" rel="noopener">心如止水</a>博客登录帐号为: 16666@cersp.com</li><li>对比之下，我的博客登录帐号则是: 22635@cersp.com ，没她那么六</li></ul><blockquote><p>爱，它像空气一样，我们赖以生存，却常常忘了它的存在。</p><footer><strong>心如止水</strong></footer></blockquote><p>说起来，我的精英邻居<strong>雪岸雕旗</strong>老师也在上面有<a href="http://blog.cersp.com/17824.aspx" target="_blank" rel="noopener">专栏</a>哦。她初中时期的文字<strong>就已经</strong>非常精英：</p><blockquote><p>两个人可以看见完全一样的东西，却可能拥有完全不一样的思想。</p><p>我懂了……</p><footer><strong>节选自雪岸雕旗的《我懂了》，2006-01-25 18:42</strong></footer></blockquote><blockquote><p>“两个人可以看见完全一样的东西，却可能拥有完全不一样的思想。”<br>——我最喜欢这一句了！<br>…<br>…<br>再远的路，只要去走，就没有到不了的地方。<br>我，也懂了……</p><footer><strong>节选自心如止水评《我懂了》，2006-01-26 16:34</strong></footer></blockquote><p>中学之后的多年时间里，对于写作领域，我处于视而不见的“梦游”状态。然后命运的邂逅发生了。紧接着台妹引导了我的觉醒，让我重新认识到<strong>日记</strong>和<strong>周记</strong>的巨大威力。一切发生得太快，是一次令人<strong>惶恐而后怕</strong>的脱胎换骨。<strong>恐</strong>的是自己配不上如此绝世武功，<strong>怕</strong>的是我的人生轨迹原本通往的只是一个悲惨的虚无之境……</p><p>台妹所参与创立的、她认为是世界上最好用的 <a href="http://logdown.com" target="_blank" rel="noopener">Logdown</a> 网站我<a href="http://chpwang-blog.logdown.com/archives" target="_blank" rel="noopener">上手</a>后觉得极其难用（约翰·罗梅罗的影响），尤其是默认界面。但这不妨碍她通过哄骗我们定期在 Logdown 上写文章的方式传授她的观念：<strong>以教为学。如果没有要教的学生，就把将来的自己当作一个。</strong></p><p>博客和笔记本的区别是，博客要给别人看，比笔记本的文字要更加严肃、更花心思。</p><p>再后来的进阶，就是精英邻居<a href="http://blog.cersp.com/17824.aspx" target="_blank" rel="noopener">雪岸雕旗</a>随口的一句恭维触发开坑的<a href="/tags/Miscellaneous/">连载系列</a>了。该系列非常调皮、很是嚣张、十分<strong>小心眼</strong>。我自己也是常看常新，跟着学到不少。我甚至都不敢经常看，不然会忍不住和杨一工更新最新的思考，很耗时间。</p><hr><h3 id="好吧，Hexo"><a href="#好吧，Hexo" class="headerlink" title="好吧，Hexo"></a>好吧，Hexo</h3><p>Hexo 其实说不上比 Logdown 更好用，不过它对于排版有着更大的潜力。网上的教程虽然很多，可要打造一个自己的风格仍然很麻烦——Theme（也就是博客的个性化主题）的开发者们经常有逻辑混乱的代码，所以你不得不使用十八般武艺，甚至重写一部分代码才能实现你想要的效果。</p><p>这，是自定义的<strong>代价</strong>。</p><p>不管怎么样，捣鼓了两天总算是勉强部署好我要的风格了。星辰大海，我来啦~</p><pre><code class="lang-bash">$ hexo new &quot;postName&quot;       ## 新建文章$ hexo new page &quot;pageName&quot;  ## 新建页面$ hexo clean                ## 清空缓存$ hexo generate             ## 生成静态页面至 public 目录$ hexo server               ## 开启 Server（默认网址 http://localhost:4000/，&#39;ctrl + c&#39; 退出）$ hexo deploy               ## 部署到 GitHub</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Miscellaneous </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
